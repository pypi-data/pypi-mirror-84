cp -rf py3.6/examples .
cp -rf py3.6/doc .
cp -f py3.6/index.html .
cp -rf Python-3.7.0rc1/Modules/_multiprocessing Modules/_multiprocess
cp -rf Python-3.7.0rc1/Lib/multiprocessing multiprocess
cp -rf Python-3.7.0rc1/Lib/test/*test_multiprocessing*.py multiprocess/tests/

# ----------------------------------------------------------------------
diff ../Python-3.7.0rc1/Lib/test/test_multiprocessing_fork.py Python-3.7.3/Lib/test/test_multiprocessing_fork.py 
3a4
> import sys
8a10,14
> if sys.platform == "win32":
>     raise unittest.SkipTest("fork is not available on Windows")
> 
> if sys.platform == 'darwin':
>     raise unittest.SkipTest("test may crash on macOS (bpo-33725)")
diff ../Python-3.7.0rc1/Lib/test/test_multiprocessing_forkserver.py Python-3.7.3/Lib/test/test_multiprocessing_forkserver.py 
3a4
> import sys
8a10,12
> if sys.platform == "win32":
>     raise unittest.SkipTest("forkserver is not available on Windows")
> 
diff ../Python-3.7.0rc1/Lib/test/test_multiprocessing_main_handling.py Python-3.7.3/Lib/test/test_multiprocessing_main_handling.py 
57d56
<     p = Pool(5)
59,64c58,67
<     p.map_async(f, [1, 2, 3], callback=results.extend)
<     deadline = time.time() + 60 # up to 60 s to report the results
<     while not results:
<         time.sleep(0.05)
<         if time.time() > deadline:
<             raise RuntimeError("Timed out waiting for results")
---
>     with Pool(5) as pool:
>         pool.map_async(f, [1, 2, 3], callback=results.extend)
>         start_time = time.monotonic()
>         while not results:
>             time.sleep(0.05)
>             # up to 1 min to report the results
>             dt = time.monotonic() - start_time
>             if dt > 60.0:
>                 raise RuntimeError("Timed out waiting for results (%.1f sec)" % dt)
> 
66a70,71
> 
>     pool.join()
85d89
< p = Pool(5)
87,92c91,100
< p.map_async(int, [1, 4, 9], callback=results.extend)
< deadline = time.time() + 10 # up to 10 s to report the results
< while not results:
<     time.sleep(0.05)
<     if time.time() > deadline:
<         raise RuntimeError("Timed out waiting for results")
---
> with Pool(5) as pool:
>     pool.map_async(int, [1, 4, 9], callback=results.extend)
>     start_time = time.monotonic()
>     while not results:
>         time.sleep(0.05)
>         # up to 1 min to report the results
>         dt = time.monotonic() - start_time
>         if dt > 60.0:
>             raise RuntimeError("Timed out waiting for results (%.1f sec)" % dt)
> 
94a103,104
> 
> pool.join()
diff Modules/_multiprocess/semaphore.c Python-3.7.0rc1/Modules/_multiprocessing/semaphore.c 
10c10
< #include "multiprocess.h"
---
> #include "multiprocessing.h"
204c204
< // ifndef HAVE_SEM_TIMEDWAIT
---
> #ifndef HAVE_SEM_TIMEDWAIT
265c265
< // endif /* !HAVE_SEM_TIMEDWAIT */
---
> #endif /* !HAVE_SEM_TIMEDWAIT */
629c629
<     /* tp_name           */ "_multiprocess.SemLock",
---
>     /* tp_name           */ "_multiprocessing.SemLock",
diff Modules/_multiprocess/multiprocess.c Python-3.7.0rc1/Modules/_multiprocessing/multiprocessing.c
10c10
< #include "multiprocess.h"
---
> #include "multiprocessing.h"
144c144
<     "_multiprocess",
---
>     "_multiprocessing",
156c156
< PyInit__multiprocess(void)
---
> PyInit__multiprocessing(void)
diff Modules/_multiprocess/multiprocess.h Python-3.7.0rc1/Modules/_multiprocessing/multiprocessing.h
1,2c1,2
< #ifndef MULTIPROCESS_H
< #define MULTIPROCESS_H
---
> #ifndef MULTIPROCESSING_H
> #define MULTIPROCESSING_H
103c103
< #endif /* MULTIPROCESS_H */
---
> #endif /* MULTIPROCESSING_H */
diff multiprocess/__init__.py Python-3.7.0rc1/Lib/multiprocessing/__init__.py
18,19d17
< __version__ = '0.70.6.dev0'
< 
diff multiprocess/connection.py Python-3.7.0rc1/Lib/multiprocessing/connection.py
21,24c21
< try:
<     import _multiprocess as _multiprocessing
< except ImportError:
<     import _multiprocessing
---
> import _multiprocessing
Common subdirectories: multiprocess/dummy and Python-3.7.0rc1/Lib/multiprocessing/dummy
diff multiprocess/forkserver.py Python-3.7.0rc1/Lib/multiprocessing/forkserver.py
106c106
<             cmd = ('from multiprocess.forkserver import main; ' +
---
>             cmd = ('from multiprocessing.forkserver import main; ' +
diff multiprocess/managers.py Python-3.7.0rc1/Lib/multiprocessing/managers.py
464c464
< listener_client = { #XXX: register dill?
---
> listener_client = {
1176c1176
<     The `multiprocess.Manager()` function creates started instances of
---
>     The `multiprocessing.Manager()` function creates started instances of
diff multiprocess/popen_fork.py Python-3.7.0rc1/Lib/multiprocessing/popen_fork.py
44c44
<                 from multiprocess.connection import wait
---
>                 from multiprocessing.connection import wait
diff multiprocess/popen_forkserver.py Python-3.7.0rc1/Lib/multiprocessing/popen_forkserver.py
59c59
<             from multiprocess.connection import wait
---
>             from multiprocessing.connection import wait
diff multiprocess/queues.py Python-3.7.0rc1/Lib/multiprocessing/queues.py
22,25c22
< try:
<     import _multiprocess as _multiprocessing
< except ImportError:
<     import _multiprocessing
---
> import _multiprocessing
diff multiprocess/reduction.py Python-3.7.0rc1/Lib/multiprocessing/reduction.py
15,18c15
< try:
<     import dill as pickle
< except ImportError:
<     import pickle
---
> import pickle
37c34
<     '''Pickler subclass used by multiprocess.'''
---
>     '''Pickler subclass used by multiprocessing.'''
253c250
<     used in multiprocess.'''
---
>     used in multiprocessing.'''
diff multiprocess/semaphore_tracker.py Python-3.7.0rc1/Lib/multiprocessing/semaphore_tracker.py
19,22c19
< try: 
<     import _multiprocess as _multiprocessing
< except ImportError:
<     import _multiprocessing
---
> import _multiprocessing
66c63
<             cmd = 'from multiprocess.semaphore_tracker import main;main(%d)'
---
>             cmd = 'from multiprocessing.semaphore_tracker import main;main(%d)'
diff multiprocess/spawn.py Python-3.7.0rc1/Lib/multiprocessing/spawn.py
86c86
<         prog = 'from multiprocess.spawn import spawn_main; spawn_main(%s)'
---
>         prog = 'from multiprocessing.spawn import spawn_main; spawn_main(%s)'
diff multiprocess/synchronize.py Python-3.7.0rc1/Lib/multiprocessing/synchronize.py
17,20c17
< try: 
<     import _multiprocess as _multiprocessing
< except ImportError:
<     import _multiprocessing
---
> import _multiprocessing
32,40c29,34
<     from _multiprocess import SemLock, sem_unlink
< except ImportError:
<     try:
<         from _multiprocessing import SemLock, sem_unlink
<     except (ImportError):
<         raise ImportError("This platform lacks a functioning sem_open" +
<                           " implementation, therefore, the required" +
<                           " synchronization primitives needed will not" +
<                           " function, see issue 3770.")
---
>     from _multiprocessing import SemLock, sem_unlink
> except (ImportError):
>     raise ImportError("This platform lacks a functioning sem_open" +
>                       " implementation, therefore, the required" +
>                       " synchronization primitives needed will not" +
>                       " function, see issue 3770.")
Only in multiprocess: tests
diff multiprocess/util.py Python-3.7.0rc1/Lib/multiprocessing/util.py
38c38
< LOGGER_NAME = 'multiprocess'
---
> LOGGER_NAME = 'multiprocessing'
62c62
<     Returns logger used by multiprocess
---
>     Returns logger used by multiprocessing
# ----------------------------------------------------------------------
REPLACED "MULTIPROCESSING" with "MULTIPROCESS"
REPLACED "from multiprocessing" with "from multiprocess"
REPLACED "from _multiprocessing" with "from _multiprocess"
REPLACED "import _multiprocessing" with "import _multiprocess as _multiprocessing"
REPLACED "multprocessing" with "multiprocess" wherever else relevant...
REPLACED "import pickle" with "import dill as pickle"
# ----------------------------------------------------------------------
diff Python-3.7.0rc1/Modules/_multiprocessing/semaphore.c Python-3.7.3/Modules/_multiprocessing/semaphore.c
452,453c452,454
<         if (name_copy == NULL)
<             goto failure;
---
>         if (name_copy == NULL) {
>             return PyErr_NoMemory();
>         }
476c477,479
<     _PyMp_SetError(NULL, MP_STANDARD_ERROR);
---
>     if (!PyErr_Occurred()) {
>         _PyMp_SetError(NULL, MP_STANDARD_ERROR);
>     }
diff Python-3.7.0rc1/Lib/multiprocessing/managers.py Python-3.7.3/Lib/multiprocessing/managers.py
20a21
> import time
22d22
< from time import time as _time
1048c1048
<             endtime = _time() + timeout
---
>             endtime = time.monotonic() + timeout
1054c1054
<                 waittime = endtime - _time()
---
>                 waittime = endtime - time.monotonic()
1137,1138c1137,1138
<     '__contains__', '__delitem__', '__getitem__', '__len__',
<     '__setitem__', 'clear', 'copy', 'get', 'has_key', 'items',
---
>     '__contains__', '__delitem__', '__getitem__', '__iter__', '__len__',
>     '__setitem__', 'clear', 'copy', 'get', 'items',
1140a1141,1143
> DictProxy._method_to_typeid_ = {
>     '__iter__': 'Iterator',
>     }
diff Python-3.7.0rc1/Lib/multiprocessing/popen_spawn_win32.py Python-3.7.3/Lib/multiprocessing/popen_spawn_win32.py
20a21,33
> 
> def _path_eq(p1, p2):
>     return p1 == p2 or os.path.normcase(p1) == os.path.normcase(p2)
> 
> WINENV = (hasattr(sys, '_base_executable') and
>           not _path_eq(sys.executable, sys._base_executable))
> 
> 
> def _close_handles(*handles):
>     for handle in handles:
>         _winapi.CloseHandle(handle)
> 
> 
42a56,66
>         python_exe = spawn.get_executable()
> 
>         # bpo-35797: When running in a venv, we bypass the redirect
>         # executor and launch our base Python.
>         if WINENV and _path_eq(python_exe, sys.executable):
>             python_exe = sys._base_executable
>             env = os.environ.copy()
>             env["__PYVENV_LAUNCHER__"] = sys.executable
>         else:
>             env = None
> 
47,48c71,72
<                     spawn.get_executable(), cmd,
<                     None, None, False, 0, None, None, None)
---
>                     python_exe, cmd,
>                     env, None, False, 0, None, None, None)
diff Python-3.7.0rc1/Lib/multiprocessing/queues.py Python-3.7.3/Lib/multiprocessing/queues.py
98c98
<                 deadline = time.time() + timeout
---
>                 deadline = time.monotonic() + timeout
103c103
<                     timeout = deadline - time.time()
---
>                     timeout = deadline - time.monotonic()
diff Python-3.7.0rc1/Lib/multiprocessing/reduction.py Python-3.7.3/Lib/multiprocessing/reduction.py
153c153
<         msg, ancdata, flags, addr = sock.recvmsg(1, socket.CMSG_LEN(bytes_size))
---
>         msg, ancdata, flags, addr = sock.recvmsg(1, socket.CMSG_SPACE(bytes_size))
diff Python-3.7.0rc1/Lib/multiprocessing/spawn.py Python-3.7.3/Lib/multiprocessing/spawn.py
33c33
<     WINEXE = (sys.platform == 'win32' and getattr(sys, 'frozen', False))
---
>     WINEXE = getattr(sys, 'frozen', False)
diff Python-3.7.0rc1/Lib/multiprocessing/synchronize.py Python-3.7.3/Lib/multiprocessing/synchronize.py
18,19c18
< 
< from time import time as _time
---
> import time
305c304
<             endtime = _time() + timeout
---
>             endtime = time.monotonic() + timeout
311c310
<                 waittime = endtime - _time()
---
>                 waittime = endtime - time.monotonic()
diff Python-3.7.0rc1/Lib/test/test_multiprocessing_fork.py Python-3.7.3/Lib/test/test_multiprocessing_fork.py 
3a4
> import sys
8a10,14
> if sys.platform == "win32":
>     raise unittest.SkipTest("fork is not available on Windows")
> 
> if sys.platform == 'darwin':
>     raise unittest.SkipTest("test may crash on macOS (bpo-33725)")
diff Python-3.7.0rc1/Lib/test/test_multiprocessing_forkserver.py Python-3.7.3/Lib/test/test_multiprocessing_forkserver.py 
3a4
> import sys
8a10,12
> if sys.platform == "win32":
>     raise unittest.SkipTest("forkserver is not available on Windows")
> 
diff Python-3.7.0rc1/Lib/test/test_multiprocessing_main_handling.py Python-3.7.3/Lib/test/test_multiprocessing_main_handling.py 
57d56
<     p = Pool(5)
59,64c58,67
<     p.map_async(f, [1, 2, 3], callback=results.extend)
<     deadline = time.time() + 60 # up to 60 s to report the results
<     while not results:
<         time.sleep(0.05)
<         if time.time() > deadline:
<             raise RuntimeError("Timed out waiting for results")
---
>     with Pool(5) as pool:
>         pool.map_async(f, [1, 2, 3], callback=results.extend)
>         start_time = time.monotonic()
>         while not results:
>             time.sleep(0.05)
>             # up to 1 min to report the results
>             dt = time.monotonic() - start_time
>             if dt > 60.0:
>                 raise RuntimeError("Timed out waiting for results (%.1f sec)" % dt)
> 
66a70,71
> 
>     pool.join()
85d89
< p = Pool(5)
87,92c91,100
< p.map_async(int, [1, 4, 9], callback=results.extend)
< deadline = time.time() + 10 # up to 10 s to report the results
< while not results:
<     time.sleep(0.05)
<     if time.time() > deadline:
<         raise RuntimeError("Timed out waiting for results")
---
> with Pool(5) as pool:
>     pool.map_async(int, [1, 4, 9], callback=results.extend)
>     start_time = time.monotonic()
>     while not results:
>         time.sleep(0.05)
>         # up to 1 min to report the results
>         dt = time.monotonic() - start_time
>         if dt > 60.0:
>             raise RuntimeError("Timed out waiting for results (%.1f sec)" % dt)
> 
94a103,104
> 
> pool.join()
# ----------------------------------------------------------------------
ADDED *args, **kwds for ForkingPickler in __init__, dump, and dumps
# ----------------------------------------------------------------------
diff Python-3.7.3/Modules/_multiprocessing/semaphore.c Python-3.7.6/Modules/_multiprocessing/semaphore.c
144c144
<                      "value %d", res);
---
>                      "value %u", res);
diff Python-3.7.3/Lib/multiprocessing/managers.py Python-3.7.6/Lib/multiprocessing/managers.py
354c354
<     def create(self, c, typeid, *args, **kwds):
---
>     def create(*args, **kwds):
357a358,377
>         if len(args) >= 3:
>             self, c, typeid, *args = args
>         elif not args:
>             raise TypeError("descriptor 'create' of 'Server' object "
>                             "needs an argument")
>         else:
>             if 'typeid' not in kwds:
>                 raise TypeError('create expected at least 2 positional '
>                                 'arguments, got %d' % (len(args)-1))
>             typeid = kwds.pop('typeid')
>             if len(args) >= 2:
>                 self, c, *args = args
>             else:
>                 if 'c' not in kwds:
>                     raise TypeError('create expected at least 2 positional '
>                                     'arguments, got %d' % (len(args)-1))
>                 c = kwds.pop('c')
>                 self, *args = args
>         args = tuple(args)
> 
579c599
<     def _create(self, typeid, *args, **kwds):
---
>     def _create(*args, **kwds):
582a603,605
>         self, typeid, *args = args
>         args = tuple(args)
> 
diff Python-3.7.3/Lib/multiprocessing/resource_sharer.py Python-3.7.6/Lib/multiprocessing/resource_sharer.py
62c62
<     '''Manager for resouces using background thread.'''
---
>     '''Manager for resources using background thread.'''
diff Python-3.7.3/Lib/multiprocessing/util.py Python-3.7.6/Lib/multiprocessing/util.py
108a109,117
> def _remove_temp_dir(rmtree, tempdir):
>     rmtree(tempdir)
> 
>     current_process = process.current_process()
>     # current_process() can be None if the finalizer is called
>     # late during Python finalization
>     if current_process is not None:
>         current_process._config['tempdir'] = None
> 
116c125,128
<         Finalize(None, shutil.rmtree, args=[tempdir], exitpriority=-100)
---
>         # keep a strong reference to shutil.rmtree(), since the finalizer
>         # can be called late during Python shutdown
>         Finalize(None, _remove_temp_dir, args=(shutil.rmtree, tempdir),
>                  exitpriority=-100)
# ----------------------------------------------------------------------
diff Python-3.7.6/Lib/multiprocessing/popen_spawn_win32.py Python-3.7.7/Lib/multiprocessing/popen_spawn_win32.py
72c72
<                     env, None, False, 0, None, None, None)
---
>                     None, None, False, 0, env, None, None)
# ----------------------------------------------------------------------
diff Python-3.7.7/Lib/multiprocessing/connection.py Python-3.7.9/Lib/multiprocessing/connection.py
105c105
<     elif type(address) is str:
---
>     elif type(address) is str or util.is_abstract_socket_namespace(address):
590c590,591
<         if family == 'AF_UNIX':
---
>         if family == 'AF_UNIX' and not util.is_abstract_socket_namespace(address):
>             # Linux abstract socket namespaces do not need to be explicitly unlinked
Common subdirectories: Python-3.7.7/Lib/multiprocessing/dummy and Python-3.7.9/Lib/multiprocessing/dummy
diff Python-3.7.7/Lib/multiprocessing/forkserver.py Python-3.7.9/Lib/multiprocessing/forkserver.py
41a42,60
>     def _stop(self):
>         # Method used by unit tests to stop the server
>         with self._lock:
>             self._stop_unlocked()
> 
>     def _stop_unlocked(self):
>         if self._forkserver_pid is None:
>             return
> 
>         # close the "alive" file descriptor asks the server to stop
>         os.close(self._forkserver_alive_fd)
>         self._forkserver_alive_fd = None
> 
>         os.waitpid(self._forkserver_pid, 0)
>         self._forkserver_pid = None
> 
>         os.unlink(self._forkserver_address)
>         self._forkserver_address = None
> 
119c138,139
<                 os.chmod(address, 0o600)
---
>                 if not util.is_abstract_socket_namespace(address):
>                     os.chmod(address, 0o600)
diff Python-3.7.7/Lib/multiprocessing/managers.py Python-3.7.9/Lib/multiprocessing/managers.py
53c53
<     Type to uniquely indentify a shared object
---
>     Type to uniquely identify a shared object
808c808
<         Try to call a method of the referrent and return a copy of the result
---
>         Try to call a method of the referent and return a copy of the result
diff Python-3.7.7/Lib/multiprocessing/util.py Python-3.7.9/Lib/multiprocessing/util.py
104a105,127
> 
> # Abstract socket support
> 
> def _platform_supports_abstract_sockets():
>     if sys.platform == "linux":
>         return True
>     if hasattr(sys, 'getandroidapilevel'):
>         return True
>     return False
> 
> 
> def is_abstract_socket_namespace(address):
>     if not address:
>         return False
>     if isinstance(address, bytes):
>         return address[0] == 0
>     elif isinstance(address, str):
>         return address[0] == "\0"
>     raise TypeError('address type of {address!r} unrecognized')
> 
> 
> abstract_sockets_supported = _platform_supports_abstract_sockets()
> 
435a459,479
> 
> 
> def _cleanup_tests():
>     """Cleanup multiprocessing resources when multiprocessing tests
>     completed."""
> 
>     from test import support
> 
>     # cleanup multiprocessing
>     process._cleanup()
> 
>     # Stop the ForkServer process if it's running
>     from multiprocessing import forkserver
>     forkserver._forkserver._stop()
> 
>     # bpo-37421: Explicitly call _run_finalizers() to remove immediately
>     # temporary directories created by multiprocessing.util.get_temp_dir().
>     _run_finalizers()
>     support.gc_collect()
> 
>     support.reap_children()

