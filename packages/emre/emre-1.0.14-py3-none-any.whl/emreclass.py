########################################################################################################
#
# emreclass.py
#
# This module defines the EMRE class used to instantiate instances of the eMRE expert system 
# machine reasoning framework
#
# Each instance of the EMRE class implements an independent machine reasoning environment with
# indepedent instances of the CLIPs expert system.  Multiple instances can be run simultaneously.
# A common way to deploy EMRE is to instantiate an EMRE instance for each use case
#
# EMRE can be run "on-box" in the guestshell on XE and NX-OS platforms and in a Docker container
# on XR eXR enabled platforms in the app-hosting environment
#
# EMRE can be run "off-box" on PC, MAC or Linux platforms
#
# EMRE execution is controlled by content contained in a collection of files loaded by EMRE on startup:
#
#   facts - This file contains information used by EMRE to collect "FACTS" from the device.  Also contains
#           "control" flags used to control EMRE operating modes and execution
#   rules - This file contains the CLIPS rules and other CLIPS constructs used to implement the use case
#   tests - This optional file contains FACTS used to enable execution of CLIPS using pre-defined fact data
#           instead of collecting FACTS from the device.  When 'test-facts' is enabled EMRE does not interact
#           with devices and instead reads and asserts lists of facts from the file.  This can be used
#           for testing and demonstrating EMRE use cases
#   log - This optional file when 'debug-logging' is enabled can be used to persist messages generated by EMRE in
#         a log file on the device, typically stored on bootflash
#
#
##### Running EMRE #####
#
# eMRE is run on-box or off-box using a command of the form below.  The relative paths to the control files are parameters. 
# If no parameters are specified EMRE finds files in the directory EMRE is started in with names 'facts.txt', 'rules.clp',
# 'tests.txt', and 'emre-log.txt'
#
#   $ python runemre.py --facts=input/assurance/memory-leak.txt --rules=input/assurance/memory-leak.clp  
#                       --tests=input/assuracne/tests.txt --log=bootflash/emre-log.txt
#
# Execution is stopped by CTRL-/ in the window where the script is started
#
# For information contact: Peter Van Horne petervh@cisco.com
#
###################################################################################################################
import ncclient.manager
from ncclient.xml_ import to_ele
from lxml import etree
import xml.dom.minidom
import xml.etree.ElementTree as ET
import clips
import datetime
from datetime import datetime
import time
import os
import sys
import logging
import logging.handlers
from logging.handlers import RotatingFileHandler
import imp
import json
import pprint
import copy
import xmltodict
import re
from threading import Timer
import pexpect

try:
    import resource
except:
    pass
#
# If emre is running on a device, import the python cli library for running cli commands in guestshell
#
try:
    import cli
except:
    pass
try:
    from genie_parsers import *
except:
    pass

class EMRE:
    #############################################################################
    #############################################################################
    #############################################################################
    #
    # eMRE entry point - Call this function to load and start CLIPs execution
    #
    #############################################################################
    #############################################################################
    #############################################################################
    def emre(self,flist, model_control, single_run):
        self.emre_init(flist, model_control, single_run)
    #
    # Save start time for this session to include in log files
    # Maintain a counter for the notification logs generated during the session
    #   
        self.control["session-log-count"] = 1
   
    ######################################################################################    
    ######################################################################################
    # while loop runs until interrupted by CTRL-/ or an error occurs that causes the
    # EMRE function to return.
    # Loop continuosly looking for triggering events which include a syslog message
    # containing a string that matches syslog_triggers, an RFC5277 notification including
    # a string that matches the content of a notification or timed execution
    ######################################################################################
    ######################################################################################
        while True:
            self.engine_process()

    def engine_process(self):
        ######################################################################################
        ######################################################################################
        # MAIN RULES ENGINE PROCESSING LOOP
        ######################################################################################
        ######################################################################################

        syslog_trigger = False
        timed_trigger = False
        notification_trigger = False

#######################################################################################
#
# control["run-mode"] = 0 Run after time delay
#
#######################################################################################
        if self.control["run-mode"] == 0:
            self.print_log("\n**** EMRE Notice: Wait for Trigger Event")
            time.sleep(self.control["run-wait"]/1000)
            timed_trigger = True
            timestamp =  datetime.now().strftime("%m-%d-%Y_%H:%M:%S.%f")
            
            self.print_log("\n**** EMRE Notice: Trigger Event: Timed Execution at: " + str(timestamp))

#######################################################################################
#
#   control["run-mode"] = 1 waits for a Syslog message to trigger execution
#   The eMRE script runs a Syslog listener on port 9514 (default Syslog port is 514)
#   Devices sending "logging" Syslog messages should use the eMRE script IP address and
#   port 9514.  Typicall port forwarding must be configured using NAT to map
#   Packets addressed to the hosting device on Port 9514 to forward to the receiver in eMRE
#   Example XR configuration: logging 10.24.121.9 vrf default severity notifications port 9514
#   Example XE configuration: logging host 10.24.72.167 vrf Mgmt-vrf transport udp port 9514
#
#######################################################################################

        if self.control["run-mode"] == 1:
#
# mesq.get() checks to see if there is a message available on the Queue that
# contains device Syslog messages received and processed by "queue_syslog" function.
# If there are no syslog messages in the queue, do not wait
#
            self.print_log("**** EMRE Notice: Wait for Syslog Trigger Event")
#
# script waits to receive a syslog message sent the IP and port defined for the syslog listener
#
            syslog = self.mesq.get()
            timestamp =  datetime.now().strftime("%m-%d-%Y_%H:%M:%S.%f")
            
            self.print_log("\n**** EMRE Notice: Trigger Event: Syslog Message at: " + str(timestamp))
            if self.control["debug-syslog"] == 1:
                self.print_log("**** EMRE Debug: queued Syslog message: ")
                self.print_log(syslog)
                self.print_log("**** EMRE Debug: syslog_triggers: " + str(self.control["syslog-triggers"]))
#
# Test to see if the syslog message receive matches one of the syslog triggering list entries
#
            for trigger in self.control["syslog-triggers"]:
                if self.control["debug-syslog"] == 1:
                    self.print_log("**** EMRE Debug: syslog_trigger: " + str(trigger))
#
# Loop through all match string for the syslog trigger entry.  All of the strings must be found
# in the syslog or the trigger condition is not satisfied
#
                syslog_trigger = False
                for match_string in trigger[0]:
                    if syslog.find(match_string) != -1:
                        syslog_trigger = True
                    elif syslog_trigger == True:
                        syslog_trigger = False
                        break # one of the match_strings was not present in the syslog message

                if syslog_trigger == True:
                    try:
                        if trigger[2] == 'True':
                            self.print_log("**** EMRE Notice: Assert Syslog FACT: " + str(trigger))
                            self.assert_syslog_fact(syslog)
#
#  Check to see if the matching this syslog requires asserting additional facts
#
                        if trigger[1] != []:
                            try:
                                for syslog_fact in trigger[1]:
                                    self.env.assert_string(str(syslog_fact))
                            except Exception as e:
                                self.print_log("%%%%% eMRE Error: Asserting syslog fact: " + str(trigger[1]) + str(e))
                        break
                    except:
                        self.print_log("%%%%% EMRE Error: Asserting syslog fact for: " + str(syslog))

#######################################################################################
#
# control["run-mode"] = 2 Trigger on NETCONF notification
#
#######################################################################################
        if self.control["run-mode"] == 2:

#
# Check for NETCONF notifications from the device
# If netconf notification is received, check if the content of the notification
# Matches one of the "triggers".
# Check to see if the notification contains content that should be used to directly assert a fact
#
#######################################################################################
            try:
#
# block and wait until an RFC5277 NETCONF notification is received
#
                if self.control["single-notify"] == 1:
                    input("\n\nHit Enter to accept one notification event\n\n")
                if self.control["run-mode"] == 2:
                    notification_found = False
                    notif = self.notify_conn.take_notification(block=True)
                    notify_xml = notif.notification_xml
                    if self.control["debug-notify"] == 1:
                        self.print_log("**** EMRE Debug: RFC5277 notification received: " + notify_xml)

######################################################################################
# Test to see if the snmpevents notification included any of the strings that
# are included in the notification_triggers.  If so, run the rules engine
######################################################################################

                    if notify_xml != '':
                        for trigger in self.control["notification-triggers"]:
                            notification_trigger = False
#
# Loop through all match string for the notification.  All of the strings must be found
# in the notification or the trigger condition is not satisfied
# [['BGP', '<clogHistFacility>BGP</clogHistFacility>', 'Down'], 
#  ['(sample-fact (sample-slot sample-value))'], 
#  'false', 
#  ['<clogHistMsgText>(.*)</clogHistMsgText>', 
#   'neighbor.{1}(?P<neighbor>(\S+))', 
#   ['neighbor'], '(bgp-event (device {0}) (neighbor {1}))']]
# 
#                            print("check values: ", str(notify_xml), trigger[0])
                            if all([val in str(notify_xml) for val in trigger[0]]): 
                                notification_trigger = True                        
                                try:
                                    timestamp =  datetime.now().strftime("%m-%d-%Y_%H:%M:%S.%f")
                                    
                                    self.print_log("\n**** EMRE Notice: Triggering Notification Event Found: " + str(trigger[0]) + " at: " + str(timestamp))
                                    if trigger[2] == 'True':
                                        self.print_log("**** EMRE Notice: Assert RFC5277 FACT: " + str(trigger))
                                        self.assert_rfc5277_fact(notify_xml)
#
# Get the event time - Extract syslog mesasge time from notification and translate into seconds since midnight
# Insert the seconds into the generated syslog FACT
# Sample time: <eventTime>2020-09-29T09:47:38+00:00</eventTime>
#
                                    try:
                                        event_seconds = 0
                                        event_content = re.search('<eventTime>(.*)</eventTime>', str(notify_xml)) #extract event_time field from message
                                        p1 = re.compile('.{11}(?P<mtime>(.{8}))') #regex to extract time in seconds
                                        results = p1.match(str(event_content.group(1))) #extract seconds field from message
                                        syslog_time = str(event_content.group(1))
                                        group = results.groupdict() #dictionary contains objects
                                        times = str(group["mtime"]).split(":")
                                        event_seconds = sum(int(x) * 60 ** i for i, x in enumerate(reversed(times)))
                                    except Exception as e:
                                        self.print_log("%%%%% Error generating notification time: " + str(event_content.group(1)) + " " + str(e))
#
# Extract FACTs from the notification message and assert a FACT
# Process in a try clause for backward compatibility with older FACT files that do not have this option
#
                                    if trigger[3] != []:
                                        mdata = trigger[3]
                                        Slog = re.search(str(mdata[0]), str(notify_xml))
                                        SlogClean = Slog.group(1).replace(',',' ')
                                        if self.control["debug-fact"] == 1:
                                            self.print_log("**** EMRE Debug: Notification Syslog: " + str(SlogClean))
                                        p1 = re.compile(str(mdata[1])) #generate regex object
#
# If there is no match generate a logging message
#
                                        if (str(results) == 'none') or (str(results) == 'None'):
                                            self.print_log("**** EMRE Debug: Notification Syslog no data found: " + str(mdata[1]))
                                            break
#
# Build the notification FACT using data parsed from the notification text
#  
                                        try:
                                            results = p1.match(SlogClean) #extract fields from message
                                            group = results.groupdict() #dictionary contains objects
                                            keys = mdata[2] #get the field names
                                            protofact = str(mdata[3]) #string to update with values
                                            if self.control["debug-fact"] == 1:
                                                self.print_log("**** EMRE Debug: Notification Protofact: " + str(protofact))
                                            if len(keys) == 1:
                                                value1 = str(group[str(keys[0])])
                                                notify_fact = protofact.format(str(self.control["mgmt-device"][4]), str(event_seconds), str(value1).replace(' ', '_'), syslog_time)
                                            elif len(keys) == 2:
                                                value1 = str(group[str(keys[0])])
                                                value2 = str(group[str(keys[1])])
                                                notify_fact = protofact.format(str(self.control["mgmt-device"][4]), str(event_seconds), str(value1).replace(' ', '_'), str(value2).replace(' ', '_'), syslog_time)
                                            elif len(keys) == 3:
                                                value1 = str(group[str(keys[0])])
                                                value2 = str(group[str(keys[1])])
                                                value3 = str(group[str(keys[2])])
                                                notify_fact = protofact.format(str(self.control["mgmt-device"][4]), str(event_seconds), str(value1).replace(' ', '_'), str(value2).replace(' ', '_'), str(value3).replace(' ', '_'), syslog_time)
                                            elif len(keys) == 4:
                                                value1 = str(group[str(keys[0])])
                                                value2 = str(group[str(keys[1])])
                                                value3 = str(group[str(keys[2])])
                                                value4 = str(group[str(keys[3])])
                                                notify_fact = protofact.format(str(self.control["mgmt-device"][4]), str(event_seconds), str(value1).replace(' ', '_'), str(value2).replace(' ', '_'), str(value3).replace(' ', '_'), str(value4).replace(' ', '_'), syslog_time)
                                            elif len(keys) == 5:
                                                value1 = str(group[str(keys[0])])
                                                value2 = str(group[str(keys[1])])
                                                value3 = str(group[str(keys[2])])
                                                value4 = str(group[str(keys[3])])
                                                value5 = str(group[str(keys[4])])
                                                notify_fact = protofact.format(str(self.control["mgmt-device"][4]), str(event_seconds), str(value1).replace(' ', '_'), str(value2).replace(' ', '_'), str(value3).replace(' ', '_'), str(value4).replace(' ', '_'), str(value5).replace(' ', '_'), syslog_time)
                                            else:
                                                self.print_log("%%%%% Error notification fact invalid: " + str(trigger[1]) + " " + str(e))
                                                notification = False
                                        except Exception as e:
                                            self.print_log("%%%%% Error FACT: " + str(notify_xml) + " " + str(SlogClean) + " " + str(e))
#
# If trigger[3] is empty there are no values to extract from the notification, assert the static FACT defined in the second list element in the trigger FACT
# for the example above: (sample-fact (sample-slot sample-value))
#
                                    else:
                                        notify_fact = str(trigger[1][0])
                                        if self.control["debug-fact"] == 1:
                                            self.print_log("**** EMRE Debug: Static notification FACT: " + str(notify_fact))
#
# Assert the notification FACT
#
                                    try:
                                        if self.control["debug-fact"] == 1:
                                            self.print_log("**** EMRE Debug: Notification FACT: " + str(notify_fact))
                                        self.env.assert_string(str(notify_fact))
                                    except: 
                                        if self.control["debug-fact"] == 1:
                                            self.print_log("**** EMRE Debug: Notification FACT Exists: " + str(notify_fact))

                                except Exception as e:
                                    self.print_log("%%%%% Error asserting notification fact: " + str(notify_fact) + " " + str(e))
                                break
                            else:
                                if self.control["debug-notify"] == 1:
                                    self.print_log("**** EMRE Debug: RFC5277 Notification Event Does Not Match Trigger - Ignored")

            except Exception as e:
                self.print_log("%%%%% EMRE Error: In notification event processing: " + str(e))
 
#TTT            Timer(5.0, self.rule_timer).start();  #TTT

###################################################################################
#
# Test to see if any triggering event was found
#
###################################################################################
        if syslog_trigger or timed_trigger or notification_trigger:

######################################################################################
#
# For each fact in the fact_list get the operational or configuration data required
# to populate the facts required by the expert system
# Assert the facts in the expert system
# Measure the amount of time required to collect the facts from the device
#
######################################################################################

#####################################################################
#####################################################################
#
# Assert all FACTS here
#
####################################################################
####################################################################
            starttime = time.time()
#
# If test facts are being used, get the facts from the test_data list 
# loaded from the 'tests.txt' file
#
            if self.control["test-facts"] == 1:
                starttime = time.time()
                max_facts = len(self.test_data)
                if self.test_index < max_facts:
                    self.assert_test_facts(self.test_data[self.test_index])
                    self.test_index = self.test_index + 1
                if self.test_index == max_facts:
                    self.test_index = 0
#
# Log time to load test facts
#
                endtime = time.time()
                fact_runtime = endtime - starttime
                self.emre_timing('**** EMRE Time: Load and assert test facts(ms): %8.3f', fact_runtime, "load-test-facts")
#
# If use case requires asserting a FACT to advance the "period" in a state machine in the rules, assert the
# template fact "update-period-fact" at the end of each run of CLIPS
#
                if self.control["update-period"] == 1:  
                    try:
                        self.env.assert_string("(update-period-fact (update TRUE))")
                    except: pass #ignore case where FACT already exists    
#
# If control["test-facts"] not set, read the FACTs from the devices
#
            else:
                starttime = time.time()
                for fact in self.control["fact-list"]:
                    if self.control["debug-fact"] == 1:
                        self.print_log("**** EMRE Debug: Main fact loop: " + str(fact))
                    if fact["fact_type"] == "show_and_assert":
                        if "log_message_while_running" in fact:
                            self.print_log(fact["log_message_while_running"])
                        status = self.show_and_assert_fact(fact)
                    elif fact["fact_type"] == "multitemplate":
                        status = self.get_template_multifacts(fact["data"], 'none', 'none')
                    elif fact["fact_type"] == "multitemplate_protofact":
                        status = self.get_template_multifacts_protofact(fact, 'none', 'none')
                    else:
                        self.print_log("%%%%% EMRE Error: Invalid fact type: " + str(fact))
                    if status != "success":
                        self.print_log("%%%%% EMRE Error: Fact Read Error: " + str(status))
#
# If required assert fact to advance the "period" state in the knowledge base
#
#
# If use case requires asserting a FACT to advance the "period" in a state machine in the rules, assert the
# template fact "update-period-fact" at the end of each run of CLIPS
#
                if self.control["update-period"] == 1:  
                    try:
                        self.env.assert_string("(update-period-fact (update TRUE))")
                    except: pass #ignore case where FACT already exists    

                endtime = time.time()
                fact_runtime = endtime - starttime
                self.emre_timing('**** EMRE Time: Get and process FACTS from devices(ms): %8.3f', fact_runtime, "get-device-facts")
#
# log the FACTS asserted and triggered RULES on the agenda before CLIPs runs 
#
            self.print_clips_info()
#
# If required return clips facts and a dictionary representation of facts in the Service Impact Notification
# FACTs are sent before running clips to capture all facts that were present before the rules were run
#
            self.clips_facts = ''
            self.dict_facts = ''
            if self.control["send-before"] == 1:
                self.send_clips_info()
                self.save_dict_facts()

            for item in self.env.activations():
                root_cause_rule = str(item)
                break

##################################################################################
#
# clips.Run() causes execution of any action functions on the RHS of rules
# These control["actions"] can include: asserting additional FACTS, calling a python function
# adding a message to the service-impact notification
# Compute the run time for the CLIPs rules
#
##################################################################################
            starttime = time.time()
            try:
                self.memory_use("**** EMRE Memory: Before Running Inference Engine in KBytes: ", "before-clips-run")
                self.env.run()
            except Exception as e:
                self.print_log("\n%%%% EMRE Error: Exception when running inference engine " + str(e))
                self.close_sessions()
                sys.exit(0)
            self.memory_use("**** EMRE Memory: After Running Inference Engine in KBytes: ", "after-clips-run")

            endtime = time.time()
            clips_runtime = endtime - starttime
            self.emre_timing('**** EMRE Time: Run Inference Engine(ms): %8.3f\n', clips_runtime, "clips-runtime")
#
# Add facts to service impact notification after CLIPs is run if required
#
            if self.control["send-after"] == 1:
                self.clips_facts = ''
                self.dict_facts = ''
                self.send_clips_info()
                self.save_dict_facts()
#
# Generate service-impact-notification message 
# Include all messages asserted by rules.  Optionally include the CLIPS facts in
# CLIPS fact format and/or in Python dictionary format
#
            try:
                event_time = datetime.now().strftime("%m-%d-%Y_%H:%M:%S.%f")
                impactMessage = ''.join(self.impactList)
                self.impactList = []
#
# Generate RFC5277 formated Service Impact notification message
#
                try:
                    si_notification = self.control["service-impact"].format("EMRE Service Impact Notification: " + str(self.control["use-case"]), impactMessage, self.clips_facts, self.dict_facts, str(self.control["session-time"]), datetime.now().strftime("%m-%d-%Y_%H:%M:%S.%f"))
                    if self.control["json-notify"] == 1:
                        data_dict = xmltodict.parse(si_notification)
                        si_notification = json.dumps(data_dict, indent=2, sort_keys=True)
                except Exception as e:
                    self.print_log("%%%%% EMRE Error: Content error: " + str(e))
      
                if self.control["show-notification"] == 1:
                    self.print_log("\n################################ EMRE Service Impact Notification ############################\n")
                    self.print_log(si_notification)
#
# Send RFC 5277 notification if platform with "send-notification" model implementation
#
                if self.control["send-notification"] == 1 or self.control["send-notification"] == 3:
                    if self.control["debug-notify"] == 1:
                        self.print_log("\n**** EMRE Debug: Notification Message: \n" + str(si_notification))
                    try:
                        self.netconf_connection.dispatch(to_ele(si_notification))
                    except Exception as e:
                        self.print_log("%%%%% EMRE Error: Notification request send error: " + str(e))
#
# Send Syslog message using IOX infrastructure if required
#
                if self.control["send-notification"] == 2 or self.control["send-notification"] == 3:
                    try:
                        filenum = self.control["session-log-count"]
                        self.control["session-log-count"] = self.control["session-log-count"] + 1
                        filename = str(self.control["log-path"]) + str(self.control["use-case"]) + "_" + str(self.control["session-time"]) + "." + str(filenum)
                        syslog_notification = "EMRE_MESSAGE " + str(self.control["use-case"]) + ": Log: " + str(filename)
                        self.run_write_to_syslog(syslog_notification, 0)
                    except Exception as e:
                        self.print_log("%%%% EMRE: Error sending Syslog notification: " + str(e))
                    if self.control["debug-notify"] == 1:
                        self.print_log("\n**** EMRE Debug: Syslog Notification Message: \n" + str(syslog_notification))
#
# Write notification log file to guest-share if syslog message notification mode selected
#
                    try:
                        with open(filename, "a+") as fd:
                            fd.write(str(si_notification))
                            fd.write("\n")
                        if self.control["debug-notify"] == 1:
                            self.print_log("\n**** EMRE Debug: Syslog Notification Log: \n" + str(filename))
                    except Exception as e:
                        self.print_log("%%%% EMRE: Error writing Notification log: " + str(e) + "\n" + str(filename))
#
# Save notification if required in emre-control model
#
                if self.control["save-notifications"] == 1:
                    self.save_si_notification(si_notification)

            except Exception as e:
                self.print_log("%%%%% EMRE Error: Notification send error: " + str(e))

#
# log the FACTS asserted and RULES on the agenda after CLIPs runs
#
            self.print_clips_info()
#
# Show memory statistics
#
        if self.control["show-memory"] == 1:
            self.print_log("\n**** EMRE Memory: Memory use statistics (kb)")
            self.print_log(self.memory)
            self.assert_statistics_fact("emre-memory", self.memory)

#
# Show timing statistics
#
        if self.control["show-timing"] == 1:
            self.print_log("\n**** EMRE Timing: Execution time statistics (ms)")
            self.print_log(self.timing)
            self.assert_statistics_fact("emre-timing", self.timing)
            self.timing = {
            "load-initial-facts" : 0,
            "load-test-facts" : 0,
            "get-device-facts" : 0,
            "clips-runtime" : 0}    
#
# If required clear selected template facts before running CLIPS again
#
        self.clear_selected_facts()
#
# If "run-one" is set, exit eMRE after running only one iteration
#
        if self.control["run-one"] == 1:
            self.print_log("\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!! EMRE Execution Cycle Completed !!!!!!!!!!!!!!!!!!!!!!!!!!!\n")
            sys.exit(0)
#
# If manual execution control wait for operator input
#
        if self.control["user-control"] == 1:
            self.print_log("\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!! EMRE Execution Cycle Completed !!!!!!!!!!!!!!!!!!!!!!!!!!!\n")
            continueRunning = input("**** EMRE Notice: Enter 1 continue, 0 to exit: ")

            if continueRunning == str(1):
                pass
            else:
                sys.exit(0)

#
# Update control parameters at the end of clips execution
# Read the emre-control model configurations from the device NETCONF datastore
#
        if self.control["model-control"] == 1:
            self.get_emre_control()

################################################################
################################################################
#
# Return to while loop
#
################################################################
################################################################

    ###########################################################################################
    #
    # save_si_notification - Save service impact notification in emre-control model list
    # list if required.  Save up to "max-notifications" service impact notifications in the 
    # saved-notifications list
    #
    ###########################################################################################

    def save_si_notification(self, si_notification):
        if self.control["save-notifications"] == 1:
            if self.control["notify-index"] > self.control["max-notifications"]:
                self.control["notify-index"] = 1
            try:
                store_notification = self.control["save-notification"].format(self.control["emre-id"], self.control["notify-index"], datetime.now().strftime("%m-%d-%Y_%H:%M:%S.%f"), 'new', si_notification.replace("<", "&lt;").replace(">", "&gt;"), self.nc_facts)
                store_notification_text = store_notification
                if self.control["debug-notify"] == 1:
                    self.print_log("\n**** EMRE Debug: Saved Notificaion: \n" + str(store_notification_text))
                self.netconf_connection.edit_config(store_notification_text, target='running')
                self.control["notify-index"] = self.control["notify-index"] + 1

            except Exception as e:
                self.print_log("%%%%% EMRE Error: Notification save error: " + str(e))

    ###########################################################################################
    #
    # clear_selected_facts - Clear facts in the knowledge base for templates in the clear-filter list
    #
    # NOTE: All FACTS in the knowledge-base that have a template name in the clear-filter list
    #       all cleared at the end of the eMRE execution cycle
    #
    ###########################################################################################
    def clear_selected_facts(self):
        if self.control["clear-selected"] == 1:
            for cfilter in self.control["clear-filter"]:
                notify_found = True
                while notify_found:
                    for fact in self.env.facts():
                        notify_found = False
                        try:
                            if str(cfilter) in str(fact):
                                notify_found = True
                                fact.retract()
                                break
                        except Exception as e:
                            self.print_log("%%%% EMRE Error: Error clearing fact: " + str(e))

    ###########################################################################################
    #
    # get_emre_control - Read the emre-control flag configurations from the 
    #                    device NETCONF datastore using the emre-control.yang model
    #
    ###########################################################################################
    def get_emre_control(self):

    #################################################################################
    #
    # Read the emre-control configurations from the cisco-ios-xe-emre-control.yang
    # model from the device CDB.  The emre-control model content is not persisted
    # across DMI infrastructure restart
    #
        try:
            path = '<emre-control xmlns="http://cisco.com/ns/yang/cisco-ios-xe-emre-control"><instances><instance><emre-id>1</emre-id><control-flags/></instance></instances>  </emre-control>'
            emre_control = self.netconf_connection.get(filter=('subtree', str(path)))
    #
    # extract the emre control configurations from the message
    # remove the namespace string that prefixes each child node (leaf) in the returned data
    #
            ns = '{http://cisco.com/ns/yang/cisco-ios-xe-emre-control}'
            root = ET.fromstring(emre_control.xml)
    #
    # Populate the 'control' dictionary with the emre control parameters
    # Handle integer and string values
    # If the control["sync"] flag is set to 1, update all control values, if set to 0
    # exit and do not update the emre-control values
    #
            for child in root.iter():
                dkey = child.tag.replace(ns, '')
    #
    # process integer and string entries in the "control-flags" container
    # the control dictionary is used by the calling code to select and apply
    # emre mode control flags
    #
                try:
                    self.control[dkey] = int(child.text)
                except:
                    self.control[dkey] = child.text
        except Exception as e:
            self.print_log("%%%%% EMRE Error: Unable to process emre-control control flags: " + str(e))           
    ############################################################################################
    # get the dictionary filter configurations if present in the emre-control message
    ############################################################################################
        try:
            path = '<emre-control xmlns="http://cisco.com/ns/yang/cisco-ios-xe-emre-control"><instances><instance><emre-id>1</emre-id><filters/></instance></instances></emre-control>'

            emre_filters = self.netconf_connection.get(filter=('subtree', str(path)))
            ns = '{http://cisco.com/ns/yang/cisco-ios-xe-emre-control}'

            dict_object = xml.dom.minidom.parseString(emre_filters.xml).getElementsByTagName('dict-filter')
            if dict_object != ['none']:
                filter_list = []
    #
    # For each dict_object get a nodelist of all instances of the <filter> in the object
    # Select the firstChild of each <filter> which will be the name of dictionary key for
    # FACTs that should be returned
    #
                for each in dict_object:
                    for filter_value in each.getElementsByTagName('filter'):
                        filter_list.append(str(filter_value.firstChild.nodeValue))
                self.control["dict-filter"] = filter_list
    ############################################################################################
    # get the fact filters for CLIPS facts
    ############################################################################################

            fact_object = xml.dom.minidom.parseString(emre_filters.xml).getElementsByTagName('fact-filter')
            if fact_object != ['none']:
                filter_list = []
                for each in fact_object:
                    for filter_value in each.getElementsByTagName('filter'):
                        filter_list.append(str(filter_value.firstChild.nodeValue))
                self.control["fact-filter"] = filter_list
    ###########################################################################################
    # get the clear fact filters for CLIPS facts
    ###########################################################################################

            clear_object = xml.dom.minidom.parseString(emre_filters.xml).getElementsByTagName('clear-filter')
            if clear_object != []:
                filter_list = []
                for each in clear_object:
                    for filter_value in each.getElementsByTagName('filter'):
                        filter_list.append(str(filter_value.firstChild.nodeValue))
                self.control["clear-filter"] = filter_list

        except Exception as e:
            self.print_log("%%%%% EMRE Error: Unable to process emre-control filters: " + str(e))


    ###########################################################################################
    # get the triggers for eMRE execution
    ###########################################################################################
        try:
            path = '<emre-control xmlns="http://cisco.com/ns/yang/cisco-ios-xe-emre-control"><instances><instance><emre-id>1</emre-id><triggers/></instance></instances></emre-control>'
            triggers = self.netconf_connection.get(filter=('subtree', str(path)))
            ns = '{http://cisco.com/ns/yang/cisco-ios-xe-emre-control}'

    ###########################################################################################
    # get the notification triggers for eMRE execution
    ###########################################################################################

            notify_object = xml.dom.minidom.parseString(triggers.xml).getElementsByTagName('notify-triggers')
            if notify_object != []:
                trigger_list = []
                for each in notify_object:
                    for trigger_value in each.getElementsByTagName('trigger'):
                        trigger_list.append(str(trigger_value.firstChild.nodeValue))
                self.control["notification-triggers"] = trigger_list

    ###########################################################################################
    # get the syslog triggers for eMRE execution
    ###########################################################################################

            syslog_object = xml.dom.minidom.parseString(triggers.xml).getElementsByTagName('syslog-triggers')
            if syslog_object != []:
                syslog_list = []
                for each in syslog_object:
                    for syslog_value in each.getElementsByTagName('trigger'):
                        syslog_list.append(str(syslog_value.firstChild.nodeValue))
                self.control["syslog-triggers"] = syslog_list

        except Exception as e:
            self.print_log("%%%%% EMRE Error: Unable to process emre-control triggers: " + str(e))

    ###########################################################################################
    # get the list of devices required by the use case for FACT collection
    ###########################################################################################
        try:
            path = '<emre-control xmlns="http://cisco.com/ns/yang/cisco-ios-xe-emre-control"><instances><instance><emre-id>1</emre-id><devices/></instance></instances></emre-control>'
            devices_get = self.netconf_connection.get(filter=('subtree', str(path)))
            device_object = xml.dom.minidom.parseString(devices_get.xml).getElementsByTagName('device')
            self.control["device-list"] = []
            new_device = []
            for device_data in device_object:
                address_value = device_data.getElementsByTagName('address')[0]
                new_device.append(address_value.firstChild.nodeValue)
                port_value = device_data.getElementsByTagName('port')[0]
                new_device.append(port_value.firstChild.nodeValue)
                user_value = device_data.getElementsByTagName('user')[0]
                new_device.append(user_value.firstChild.nodeValue)
                pass_value = device_data.getElementsByTagName('pass')[0]
                new_device.append(pass_value.firstChild.nodeValue)
                self.control["device-list"].append(new_device)
                new_device = []
        except Exception as e:
            self.print_log("%%%%% EMRE Error: Unable to process device list: " + str(e))

    ###########################################################################################
    # get the FACT list required to control FACT collection
    ###########################################################################################
        try:
            path = '<emre-control xmlns="http://cisco.com/ns/yang/cisco-ios-xe-emre-control"><instances><instance><emre-id>1</emre-id><fact-definitions/></instance></instances></emre-control>'
            facts_get = self.netconf_connection.get(filter=('subtree', str(path)))
            if self.control["debug-fact"] == 1:
                self.print_log("\n**** EMRE Debug: Get fact-list from emre-control:\n" + str(facts_get.xml)) 

            fact_object = xml.dom.minidom.parseString(facts_get.xml).getElementsByTagName("fact-definitions")
            facts = []

            for each in fact_object:
                for fact in each.getElementsByTagName("content"):
                    fact_dict = json.loads(fact.firstChild.nodeValue.replace("#l", "<"))
                    facts.append(fact_dict)
            self.control["fact-list"] = facts
            if self.control["debug-fact"] == 1:
                self.print_log("\n**** EMRE Debug: Fact list loaded from emre-control:\n" + str(self.control["fact-list"])) 
        except Exception as e:
            self.print_log("%%%%% EMRE Error: Unable to process fact list: " + str(e))

    ###########################################################################################
    # get the initial-facts-list required to initial facts for the use case
    ###########################################################################################
        try:
            path = '<emre-control xmlns="http://cisco.com/ns/yang/cisco-ios-xe-emre-control"><instances><instance><emre-id>1</emre-id><initial-facts/></instance></instances></emre-control>'
            initial_facts_get = self.netconf_connection.get(filter=('subtree', str(path)))
            if self.control["debug-fact"] == 1:
                self.print_log("\n**** EMRE Debug: Get initial-facts-list from emre-control:\n" + str(initial_facts_get.xml)) 
            facts = []
            fact_object = xml.dom.minidom.parseString(initial_facts_get.xml).getElementsByTagName("initial-facts")
            for each in fact_object:
                for fact in each.getElementsByTagName("facts"):
                    value = fact.getElementsByTagName('fact')[0]
                    facts.append(value.firstChild.nodeValue)
            self.control["initial-facts-list"] = facts
 
            if self.control["debug-fact"] == 1:
                self.print_log("\n**** EMRE Debug: initial-facts-list loaded from emre-control:\n" + str(self.control["initial-facts-list"])) 

        except Exception as e:
            self.print_log("%%%%% EMRE Error: Unable to process initial-facts-list: " + str(e))

    ###########################################################################################
    # get the service-impact notification template for the use case
    ###########################################################################################
        try:
            path = '<emre-control xmlns="http://cisco.com/ns/yang/cisco-ios-xe-emre-control"><instances><instance><emre-id>1</emre-id><service-impact-template/></instance></instances></emre-control>'
            template_get = self.netconf_connection.get(filter=('subtree', str(path)))

            temp_object = xml.dom.minidom.parseString(template_get.xml).getElementsByTagName("service-impact")
            for template in temp_object:
                self.control["service-impact"] = template.firstChild.nodeValue
            if self.control["debug-notify"] == 1:
                self.print_log("\n**** EMRE Debug: service impact loaded from emre-control:\n" + str(self.control["service-impact"])) 
        except Exception as e:
            self.print_log("%%%%% EMRE Error: Unable to process service-impact: " + str(e))

    ###########################################################################################
    # get the list of edit-config messages required by the use case
    ###########################################################################################
        try:
            path = '<emre-control xmlns="http://cisco.com/ns/yang/cisco-ios-xe-emre-control"><instances><instance><emre-id>1</emre-id><edit-config/></instance></instances></emre-control>'
            config_get = self.netconf_connection.get(filter=('subtree', str(path)))
            config_object = xml.dom.minidom.parseString(config_get.xml).getElementsByTagName('device')
    #
    # Populate the edit-list with the edit-config messages for this use case
    #
            self.control["edit-list"] = []
            new_config = []
            for config_data in config_object:
                id_value = config_data.getElementsByTagName('id')[0]
                new_config.append(id_value.firstChild.nodeValue)
                device_id = config_data.getElementsByTagName('device-id')[0]
                new_config.append(device_id.firstChild.nodeValue)
                commit_value = config_data.getElementsByTagName('commit-type')[0]
                new_config.append(commit_value.firstChild.nodeValue)
                content_value = config_data.getElementsByTagName('content')[0]
                new_config.append(content_value.firstChild.nodeValue)
                self.control["edit-list"].append(new_config)
                new_config = []
        except Exception as e:
            self.print_log("%%%%% EMRE Error: Unable to process edit-config list: " + str(e))
    #########################################################################################
    # Set logging to null device if required or re-enable logging
    #########################################################################################
        if self.control["logging-null"] == 1:
            f = open(os.devnull, 'w')
            sys.stdout = f
        else:
            sys.stdout = self.stdout_save

        return

########################################################
#
#  emre_init - initialize emre runtime
#
########################################################
    def emre_init(self, flist, model_control, single_run):
    #
    # Flags that control emre execution are read from the emre-control.yang model
    # The values of the control flags are read when emre is started and after the
    # execution of each emre pass (while loop execution)
    # The default values for the flags are shown below
    # These values will be updated by reading the emre-control model
    # If the 'control["sync"]' flag in the emre-control model is set, the values in the model
    # are updated in the control dictionary and selected values applied to emre control variables
    #
        self.control = dict()
    #
    # If model_control which is passed in when emre is started is == 1, control eMRE using
    # the emre-control.yang model
    #
        try:
            self.control.update({"model-control" : model_control})
#PVH what values need to have defaults?
            self.control.update({"send-messages" : 0})
            self.control.update({"debug-logging" : 0})
            self.control.update({"session-time" : ''})
            self.control["session-time"] = str(datetime.now().strftime('%m-%d-%Y_%H:%M:%S.%f'))
            self.control.update({"session-log-count" : 0})
    #
    # variable to collect facts that are converted from dictionary format and saved
    #
            self.nc_facts = ''
    #
    # Dictionary for collecting timing information
    #
            self.timing = {
            "load-initial-facts" : 0,
            "load-test-facts" : 0,
            "get-device-facts" : 0,
            "clips-runtime" : 0
            }
    #
    # Dictionary for collecting memory use information
    #
            self.memory = {
            "entry" : 0,
            "before-test-facts" : 0,
            "after-test-facts" : 0,
            "before-clips-env" : 0,
            "after-clips-env" : 0,
            "before-rules-load" : 0,
            "after-rules-load" : 0,
            "before-load-init-facts" : 0,
            "after-load-init-facts" : 0,
            "after-assert-init-facts" : 0,
            "before-clips-run": 0,
            "after-clips-run": 0
            }
    #
    # impactList is used to collect messages to include in a service-impact notification
    #
            self.impactList = []
    #
    # Template for saving notifications
    #
            self.control["save-notification"] = '''
 <config xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
  <emre-control xmlns="http://cisco.com/ns/yang/cisco-ios-xe-emre-control">
    <instances>
      <instance>
        <emre-id>{0}</emre-id>
        <saved-notifications>
          <notifications>
            <notification>
              <id>{1}</id>
              <datetime>{2}</datetime>
              <status>{3}</status>
              <content>{4}</content>
              <dictionary-facts>{5}</dictionary-facts>
            </notification>
          </notifications>
        </saved-notifications>
      </instance>
    </instances>
  </emre-control>
 </config>'''
        except Exception as e:
            self.print_log('%%%%% EMRE Error: eMRE Intialization error: ' + str(e))
            sys.exit(0)

    ###################################################################################################
    #
    # Check to see if the use case FACTS file is available in /bootflash/guest-share/emre-facts
    # If the emre-facts file is present, read all emre control files from guestshare:
    #
    #    emre-facts - FACT collection and use case control definitions
    #    emre-rules - RULE definitions for CLIPs execution
    #    emre-test - FACT definitions to assert when emre is running if 'test-facts' is set
    #    emre-init - File containing collection of FACTs to assert on emre startup if 'initial-facts' is set
    #    
    # If the files are not present in /guest-share use the the files provided as command line arguments
    #
    ###################################################################################################

        try:
            if os.path.exists('/bootflash/guest-share/emre' + 'emre-facts'):
                self.control.update({"facts-file" : '/bootflash/guest-share/emre' + 'emre-facts'})
                self.control.update({"rules-file" : '/bootflash/guest-share/emre' + 'emre-rules'})
                self.control.update({"test-file" : '/bootflash/guest-share/emre' + 'emre-test'})
                self.control.update({"init-facts-file" : '/bootflash/guest-share/emre' + 'emre-init'})
            else:
                if not os.path.exists(flist[0]):
                    self.print_log("%%%%% EMRE Error: FACTS file not found")
                if not os.path.exists(flist[1]):
                    self.print_log("%%%%% EMRE Error: RULES file not found")
                self.control.update({"facts-file" : flist[0]})
                self.control.update({"rules-file" : flist[1]})
                self.control.update({"test-file" : flist[2]})
                self.control.update({"init-facts-file" : flist[4]})
    #
    # Read the FACTs definitions from the facts-file
    #
            fd = open(self.control["facts-file"])
            inputdata = imp.load_source('inputdata', self.control["facts-file"], fd)
            fd.close()
        except Exception as e:
            self.print_log('%%%%% EMRE Error: eMRE Intialization files read error: ' + str(e))
            sys.exit(0)
    #
    # If this EMRE instance control parameters will be loaded
    # from files set the 'control' dictionary parameters
    #
        try:
#PVH defaults again         self.control.update({"model-control" : inputdata.modelControl})

            self.control.update({"nc-timeout" : inputdata.ncTimeout})
            self.control.update({"debug-logging" : inputdata.debugLogging})
            self.control.update({"log-file" : inputdata.logFile})
            self.control.update({"emre-id" :  1})
            self.control.update({"run-mode" : inputdata.runMode})
            self.control.update({"run-one" : inputdata.runOne})
            self.control.update({"user-control" : inputdata.userControl})
            self.control.update({"run-wait" : inputdata.runWait})
            self.control.update({"update-period" : inputdata.updatePeriod})
            self.control.update({"actions" : inputdata.actions})
            self.control.update({"clear-facts" : inputdata.clearFacts})
            self.control.update({"clear-selected" : inputdata.clearSelected})
            self.control.update({"test-facts" : inputdata.testFacts})
            self.control.update({"initial-facts" : inputdata.initialFacts})
            self.control.update({"show-facts" : inputdata.showFacts})
            self.control.update({"show-dict" : inputdata.showDict})
            self.control.update({"show-rules" : inputdata.showRules})
            self.control.update({"show-messages" : inputdata.showMessages})
            self.control.update({"send-messages" : inputdata.sendMessages})
            self.control.update({"show-notification" : inputdata.showNotification})
            self.control.update({"show-memory" : inputdata.showMemory})
            self.control.update({"show-timing" : inputdata.showTiming})
            self.control.update({"debug-CLI" : inputdata.debugCLI})
            self.control.update({"debug-notify" : inputdata.debugNotify})
            self.control.update({"debug-syslog" : inputdata.debugSyslog})
            self.control.update({"debug-fact" : inputdata.debugFact})
            self.control.update({"debug-config" : inputdata.debugConfig})
            self.control.update({"logging-null" : inputdata.loggingNull})
            self.control.update({"send-notification" : inputdata.sendNotification})
            self.control.update({"save-notifications" : inputdata.saveNotifications})
            self.control.update({"save-dict-facts" : inputdata.saveDictFacts})
            self.control.update({"max-notifications" : inputdata.maxNotifications})
            self.control.update({"send-before" : inputdata.sendBefore})
            self.control.update({"send-after" : inputdata.sendAfter})
            self.control.update({"send-clips" : inputdata.sendClips})
            self.control.update({"send-dict" : inputdata.sendDict})
            self.control.update({"syslog-address" : inputdata.syslogAddress})
            self.control.update({"syslog-port" : inputdata.syslogPort})
            self.control.update({"fact-filter" : inputdata.fact_filter})
            self.control.update({"dict-filter" : inputdata.dict_filter})
            self.control.update({"clear-filter" : inputdata.clear_filter})
            self.control.update({"notification-triggers" : inputdata.notification_triggers})
            self.control.update({"syslog-triggers" : inputdata.syslog_triggers})
            self.control.update({"notify-index" : 1})
            self.control.update({"initial-facts-list" : inputdata.initial_facts})
            self.control.update({"service-impact" : inputdata.service_impact})
            self.control.update({"initial-facts-list" : inputdata.initial_facts})
            self.control.update({"edit-configs" : inputdata.edit_configs})
            self.control.update({"use-case" : inputdata.useCase})
            self.control.update({"log-path" : inputdata.logPath})
    #
    # Read the FACT collection instructions from the fact-definitions and load into the fact-list
    #
            self.control.update({"fact-list" : inputdata.fact_list})        
    #
    # Put added fact file parameters into try clause for backward compatibility
    # Ignore if not found
    #
            try:
                self.control.update({"debug-action" : inputdata.debugAction})
            except: pass
            try:            
                self.control.update({"json-notify" : inputdata.jsonNotify})
            except: pass
            try:            
                self.control.update({"retry-count" : inputdata.retryCount})
            except: pass
            try:            
                self.control.update({"retry-time" : inputdata.retryTime})
            except: pass
            try:            
                self.control.update({"startup-delay" : inputdata.startupDelay})
            except: pass

            try:
                self.control.update({"action-fact-list" : inputdata.action_fact_list})
                self.control.update({"nc-fact-list" : inputdata.nc_fact_list})
                self.control.update({"show-fact-list" : inputdata.show_fact_list})
                self.control.update({"show-run-facts" : inputdata.showRunFacts})
                self.control.update({"single-notify" : inputdata.singleNotify})
                self.control.update({"fact-timer" : inputdata.factTimer})
                self.control.update({"timer-fact-name" : inputdata.factName})
                self.control.update({"notify-path" : inputdata.notifyPath})
                self.control.update({"local-path" : inputdata.localPath})
                self.control.update({"show-parameter-fact-list" : inputdata.show_parameter_fact_list})
            except:pass 
            try:
                self.control.update({"file-fact-list" : inputdata.file_fact_list})
            except: pass    
            try:
                self.control.update({"debug-parser" : inputdata.debugParser})
                self.control.update({"debug-file" : inputdata.debugFile})
            except: pass    
    #
    # optional configuration content
    #
            try:
                self.telem_list = inputdata.telem_list
                self.telemetry_config = inputdata.telemetry_config
                self.cli_cmd = inputdata.cli_cmd
                self.translation_dict = inputdata.translation_dict
                self.append_slot_dict = inputdata.append_slot_dict
            except: pass
    #
    # Set logging to null device if required
    #
            self.stdout_save = sys.stdout
            if self.control["logging-null"] == 1:
                f = open(os.devnull, 'w')
                sys.stdout = f

        except Exception as e:
            self.print_log('%%%%% EMRE Error: Test fact file missing content: ' + str(e))
        self.memory_use("**** EMRE Memory: On Entry(kb): ", "entry")
    #
    # If this EMRE instance is run on a platform with the 'cisco-ios-xe-emre-control.yang" model
    # control configurations can be read from the device NETCONF datastore
    # EMRE uses the device credentials contained in the FACTS file to connect to the device NETCONF instance
    #
        if self.control["model-control"] == 1:            
            self.get_emre_control()

    ###################################################################################################
    #
    # Check to see if device configuration information is available in /bootflash/guest-share/emre-config
    # If the file is present, update the "device-list" and "mgmt-device" with configurations from emre-config
    #
    ###################################################################################################

        try:
            if os.path.exists(str(self.control["log-path"]) + 'emre-config'):
                fd = open(str(self.control["log-path"]) + 'emre-config')
                devicedata = imp.load_source('devicedata', str(self.control["log-path"]) + 'emre-config', fd)
                self.control.update({"device-list" : devicedata.device_list})
                self.control.update({"mgmt-device" : devicedata.mgmt_device})
                self.print_log("**** EMRE Notice: emre-config used to set device information")
            else:
                self.print_log("**** EMRE Notice: FACTS file used to set device information")
                self.control.update({"device-list" : inputdata.device_list})
                self.control.update({"mgmt-device" : inputdata.mgmt_device})

        except Exception as e:
            self.print_log('%%%%% EMRE Error: eMRE emre-config file read error: ' + str(e))
            sys.exit(0)
    #
    # If required delay before attempting the first device connection
    #
        if self.control["startup-delay"] != 0:            
            self.print_log("**** EMRE Notice: Delay Seconds before Connecting to Device: " + str(self.control["startup-delay"]))
            time.sleep(self.control["startup-delay"])
            self.print_log("**** EMRE Notice: Startup Connect Delay Complete")
    #
    # Connect to device identified as the management device
    #
        retry_count = 1
        connect_success = False
        while retry_count <= self.control["retry-count"]:
    #
    #    Try multiple times to connect (may be delayed for DHCP lease)
    #
            try:
                self.netconf_connection = (ncclient.manager.connect_ssh(host=self.control["mgmt-device"][0], port=self.control["mgmt-device"][1],
                    username=self.control["mgmt-device"][2],
                    password=self.control["mgmt-device"][3],
                    hostkey_verify=False,
                    look_for_keys=False,
                    allow_agent=False,
                    timeout=self.control["nc-timeout"]))
    #
    # If connections successful break out of the retry loop
    #
                connect_success = True
                break
    #
    # If connection failed, retry after waiting "retry-time" seconds
    #
            except Exception as e:
                timestamp =  datetime.now().strftime("%m-%d-%Y_%H:%M:%S.%f")
                
                self.print_log("%%%%% EMRE Error: Unable to connect to management device: " + str(self.control["mgmt-device"][0]) + " retry: " + str(retry_count) + " at: " + str(timestamp) + " " + str(e))
                retry_count = retry_count + 1
                time.sleep(self.control["retry-time"])
    #
    # If device connections failed exit
    #
        if connect_success == False:
            timestamp =  datetime.now().strftime("%m-%d-%Y_%H:%M:%S.%f")
            
            self.print_log("%%%%% EMRE Error: Unable to connect management device: " + str(self.control["mgmt-device"][0]) + " at: " + str(timestamp))
            self.close_sessions()
            sys.exit(0)
        timestamp =  datetime.now().strftime("%m-%d-%Y_%H:%M:%S.%f")
        
        self.print_log("**** EMRE Notice: Connected to management device: " + str(self.control["mgmt-device"][0]) + " at: " + str(timestamp))

    #
    # If run-mode requires waiting for notifications create NETCONF listener for snmpevents stream
    #
        if self.control["run-mode"] == 2:
            retry_count = 1
            connect_success = False
            while retry_count <= self.control["retry-count"]:
    #
    #    Try multiple times to connect for notifications (may be delayed for DHCP lease)
    #
                try:
                    self.notify_conn = (ncclient.manager.connect_ssh(host=self.control["mgmt-device"][0], port=self.control["mgmt-device"][1],
                        username=self.control["mgmt-device"][2],
                        password=self.control["mgmt-device"][3],
                        hostkey_verify=False,
                        look_for_keys=False,
                        allow_agent=False,
                        timeout=self.control["nc-timeout"]))
                    self.notify_conn.async_mode = False
                    self.notify_conn.create_subscription(stream_name='snmpevents')
    #
    # If connections successful break out of the retry loop
    #
                    connect_success = True
                    break
    #
    # If connection failed, retry after waiting "retry-time" seconds
    #
                except Exception as e:
                    timestamp =  datetime.now().strftime("%m-%d-%Y_%H:%M:%S.%f")
                    
                    self.print_log("%%%%% EMRE Error: Unable to connect to notification stream from: " + str(self.control["mgmt-device"][0]) + " retry: " + str(retry_count) + " at: " + str(timestamp) + " " + str(e))
                    retry_count = retry_count + 1
                    time.sleep(self.control["retry-time"])
    #
    # If device connection failed exit
    #
            if connect_success == False:
                timestamp =  datetime.now().strftime("%m-%d-%Y_%H:%M:%S.%f")
                
                self.print_log("%%%%% EMRE Error: Unable to connect to notification stream from: " + str(self.control["mgmt-device"][0]) + " at: " + str(timestamp))
                self.close_sessions()
            timestamp =  datetime.now().strftime("%m-%d-%Y_%H:%M:%S.%f")
            
            self.print_log("**** EMRE Notice: Connected to notification stream from: " + str(self.control["mgmt-device"][0]) + " at: " + str(timestamp))

    #
    # Read test facts to assert if 'test-facts' is configured
    # The list of list of facts will be available in self.test_data
    #
        self.test_index = 0
        if self.control["test-facts"] == 1:
            self.memory_use("**** EMRE Memory: Before Loading Test Facts(kb): ", "before-test-facts")
            try:
                if not os.path.exists(self.control["test-file"]):
                    self.print_log('%%%%% EMRE Error: Test fact file does not exist')

                fd = open(self.control["test-file"])
                testdata = imp.load_source('testdata', self.control["test-file"], fd)
                fd.close()
                self.test_data = testdata.test_data
            except Exception as e:
                self.print_log('%%%%% EMRE Error: Test fact file read error: ' + str(e))
            self.memory_use("**** EMRE Memory: After Loading Test Facts(kb): ", "after-test-facts")

    ###########################################################################
    #
    # Connect to devices used to implement the use case
    # Create a list with entries for each device containing the
    # ncclient connection object.  The indexes into the 'device' list
    # are one of the parameters in configurations in the 'facts.txt' instructions
    # for collecting FACT information from devices
    # If control["test-facts"] is not set, connect to the devices
    #
    ###########################################################################
        retry_count = 1
        connect_success = False
        while retry_count <= self.control["retry-count"]:

            try:
                self.device = []
                for device_dat in self.control["device-list"]:
                    self.device.append(ncclient.manager.connect_ssh(host=device_dat[0], port=device_dat[1],
                                username=device_dat[2],
                                password=device_dat[3],
                                hostkey_verify=False,
                                look_for_keys=False,
                                allow_agent=False,
                                timeout=self.control["nc-timeout"]))
    #
    # If connections successful break out of the retry loop
    #
                connect_success = True
                break
    #
    # If connection failed, retry after waiting "retry-time" seconds
    #
            except Exception as e:
                timestamp =  datetime.now().strftime("%m-%d-%Y_%H:%M:%S.%f")
                
                self.print_log("%%%%% EMRE Error: Unable to connect to device-list entry: " + str(device_dat[0]) + " retry: " + str(retry_count) + " at: " + str(timestamp) + " " + str(e))
                retry_count = retry_count + 1
                time.sleep(self.control["retry-time"])
    #
    # If device connections failed exit
    #
        if connect_success == False:
            timestamp =  datetime.now().strftime("%m-%d-%Y_%H:%M:%S.%f")
            
            self.print_log("%%%%% EMRE Error: Unable to connect to device-list entries at: " + str(timestamp))
            self.close_sessions()
            sys.exit(0)
        timestamp =  datetime.now().strftime("%m-%d-%Y_%H:%M:%S.%f")
        
        self.print_log("**** EMRE Notice: Connected to all device-list entry devices at: " + str(timestamp))


    ###########################################################################################
    #
    # Initialize CLIPS environment
    #
    ###########################################################################################
        try:
            self.memory_use("**** EMRE Memory: Before Creating CLIPs env(kb): ", "before-clips-env")
            self.env = clips.Environment()
            if self.control["debug-action"] == 1:
                self.print_log("**** EMRE Debug: CLIPs Environment: " + str(self.env))

        except:
            self.print_log("%%%%% EMRE Error: Failed to clear inference engine")
            sys.exit(0)
        self.memory_use("**** EMRE Memory: After Creating CLIPs env(kb): ", "after-clips-env")

    ###########################################################################################
    #
    # action_functions - Names of any python functions used as control["actions"] in CLIPS rules
    # The functions in the list must be defined before being referenced below
    # The functions could be defined in a library that is imported by the basic script.
    # As new action functions are created they are added to the library
    #PVH dynamically load action functions
    ###########################################################################################
        try:
            action_functions = self.get_action_functions()
            for function in action_functions:
                if self.control["debug-action"] == 1:
                    self.print_log("**** EMRE Debug: intialize action functions: " + str(function))
                self.env.define_function(function)
        except Exception as e:
            self.print_log("%%%%% EMRE Error: registering action_functions: " + str(e))
            self.close_sessions()
            sys.exit(0)
    #
    # Load the clips constructs file including rules deftemplates and deffacts
    #
        try:
            self.memory_use("**** EMRE Memory: Before load CLIPS rules in KBytes: ", "before-rules-load")
            self.env.load(self.control["rules-file"])
            self.memory_use("**** EMRE Memory: After load CLIPS rules in KBytes: ", "after-rules-load")

            self.print_log("**** EMRE Notice: Inference Engine rules file loaded: " + self.control["rules-file"])
        except Exception as e:
            self.print_log("%%%%% EMRE Error: failed to load inference engine rules" + str(e))
            self.close_sessions()
            sys.exit(0)

        try:
            self.env.reset() # Initialize any "deffacts" defined in the .clp CLIPS file
            self.print_log("**** EMRE Notice: Inference Engine Reset")
        except:
            self.print_log("%%%%% EMRE Error: failed resetting inference engine")
            self.close_sessions()
            sys.exit(0)

    #
    # Assert initial facts defined in the FACTS configuration file
    #
        starttime = time.time()
        if self.control["initial-facts-list"] != []:
            self.get_initial_facts()
    #
    # Read and assert facts in the init-facts-file
    #
        if self.control["initial-facts"] == 1:
            self.memory_use("**** EMRE Memory: After Loading Initial Facts(kb): ", "before-load-init-facts")

            try:
                fd = open(self.control["init-facts-file"], 'r')
                facts = fd.readlines()
                fd.close()
                self.memory_use("**** EMRE Memory: After Loading Initial Facts(kb): ", "after-load-init-facts")

    #
    # Assert each initial fact
    #
                try:
                    for fact in facts:
                        if self.control["debug-fact"] == 1:
                            self.print_log("**** EMRE Debug: Assert init-file fact: " + str(fact))
                        try:
                            self.env.assert_string(str(fact))
                        except: pass #ignore case where FACT already exists
                except Exception as e:
                    self.print_log('%%%%% EMRE Error: init-file-fact assert error' + str(e))
            except Exception as e:
                self.print_log('%%%%% EMRE Error: init-file-fact read error: ' + str(e))
    #
    # Log time to load any inital facts
    #
        endtime = time.time()
        fact_runtime = endtime - starttime
        self.emre_timing('**** EMRE Time: to load and assert initial facts(ms): %8.3f', fact_runtime, "load-initial-facts")
        self.memory_use("**** EMRE Memory: After Asserting Initial Facts(kb): ", "after-assert-init-facts")


    ##############################################################################################
    #
    # run_write_to_syslog - This function sends the input syslog_message to the host through
    # serial device /dev/ttyS2 as described here: 
    # https://developer.cisco.com/docs/iox/#!app-hosting-loggingtracing-services/iox-logging-tracing-facility
    #
    ##############################################################################################
    def run_write_to_syslog(self, syslog_message, delay_ms):
        try:
            if int(delay_ms) != 0: time.sleep(delay_ms/1000)
            if str(self.control["local-path"]) == 'TRUE':
                timestamp =  datetime.now().strftime("%m-%d-%Y_%H:%M:%S.%f")
                
                outfile = str(self.control["notify-path"]) + str(self.control["use-case"]) + "_" + timestamp
                tty_fd = os.open(outfile, os.O_WRONLY | os.O_CREAT)
            else:
                tty_fd = os.open(str(self.control["notify-path"]), os.O_WRONLY)
            numbytes = os.write(tty_fd, str.encode(syslog_message + "\n"))
            os.close(tty_fd)
        except Exception as e:
            self.print_log('%%%%% EMRE Error: Writing Syslog notification ' + str(e))

    ##############################################################################################
    #
    # memory_use - Measure and display memory used by the EMRE Python script
    #
    ##############################################################################################
    def memory_use(self, message, key):
        if self.control["show-memory"] == 1:
            try:
                usage = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
                self.print_log(message + str(usage))
                self.memory[key] = usage
            except:
                pass

    ##############################################################################################
    #
    # timing - Report execution time used by EMRE Python script
    #
    ##############################################################################################
    def emre_timing(self, message, runtime, key):
        if self.control["show-timing"] == 1:
            try:
                self.print_log(message%(runtime*1000))
                self.timing[key] = runtime*1000
            except:
                pass

    ##############################################################################################
    #
    # run_assert_message - This function displays messages sent from triggered rules to the console
    # and also adds the messages as service-tags in the service-impact notification
    #
    ##############################################################################################
    def run_assert_message(self, string):
        if self.control["show-messages"] == 1:
            self.print_log("#### EMRE Rule Message: " + string)
        if self.control["send-messages"] == 1:
    #
    # Add the message to a list that will be inserted into the service impact notification
    #
            try:
                self.impactList.append("      <message>")
                self.impactList.append(string)
                self.impactList.append("</message>")
                self.impactList.append("\n")
            except Exception as e:
                self.print_log("%%%% EMRE Error: run_assert_message error: " + str(e))
        return

    #########################################################################################
    #
    # Create a logging file
    #
    #########################################################################################
    def make_logger(self, path):

        logger = logging.getLogger('emreLogger')
        logger.setLevel(logging.DEBUG)

        handler = logging.handlers.SysLogHandler('/var/log')
        handler_rot = RotatingFileHandler(path, maxBytes=10*1024*1024, backupCount=5)

        l_format = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(l_format)

        logger.addHandler(handler_rot)

        return logger


    ########################################################################################
    #
    # get_template_multifacts_protofact - For each element in the element_list substitute the element
    # value, for example the name of an interface, as the key in a template used to read
    # multiple facts from a device
    #
    ########################################################################################
    def get_template_multifacts_protofact(self, fact, slot, slot_value):
        get_result = self.device[fact['device_index']].get(filter=('subtree', str(fact['path'])))
        instances = xml.dom.minidom.parseString(get_result.xml).getElementsByTagName(fact["assert_fact_for_each"])

        # put all instances with desired fields in "filtered_instances"
        if "element_list" in fact:
            filtered_instances = []
            for each in instances:
                found = False
                slots = fact['protofact']["slots"]
                for slot in slots:
                    if found: break
                    if ("hardcoded_list" in fact) and (slot in fact["hardcoded_list"]): continue
                    node_list = each.getElementsByTagName(slots[slot])
                    if node_list:
                        node = node_list[0]
                    elif "/" in slots[slot]:
                        node = self.get_upper_value(each, slots[slot])
                    else: continue
                    for category in fact["element_list"]:
                        if slot == category:
                            if (str(node.firstChild.nodeValue).replace(" ", "") in fact["element_list"][category]):
                                filtered_instances.append(each)
                                found = True
                                break
        else:
            filtered_instances = instances

        # collect info for each instance and then assert it as a template fact
        for each in filtered_instances:
            protofact = copy.deepcopy(fact['protofact'])
            slots = fact['protofact']["slots"]
            for slot in slots:
                if ("hardcoded_list" in fact) and (slot in fact["hardcoded_list"]): continue
                node_list = each.getElementsByTagName(slots[slot])
                if node_list:
                    node = node_list[0]
                elif "/" in slots[slot]:
                    # for upper tags, node_list would have been empty above
                    node = self.get_upper_value(each, slots[slot])
                else: continue

                value_str = node.firstChild.nodeValue
                if value_str.isdecimal():
                    protofact["slots"][slot] = int(value_str)
                else:
                    protofact["slots"][slot] = value_str  
            self.assert_template_fact(protofact, slot, slot_value)
            if self.control["debug-fact"] == 1:
                self.print_log("**** EMRE Debug: get_protofact: " + str(protofact))
        return "success"

    ##############################################################################
    #
    # get_upper_value - Get the value for model nodes above the target nodes
    #                   These nodes are normally keys in a nested list above the
    #                   target nodes
    #
    ##############################################################################
    def get_upper_value(self, node, upper_tag_key_combo):
        tag_key_list = upper_tag_key_combo.split("/")
        upper_tag = tag_key_list[0]
        key = tag_key_list[1]
        cur_node = node
        while cur_node.tagName != upper_tag:
            try:
                cur_node = cur_node.parentNode
            except:
                self.print_log("%%%%% EMRE Error: Protofact could not find parent: " + str(upper_tag_key_combo))
                return
        return cur_node.getElementsByTagName(key)[0]


    ########################################################################################
    #
    # get_template_multifacts - For each element in the element_list substitute the element
    # value, for example the name of an interface, as the key in a template used to read
    # multiple facts from a device
    #
    ########################################################################################
    ########################################################################################
    #
    # get_template_multifacts - For each element in the element_list substitute the element
    # value, for example the name of an interface, as the key in a template used to read
    # multiple facts from a device
    #
    ########################################################################################
    def get_template_multifacts(self, fact, slot, slot_value):
        device_id = self.device[fact[1]]
        device_name = fact[2]
        path =  fact[3]
        template = fact[4]
        key = fact[5]
        leafs = fact[6]
        facts = fact[7]
        assert_list = fact[8]
        element_list = fact[9]
        totaltimestart = time.time()
        try:
            if self.control["debug-fact"] == 1:
                self.print_log("**** EMRE Debug: get_fact parameters: " + str(path) + " " + str(key) + " " + str(leafs) + " " + str(facts) + " " + str(assert_list) + " " + str(element_list))
    #
    # If there are facts that must be asserted for this call assert all facts in the required templates
    # The list contains entries of this form [[template_name, slot_name, slot_value]]
    #
            for assert_fact in assert_list:
                try:
                    self.env.assert_string("(" + str(assert_fact[0]) + " (" + str(assert_fact[1]) + " " + str(assert_fact[2]) + "))")
                except: pass #ignore case where FACT already exists
    #
    # get data for multiple instances
    # instances will be a list of the objects which match the "key"
    #
            get_result = device_id.get(filter=('subtree', str(path)))
            if self.control["debug-fact"] == 1:
                self.print_log("**** EMRE Debug: get_template result: " + str(get_result))
            instances = xml.dom.minidom.parseString(get_result.xml).getElementsByTagName(key)
            if self.control["debug-fact"] == 1:
                self.print_log("**** EMRE Debug: instances: " + str(instances))
    #
    # Filter entries in multitemplate list if a filter is specified to limit fact collection
    #
            if element_list != []:
                filtered_elements = []
                filtered_instances = []
                for each in instances:
                    instance = []
                    for leaf in leafs:
                        for node in each.getElementsByTagName(leaf):
                            if str(node.firstChild.nodeValue).replace(" ", "") in element_list:
                                if self.control["debug-fact"] == 1:
                                    self.print_log("**** EMRE Debug: Multitemplate instance in list: " + str(node.firstChild.nodeValue))
                                filtered_elements.append(str(node.firstChild.nodeValue).replace(" ", ""))
                                filtered_instances.append(each)
                element_list = filtered_elements
                instances = filtered_instances

            instance_list = []
            for each in instances:
                if self.control["debug-fact"] == 1:
                    self.print_log("**** EMRE Debug nodes: " + str(each.childNodes))
                instance = []
                for leaf in leafs:
                    if self.control["debug-fact"] == 1:
                        self.print_log("**** EMRE Debug: leaf: " + str(leaf))
                    for node in each.getElementsByTagName(leaf):
                        if self.control["debug-fact"] == 1:
                            self.print_log("**** EMRE Debug get_template_fact node: " + str(node.firstChild.nodeValue))
                        instance.append(node.firstChild.nodeValue)
                if instance != []:
                    instance_list.append(instance)
                instance = []
    #
    # For each instance in the list assert the information read as facts
    #
            for each in instance_list:
                flist = ["(", str(template)]
                j = 0
                try:
                    flist.append(" (")
                    flist.append("device")
                    flist.append(" ")
                    flist.append(str(device_name))
                    flist.append(")")
                    for fact in facts:
                        factlist_save = flist
                        try:
                            flist.append(" (")
                            flist.append(str(fact))
                            flist.append(" ")
                            flist.append(str(each[j]).replace(" ", ""))
                            flist.append(")")
                            j = j + 1
    #
    # Some instances of a fact object may not implement all keys causing a mismatch in length
    # catch exceptions and set missing fact values to 0
    #
                        except:
                            self.print_log("%%%%% EMRE Error: Fact template: " + str(template) + " " + str(each[0]) + " requires a value not returned: " + str(fact))
                            flist.append("0")
                            flist.append(")")
                            j = j + 1
    # 
    # Append extra "slot" if there is a slot and slot_value passed in to the function
    #   
                    if slot != 'none':
                      slot_fact = " (" + str(slot) + " " + str(slot_value) + ")"
                      flist.append(slot_fact)
                    flist.append(")") #add closing paren for the FACT
    #
    # Join all strings in list into one string and assert as a FACT
    #
                    if self.control["debug-fact"] == 1:
                        self.print_log("**** EMRE Debug: Assert template fact: ")
                        self.print_log(''.join(flist))
                    try:
                        self.env.assert_string(''.join(flist))
                    except: pass #ignore case where FACT already exists
                except Exception as e:
                    self.print_log(str(e))
                    self.print_log("%%%%% EMRE Error: Error asserting template fact: " + fact + "  " + flist)
    #
    # If there are no instances found, create an empty FACT to indicate no data found
    #
            if len(instance_list) == 0:
                try:                
                    flist = ["(", str(template)]
                    flist.append(" (")
                    flist.append("device")
                    flist.append(" ")
                    flist.append(str(device_name))
                    flist.append(")")
                    flist.append(")")
    #
    # Join all strings in list into one string and assert as a FACT
    #
                    if self.control["debug-fact"] == 1:
                        self.print_log("**** EMRE Debug: Assert empty template fact: ")
                        self.print_log(''.join(flist))
                    self.env.assert_string(''.join(flist))
                except: pass #ignore case where FACT already exists

        except Exception as e:
            self.print_log("%%%%% EMRE Error: Get template multifact error: " + str(e))
            self.print_log("%%%%% EMRE Error: No value found in get_template_multifacts")
        return "success"

    ########################################################################################
    #
    # get_template_multifacts_protofact - For each element in the element_list substitute the element
    # value, for example the name of an interface, as the key in a template used to read
    # multiple facts from a device
    #
    ########################################################################################
    def get_template_multifacts_protofact(self, fact, slot, slot_value):
        get_result = self.device[fact['device_index']].get(filter=('subtree', str(fact['path'])))
        instances = xml.dom.minidom.parseString(get_result.xml).getElementsByTagName(fact["assert_fact_for_each"])

        # put all instances with desired fields in "filtered_instances"
        if "element_list" in fact:
            filtered_instances = []
            for each in instances:
                found = False
                slots = fact['protofact']["slots"]
                for slot in slots:
                    if found: break
                    if ("hardcoded_list" in fact) and (slot in fact["hardcoded_list"]): continue
                    node_list = each.getElementsByTagName(slots[slot])
                    if node_list:
                        node = node_list[0]
                    elif "/" in slots[slot]:
                        node = self.get_upper_value(each, slots[slot])
                    else: continue
                    for category in fact["element_list"]:
                        if slot == category:
                            if (str(node.firstChild.nodeValue).replace(" ", "") in fact["element_list"][category]):
                                filtered_instances.append(each)
                                found = True
                                break
        else:
            filtered_instances = instances
        
        # collect info for each instance and then assert it as a template fact
        for each in filtered_instances:
            protofact = copy.deepcopy(fact['protofact'])
            slots = fact['protofact']["slots"]
            for slot in slots:
                if ("hardcoded_list" in fact) and (slot in fact["hardcoded_list"]): continue
                node_list = each.getElementsByTagName(slots[slot])
                if node_list:
                    node = node_list[0]
                elif "/" in slots[slot]:
                    # for upper tags, node_list would have been empty above
                    node = self.get_upper_value(each, slots[slot])
                else: continue

                value_str = node.firstChild.nodeValue
                if value_str.isdecimal():
                    protofact["slots"][slot] = int(value_str)
                else:
                    protofact["slots"][slot] = value_str  
            self.assert_template_fact(protofact, slot, slot_value)
        return "success"

##############################################################################
#
#
# show_and_assert_fact -
#            Execute a show command, parse the show command output,
#            and assert FACTS based on the output
#            Support using ssh for device access (for offbox use cases) or use the
#            Python cli package.
#            Function is backward compatible with older FACT files that do not have the
#            the "access-method" dictionary entry in the FACT definition
#            Return "success" on success else return error string
#
#############################################################################
    def show_and_assert_fact(self, fact):
    #
    # Determine if ssh should be used to access device
    # Execute in try clause for backward compatibility with older FACT files
    #
        try:
            if str(fact["access-method"]) == 'ssh':
                device_info = self.control["device-list"][int(fact["device-index"])]
                device_address = str(device_info[0])
                device_user = str(device_info[2])
                device_pass = str(device_info[3])
                options = '-q -oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null -oPubkeyAuthentication=no'
    #
    # Select the device to use
    #
                ssh_cmd = 'ssh %s@%s %s "%s"' % (device_user, device_address, options, str(fact["command"]))
                if self.control["debug-fact"] == 1:
                    self.print_log("**** EMRE Debug: run_show_and_assert SSH command: " + str(ssh_cmd) + "\n")
                try:
                    child = pexpect.spawn(ssh_cmd, timeout=15, encoding='utf-8')
                    child.delaybeforesend = None
                    if self.control["debug-CLI"] == 1:
                        child.logfile = sys.stdout
                    child.expect(['\r\nPassword: ', '\r\npassword: ', 'Password: ', 'password: '])
                    child.sendline(device_pass)
                    child.expect(pexpect.EOF)
                    response = child.before
                    if self.control["debug-fact"] == 1:
                        self.print_log("**** EMRE Debug: run_show_and_assert SSH execution response: " + str(response))
                except Exception as e:
                    child.close()
                    self.print_log("%%%% EMRE show_and_assert ssh or timeout Error: " + str(ssh_cmd) + "\n")
                    return "show_and_assert ssh or timeout Error"

                child.close()
    #
    # process response and generate FACTs
    #
                try:
                    if "error" in response:
                        self.print_log("%%%% EMRE Error: error in ssh show_and_assert show command response")
                        return "Error: show_and_assert show command response"
                    parser = genie_str_to_class(fact["genie_parser"])
                    if type(parser) == str:
                        return parser
                    parsed_genie_output = parser.cli(output=response)
                    if self.control["debug-fact"] == 1:
                        self.print_log("\n*** EMRE Debug: parsed genie output: " + str(parsed_genie_output))
                    if parsed_genie_output == {}:
                        return "success"
                    sub_dictionary_list = self.find(fact["assert_fact_for_each_item_in"], parsed_genie_output)
                    import copy
                    for sub_dictionary in sub_dictionary_list:
                        for item in sub_dictionary:
                            protofact = copy.deepcopy(fact["protofact"])
                            for slot in protofact["slots"]:
                                value = protofact["slots"][slot]
	#
	# insert the device name into the fact
	#
                                if value == "device":
                                    protofact["slots"][slot] = value.replace("device", fact["device"])
                                elif type(value) == str and "$" in value:
                                    protofact["slots"][slot] = value.replace("$", item)
                            self.assert_template_fact(protofact, 'device', fact["device"], sub_dictionary)
                    return "success"
                except Exception as e:
                    self.print_log("%%%% EMRE Error: Exception in ssh show_and_assert_fact response processing: " + str(e))
                    return "Exception in ssh show_and_assert_fact response processing"


            elif str(fact["access-method"]) == 'cli':
                try:
                    response = cli.cli(str(fact["command"]))
                    if self.control["debug-fact"] == 1:
                        self.print_log("**** EMRE Debug: show_and_assert cli command result \n" + str(response))
                    if "error" in response:
                        self.print_log("%%%% EMRE Error: show_and_assert show command response")
                        return "Error: show_and_assert show command response"

                    parser = genie_str_to_class(fact["genie_parser"])
                    if type(parser) == str:
                        return parser
    #
    # convert show command response to parsed dictionary
    #
                    parsed_genie_output = parser.cli(output=response)
                    if self.control["debug-fact"] == 1:
                        self.print_log("\n*** EMRE Debug: parsed genie output: " + str(parsed_genie_output))
                    if parsed_genie_output == {}:
                        return "success"

                    sub_dictionary_list = self.find(fact["assert_fact_for_each_item_in"], parsed_genie_output)
                    import copy
                    for sub_dictionary in sub_dictionary_list:
                        for item in sub_dictionary:
                            protofact = copy.deepcopy(fact["protofact"])
                            for slot in protofact["slots"]:
                                value = protofact["slots"][slot]
	#
	# insert the device name into the fact
	#
                                if value == "device":
                                    protofact["slots"][slot] = value.replace("device", fact["device"])
                                elif type(value) == str and "$" in value:
                                    protofact["slots"][slot] = value.replace("$", item)
                            self.assert_template_fact(protofact, 'device', fact["device"], sub_dictionary)
                    return "success"
                except Exception as e:
                    self.print_log("%%%% EMRE Error: Exception in cli show_and_assert_fact: " + str(e))
                    return "Error: Exception in cli show_and_assert_fact"
    #
    # If "access-method" not supported, return error
    #
            else:
                self.print_log("%%%% EMRE Error: Exception in show_and_assert_fact: Invalid access-method")
                return "Exception in show_and_assert_fact: Invalid access-method"


    #
    # catch exception if using old FACT file without the "access-method" dictionary element
    # Process show_and_assert using the python cli package
    #
        except:
            try:
                response = cli.cli(str(fact["command"]))
                if "error" in response:
                    self.print_log("%%%% EMRE Error: show_and_assert show command response")
                    return "Error: show_and_assert show command response"

                parser = genie_str_to_class(fact["genie_parser"])
                if type(parser) == str:
                    return parser
                parsed_genie_output = parser.cli(output=response)
                if self.control["debug-fact"] == 1:
                    self.print_log("\n*** EMRE Debug: parsed genie output: " + str(parsed_genie_output))
                if parsed_genie_output == {}:
                    return "success"

                sub_dictionary_list = self.find(fact["assert_fact_for_each_item_in"], parsed_genie_output)
                import copy
                for sub_dictionary in sub_dictionary_list:
                    for item in sub_dictionary:
                        protofact = copy.deepcopy(fact["protofact"])
                        for slot in protofact["slots"]:
                            value = protofact["slots"][slot]
	#
	# insert the device name into the fact
	#
                            if value == "device":
                                protofact["slots"][slot] = value.replace("device", fact["device"])
                            elif type(value) == str and "$" in value:
                                protofact["slots"][slot] = value.replace("$", item)
                        self.assert_template_fact(protofact, 'device', fact["device"], sub_dictionary)
                return "success"
            except Exception as e:
                self.print_log("%%%% EMRE Error: Exception in show_and_assert_fact: " + str(e))
                return "Error: Exception in show_and_assert_fact"

##############################################################################
#
# find - return nested dictionary value given a dictionary (j) and a string
#		 element (element) in the form of "Garden.Flowers.White"
#
#############################################################################
    def find(self, element, j):
        if element == "":
            return j
        keys = element.split('+')
        rv = j
        for i, key in enumerate(keys):
            if key == '*':
                new_list = []
                new_keys = copy.deepcopy(keys[i+1:]) # all the keys past the * entry
                for entry in rv: # for each entry in the * dictionary
                    new_rv = copy.deepcopy(rv[entry])
                    for new_key in new_keys:
                        new_rv = new_rv[new_key]
                    for e in new_rv:
                        new_rv[e]["upper_value"] = entry
                    new_list.append(new_rv)
                return new_list
            else:
    # normal stepping through dictionary
                rv = rv[key]
        return [rv]

##############################################################################
#
# assert_template_fact - given a protofact, assert the fact into the clips system
# 						 protofact examples:
# protofact = {"template": "person-template", "slots": {"name": "Leeroy", "surname": "Jenkins", "age": 23.1}}
# protofact2 = {"template": "person-template", "slots": {"name": "Leeroy", "surname": "Jenkins", "age": "Leeroy.age"}}
#						 in protofact2, the age is unknown, but can be looked up in a sub_dictionary
#						 sub_dictionary example:
# sub_dictionary = {"Leeroy: {"age": 23.1, "height": 182, "gender": "M"},
#				    "Maria": {"age": 32.5, "height": 160, "gender": "F"}}
#
#############################################################################
    def assert_template_fact(self, protofact, add_slot, slot_value, sub_dictionary=None):
        try:
            template = self.env.find_template(protofact["template"])
            fact1 = template.new_fact()
            for slot, value in protofact["slots"].items():
    #
    # If the "value" is in a subdirectory, look up the final value in the sub_dictionary
    #
                if type(value) is str and "+" in value:
                    value = self.find(value, sub_dictionary)[0]
    #
    # if the value is a string, assert using CLIPs Symbol
    # if value is a number assert as a number
    #
                if type(value) is str:
                    fact1[slot] = clips.Symbol(value)
                else:
                    fact1[slot] = value
    # 
    # Append extra "slot" if there is a slot and slot_value passed in to the function
    #   
            if add_slot != 'none':
                fact1[add_slot] = clips.Symbol(slot_value)
    #
    # Assert the FACT
    #
            if self.control["debug-fact"] == 1:
                self.print_log("**** EMRE Debug: Assert Template FACT: " + str(fact1))
            try:
                fact1.assertit()
            except Exception as e:
                pass
        except Exception as e:
            self.print_log("%%%% EMRE Error: Exception assert_template_fact: " + str(e))

    ##############################################################################
    #
    # assert_syslog_fact - Convert the syslog message passed in to a
    #            to a FACT and assert in CLIPS
    #
    # The device syslog message has this form:
    # XR: RP/0/RSP0/CPU0:Apr 26 20:30:07.567 UTC: ifmgr[257]:
    #                    %PKT_INFRA-LINK-3-UPDOWN : Interface Loopback5, changed state to Down
    #
    #    The syslog message fact has this form:
    #       (deftemplate syslog-message
    #         (slot device)
    #         (slot source)
    #         (slot date)
    #         (slot time)
    #         (slot component)
    #         (slot syslog)
    #         (slot content)
    #       )
    #
    #############################################################################
    def assert_syslog_fact(self, fact):
        try:
            if self.control["mgmt-device"][5] == 'XR':
                parser = genie_str_to_class("ParseXRSyslogMessage")
                parsed_genie_output = parser.syslog(message=fact)
            if self.control["mgmt-device"][5] == 'XE':
                parser = genie_str_to_class("ParseXESyslogMessage")
                parsed_genie_output = parser.syslog(message=fact)

            if self.control["debug-syslog"] == 1:
                self.print_log("*** EMRE Debug: parsed Syslog output: " + str(parsed_genie_output))
            sub_dictionary = parsed_genie_output["syslog-message"]
            assert_fact = "(syslog-message (device " + str(self.control["mgmt-device"][4]) + ")"

            for key, value in sub_dictionary.items():
                if self.control["debug-syslog"] == 1:
                    self.print_log("**** EMRE Debug: key,value: " + str(key) + " " + str(value))
                if self.control["mgmt-device"][5] == 'XE':
                    if key == 'source': value = self.control["mgmt-device"][4]
                assert_fact = assert_fact + " (" + str(key) + " " + str(value) + ")"

            assert_fact = assert_fact + "))"
            if self.control["debug-syslog"] == 1:
                self.print_log("*** EMRE Debug: assert_syslog_fact: " + str(assert_fact))
    #
    # Assert the syslog FACT
    #
            try:
                self.env.assert_string(assert_fact)
            except: pass #ignore case where FACT already exists
            return
        except Exception as e:
            self.print_log("%%%% EMRE Error: Exception assert_syslog_fact: " + str(e))
            return

    ##############################################################################
    #
    # assert_rfc5277_fact - Convert the RFC5277 notification message generated for a Syslog message 
    #            to a FACT and assert in CLIPS
    #
    # The device syslog message has this form:
    # XR: RP/0/RSP0/CPU0:Apr 26 20:30:07.567 UTC: ifmgr[257]:
    #                    %PKT_INFRA-LINK-3-UPDOWN : Interface Loopback5, changed state to Down
    #
    #    The syslog message fact has this form:
    #       (deftemplate rfc5277-message
    #         (slot device)
    #         (slot source)
    #         (slot date)
    #         (slot time)
    #         (slot component)
    #         (slot syslog)
    #         (slot content)
    #       )
    #
    #############################################################################
    def assert_rfc5277_fact(self, fact):
        try:
            if self.control["mgmt-device"][5] == 'XR':
                parser = genie_str_to_class("ParseRFC5277Message")
                parsed_genie_output = parser.rfc5277(message=fact)
            if self.control["mgmt-device"][5] == 'XE':
                parser = genie_str_to_class("ParseRFC5277Message")
                parsed_genie_output = parser.rfc5277(message=fact)

            if self.control["debug-notify"] == 1:
                self.print_log("*** EMRE Debug: parsed RFC5277 output: " + str(parsed_genie_output))
            sub_dictionary = parsed_genie_output["rfc5277-message"]
            assert_fact = "(rfc5277-message (device " + str(self.control["mgmt-device"][4]) + ")"

            for key, value in sub_dictionary.items():
                if self.control["debug-notify"] == 1:
                    self.print_log("**** EMRE Debug: key,value: " + str(key) + " " + str(value))
                if self.control["mgmt-device"][5] == 'XE':
                    if key == 'source': value = self.control["mgmt-device"][4]
                if self.control["mgmt-device"][5] == 'XR':
                    if key == 'source': value = self.control["mgmt-device"][4]
                assert_fact = assert_fact + " (" + str(key) + " " + str(value) + ")"

            assert_fact = assert_fact + "))"
            if self.control["debug-notify"] == 1:
                self.print_log("*** EMRE Debug: assert_rfc5277_fact: " + str(assert_fact))
    #
    # Assert the syslog FACT
    #
            try:
                self.env.assert_string(assert_fact)
            except: pass #ignore case where FACT already exists
            return
        except Exception as e:
            self.print_log("%%%% EMRE Error: Exception assert_rfc5277_fact: " + str(e))
            return

    ##############################################################################
    #
    # assert_statistics_fact
    #
    #############################################################################
    def assert_statistics_fact(self, template_name, statistics):
        try:
            template = self.env.find_template(template_name)
            fact = template.new_fact()
            for key, value in statistics.items():
                fact[key] = value
            fact.assertit()
        except Exception as e:
            self.print_log("%%%% EMRE Error: Exception assert_statistics_fact: " + str(e))

    ##############################################################################
    #
    #  print_clips_info - Print facts and rules from main loop
    #
    #############################################################################
    def print_clips_info(self):
        try:
            if self.control["show-facts"] == 1:
                if self.control["fact-filter"] == ['all']:
                    self.print_log("\n####################### FACTs(all) Main - CLIPS Format ########################\n")
                    for fact in self.env.facts(): self.print_log(fact)

                elif self.control["fact-filter"] != ['none']:
                    self.print_log("\n####################### FACTs(filtered)  Main - CLIPS Format ########################\n")
                    for fact in self.env.facts():
                        for ffilter in self.control["fact-filter"]:
                            if str(ffilter) in str(fact): 
                                self.print_log(fact)

            if self.control["show-rules"] == 1:
                self.print_log("\n####################### EMRE Activated RULES Main ########################\n")
                for item in self.env.activations(): self.print_log(item)

#
# Show all facts in dictionary encoded format without filtering if dict_filter specifies all FACTS
#
            if self.control["show-dict"] == 1 and self.control["dict-filter"] == ['all']:
                self.print_log("\n####################### FACTs(all) Main - Python Dictionary Format ########################\n")
                for fact in self.env.facts():
                    try:
                        cleanfact = str(fact).split('  ')[-1]
                        templatename = cleanfact.split('(')
                        template = templatename[1].lstrip('(')
                        tempdict = "{'template': '" + str(template) + "', "
                        strfact = str(dict(fact))
                        stripquotes = strfact.split('  ')[-1].strip('"').lstrip("{")
                        finalfact = tempdict + stripquotes
                        self.print_log(finalfact.strip('"'))
                    except Exception as e:
                        self.print_log("%%%% EMRE Error: Print Dictionary exception: " + str(e))
                        pass
#
# Show dictionary encoded facts filtered by the dict_filter list unless 'none' is specified in the filter
#
            elif self.control["show-dict"] == 1 and self.control["dict-filter"] != ['none']:
                self.print_log("\n####################### FACTs(filtered) Main - Python Dictionary Format ########################\n")
                for fact in self.env.facts():
                    try:
                        cleanfact = str(fact).split('  ')[-1]
                        templatename = cleanfact.split('(')
                        template = templatename[1].lstrip('(')
                        for dfilter in self.control["dict-filter"]:
                            if str(dfilter) in template: 
                                tempdict = "{'template': '" + str(template) + "', "
                                strfact = str(dict(fact))
                                stripquotes = strfact.split('  ')[-1].strip('"').lstrip("{")
                                finalfact = tempdict + stripquotes
                                self.print_log(finalfact.strip('"'))
                    except Exception as e:
                        self.print_log("%%%% EMRE Error: Print Dictionary exception: " + str(e))
                        pass

        except Exception as e:
            self.print_log("%%%% EMRE Error: Exception print_clips_info: " + str(e))

    ##############################################################################
    #
    #  print_clips_info_run - Print facts and rules from run_ functions
    #
    #############################################################################
    def print_clips_info_run(self, when_run):
        try:
            if self.control["show-run-facts"] == 1:
                if self.control["fact-filter"] == ['all']:
                    self.print_log("\n####################### FACTs(all) Run Action " + str(when_run) +"- CLIPS Format ########################\n")
                    for fact in self.env.facts(): self.print_log(fact)

                elif self.control["fact-filter"] != ['none']:
                    self.print_log("\n####################### FACTs(filtered) Run Action " + str(when_run) +"- CLIPS Format ########################\n")
                    for fact in self.env.facts():
                        for ffilter in self.control["fact-filter"]:
                            if str(ffilter) in str(fact): 
                                self.print_log(fact)

            if self.control["show-rules"] == 1:
                self.print_log("\n####################### EMRE Activated RULES Run Action ########################\n")
                for item in self.env.activations(): self.print_log(item)

#
# Show all facts in dictionary encoded format without filtering if dict_filter specifies all FACTS
#
            if self.control["show-dict"] == 1 and self.control["dict-filter"] == ['all']:
                self.print_log("\n####################### FACTs(all) Run Action - Python Dictionary Format ########################\n")
                for fact in self.env.facts():
                    try:
                        cleanfact = str(fact).split('  ')[-1]
                        templatename = cleanfact.split('(')
                        template = templatename[1].lstrip('(')
                        tempdict = "{'template': '" + str(template) + "', "
                        strfact = str(dict(fact))
                        stripquotes = strfact.split('  ')[-1].strip('"').lstrip("{")
                        finalfact = tempdict + stripquotes
                        self.print_log(finalfact.strip('"'))
                    except Exception as e:
                        self.print_log("%%%% EMRE Error: Print Dictionary exception: " + str(e))
                        pass
#
# Send dictionary encoded facts filtered by the dict_filter list unless 'none' is specified in the filter
#
            elif self.control["show-dict"] == 1 and self.control["dict-filter"] != ['none']:
                self.print_log("\n####################### FACTs(filtered) Run Action - Python Dictionary Format ########################\n")
                for fact in self.env.facts():
                    try:
                        cleanfact = str(fact).split('  ')[-1]
                        templatename = cleanfact.split('(')
                        template = templatename[1].lstrip('(')
                        for dfilter in self.control["dict-filter"]:
                            if str(dfilter) in template: 
                                tempdict = "{'template': '" + str(template) + "', "
                                strfact = str(dict(fact))
                                stripquotes = strfact.split('  ')[-1].strip('"').lstrip("{")
                                finalfact = tempdict + stripquotes
                                self.print_log(finalfact.strip('"'))
                    except Exception as e:
                        self.print_log("%%%% EMRE Error: Print Dictionary exception: " + str(e))
                        pass

        except Exception as e:
            self.print_log("%%%% EMRE Error: Exception print_clips_info: " + str(e))

    ##############################################################################
    #
    #  send_clips_info - Send filtered facts and rules in the service impact notification
    #
    #############################################################################
    def send_clips_info(self):
        try:
            if self.control["send-clips"] == 1:
                if self.control["fact-filter"] == ['all']:
                    for fact in self.env.facts(): self.clips_facts = self.clips_facts + "      <cfact>" + str(fact) + "</cfact>\n"

                elif self.control["fact-filter"] != ['none']:
                    for fact in self.env.facts():
                        for ffilter in self.control["fact-filter"]:
                            if str(ffilter) in str(fact): 
                                self.clips_facts = self.clips_facts + "      <cfact>" + str(fact) + "</cfact>\n"
#
# Send all facts in dictionary encoded format without filtering if dict_filter specifies 'all'
#
            if self.control["send-dict"] == 1 and self.control["dict-filter"] == ['all']:
                for fact in self.env.facts():
                    try:
                        cleanfact = str(fact).split('  ')[-1]
                        templatename = cleanfact.split('(')
                        template = templatename[1].lstrip('(')
                        tempdict = "{'template': '" + str(template) + "', "
                        strfact = str(dict(fact))
                        stripquotes = strfact.split('  ')[-1].strip('"').lstrip("{")
                        finalfact = tempdict + stripquotes
                        self.dict_facts = self.dict_facts + "      <dfact>" + json.dumps(finalfact).strip('"') + "</dfact>\n"
                    except Exception as e:
                        if str(fact).find("retract") == -1:
                            self.print_log("%%%% EMRE Error: Send Dictionary exception: " + str(fact))
                        pass
#
# Send dictionary encoded facts filtered by the dict_filter list
#
            elif self.control["send-dict"] == 1 and self.control["dict-filter"] != ['none']:
                for fact in self.env.facts():
                    try:
                        cleanfact = str(fact).split('  ')[-1]
                        templatename = cleanfact.split('(')
                        template = templatename[1].lstrip('(')
                        for dfilter in self.control["dict-filter"]:
                            if str(dfilter) in template: 
                                tempdict = "{'template': '" + str(template) + "', "
                                strfact = str(dict(fact))
                                stripquotes = strfact.split('  ')[-1].strip('"').lstrip("{")
                                finalfact = tempdict + stripquotes
                                self.dict_facts = self.dict_facts + "      <dfact>" + json.dumps(finalfact).strip('"') + "</dfact>\n"
                    except Exception as e:
                        if str(fact).find("retract") == -1:
                            self.print_log("%%%% EMRE Error: Send Dictionary exception: " + str(fact))
                        pass

        except Exception as e:
            self.print_log("%%%% EMRE Error: Exception send_clips_info: " + str(e))


    ##############################################################################
    #
    #  save_dict_facts - Save dictionary facts in the emre-control dictionary-facts list
    #  (interfact-error-state (slot value) (slot value) (slot value))
    #
    #############################################################################
    def save_dict_facts(self):
        try:
            count = 1
            if self.control["save-dict-facts"] == 1 and self.control["dict-filter"] == ['all']:
                self.nc_facts = '<facts>'
                count = 1
                for fact in self.env.facts():
                    try:
                        cleanfact = str(fact).split('  ')[-1]
                        template = cleanfact.split('(')
                        name = template[1].lstrip('(').rstrip(' ')
                        templeaf = "<template>" + str(name) + "</template><slot-list>"
                        self.nc_facts = self.nc_facts + "<fact><id>" + str(count) + "</id>"
                        self.nc_facts = self.nc_facts + str(templeaf)
                        fact_len = len(template)
    #
    # add each fact to the slot-list
    #
                        index = 2
                        while index <= fact_len - 1:
                            strfact = str(template[index]).rstrip(' ').rstrip(')')
                            stripfact = strfact.split(' ')
                            self.nc_facts = self.nc_facts + "<slots><slot>" + str(stripfact[0]) + "</slot><value>" + str(stripfact[1]) + "</value></slots>"
                            index = index + 1
                        count = count + 1
                        self.nc_facts = self.nc_facts + "</slot-list></fact>"

                    except Exception as e:
                        self.print_log("%%%% EMRE Error: save_dict_facts unfiltered: " + str(e))
                        pass
                self.nc_facts = self.nc_facts + '</facts>'
#
# Send dictionary encoded facts filtered by the dict_filter list
#
            elif self.control["save-dict-facts"] == 1 and self.control["dict-filter"] != ['none']:
                self.nc_facts = '<facts>'
                count = 1
                for fact in self.env.facts():
                    try:
                        cleanfact = str(fact).split('  ')[-1]
                        template = cleanfact.split('(')
                        name = template[1].lstrip('(').rstrip(' ')
                        for dfilter in self.control["dict-filter"]:
                            if str(dfilter) == name:
                                templeaf = "<template>" + str(name) + "</template><slot-list>"
                                self.nc_facts = self.nc_facts + "<fact><id>" + str(count) + "</id>"
                                self.nc_facts = self.nc_facts + str(templeaf)
                                fact_len = len(template)
    #
    # add each fact to the slot-list
    #
                                index = 2
                                while index <= fact_len - 1:
                                    strfact = str(template[index]).rstrip(' ').rstrip(')')
                                    stripfact = strfact.split(' ')
                                    self.nc_facts = self.nc_facts + "<slots><slot>" + str(stripfact[0]) + "</slot><value>" + str(stripfact[1]) + "</value></slots>"
                                    index = index + 1
                                count = count + 1
                                self.nc_facts = self.nc_facts + "</slot-list></fact>"

                    except Exception as e:
                        self.print_log("%%%% EMRE Error: save_dict_facts filtered: " + str(e))
                        pass
                self.nc_facts = self.nc_facts + '</facts>'

        except Exception as e:
            self.print_log("%%%% EMRE Error: Exception save_dict_facts: " + str(e))

    ##############################################################################################
    #
    # get_initial_facts
    #
    ##############################################################################################
    def get_initial_facts(self):
        try:
    #
    # assert a fact for each instance in the fact list
    #
            for fact in self.control["initial-facts-list"]:
                if self.control["debug-fact"] == 1:
                    self.print_log("**** EMRE Debug: Assert initial fact: ")
                    self.print_log(fact)
                try:
                    self.env.assert_string(fact)
                except: pass #ignore case where FACT already exists

        except Exception as e:
            self.print_log("%%%%% EMRE Error: Error asserting initial fact: " + str(fact))
        return

    #
    # assert a fact for each instance in the fact list 
    #
        for fact in self.control["test-facts"]:
            if self.control["debug-fact"] == 1:
                self.print_log("**** EMRE Debug: Assert test fact: ")
                self.print_log(fact)
            try:
                self.env.assert_string(fact)
            except: pass #ignore case where FACT already exists
        return

##############################################################################################
#
# assert_test_facts
#
##############################################################################################
    def assert_test_facts(self, test_fact):
#
# assert a fact for each instance in the fact list
#
        fact_count = int(test_fact[0])
        for i in range(int(fact_count)):
           if self.control["debug-fact"] == 1:
               self.print_log("**** EMRE Debug: Assert test fact: ")
               self.print_log(test_fact[i + 1])
           try:
               self.env.assert_string(test_fact[i + 1])
           except: pass #ignore case where FACT already exists    
        return

    #############################################################################
    #
    # Close open netconf device sessions and other open connections
    #
    #############################################################################
    def close_sessions(self):
        try:
            self.netconf_connection.close_session()
            self.notify_conn.close_session()
            for dev in self.device:
                dev.close_session()
        except Exception as e:
            self.print_log("%%%% EMRE Error: Closing NETCONF sessions: " + str(e))
            sys.exit(0)

    ##############################################################################
    #
    #  print_log - log message to debug control["log-file"] if enabled otherwise only display
    #              logging messages on command line
    #     debug-logging controls logging behavior
    #        0 - Display log messages on stdout
    #        1 - Write log messages to the path defined in the FACT file with a timestamp added
    #        2 - Write log messages to stdout and log file path
    #
    #############################################################################
    def print_log(self, logMessage):
        try: 
            if self.control["debug-logging"] == 0 : print(logMessage)
            if self.control["debug-logging"] >= 1: 
                with open(self.control["log-path"] + self.control["log-file"] + "_" + str(self.control["session-time"]), 'a+') as debuglog_file:
                    debuglog_file.write(str(logMessage) + "\n")
                if self.control["debug-logging"] == 2: print(logMessage)
        except Exception as e:
            print("%%%% EMRE Error: Error writing to log file: " + str(e))


    #################################################################################################
    #
    # run_cli_command - Runs a CLI command on the host.  If the output from the command should
    # be redirected, for example to bootflash:, the path for the redirected output is provided.
    # The list 'cli_cmd' is defined in the FACTS file
    # The list is a nested list with each entry defining a CLI command to execute
    #
    # Commands are executed using the python "cli" package in the guestshell
    #
    #  cli.cli("show interface GigabitEthernet 0/0 status | redirect flash:runtest2")
    # Sample FACTS file content
    # cli_cmd = [[['flash:memleak-1-run-cli-log', 'show run interface GigabitEthernet 0/0 | redirect RUN_FILE_NAME ', 'none/nvram/local/both', 1,
    # , {'ndbmand':'ndbman', 'linux_iosd-imag':'ios'}]]]
    #
    # This function is called from CLIPs rules using this format:
    #    (run_cli_command 0 emre_show_tech_acl 0 0 notime)
    #      0 - index into the cli_cmd list in the fact file
    #    emre_show_tech_acl - Filename to include in the command output if writing output to a file
    #      0 0 - Parameters to control substitution of values if required
    #     notime - Do not add a timestamp to the generated file, 'time' if a timestamp should be added to the file name
    #
    #################################################################################################
    def run_cli_command(self, cli_index, filename, parameter1, parameter2, addtime):
        if self.control["actions"] == 1:
            command_idx = int(cli_index)
            timestamp =  datetime.now().strftime("%m-%d-%Y_%H:%M:%S.%f")
            
        #######################################################################
        #
        # Process each CLI command in the list identified in the RULE callback
        # If filename is not equal to 'none' include the filename argument in the data file name
        #
        #######################################################################
            try:
                cmdline = self.cli_cmd[command_idx]
                if self.control["debug-CLI"] == 1:
                    self.print_log("**** EMRE Debug: run_cli_cmd: cmdline: " + str(cmdline))
                if addtime == 'time':
                    timestring = "_" + timestamp
                else:
                    timestring = ""
                if filename == 'none':
                    outfile = cmdline[0] + timestring
                else:
                    outfile = cmdline[0] + "_" + str(filename) + timestring
        #
        # substitute parameters in command string if included in call from rule
        #
                if cmdline[3] == 0:
                    command = str(cmdline[1])
                else:
                    translated_value = self.translation_dict.get(str(parameter1))
                    if not translated_value:
                        return
                    if cmdline[3] == 1:
                        first = translated_value
                        command = str(cmdline[1]).format(first)
                    elif cmdline[3] == 2:
                        (first, second) = translated_value
                        command = str(cmdline[1]).format(first, second)
                    elif cmdline[3] == 3:
                        (first, second) = translated_value
                        third = parameter2
                        command = str(cmdline[1]).format(first, second, third)
        #
        # if command result is written to a file in nvram insert the file name into the cli command
        #
                if cmdline[2] == 'none':
                    out_command = command
                else:
                    out_command = command.replace('RUN_FILE_NAME', str(outfile))
        #######################################################################
        #
        # If the location to save the data is 'nvram' only write the command results to the device flash/bootflash
        #
        #######################################################################
                try:
                    if self.control["debug-CLI"] == 1:
                        self.print_log("**** EMRE Debug: run_cli_cmd: out_command: " + str(out_command))
                    cli.cli(out_command)
                    if self.control["debug-CLI"] == 1:
                        self.print_log("**** EMRE Notice: CLI Command Executed: " + str(out_command) + " at: " + str(timestamp))
                except Exception as e:
                    self.print_log("%%%% EMRE run_cli_cmd Error: Exception writing to nvram: " + str(e) + "\n")
            except Exception as e:
                self.print_log("%%%% EMRE run_cli_cmd Error: Exception command processing: " + str(e) + "\n")

    #################################################################################################
    #
    # run_show_parameter - Runs a show command on the host.  The show command request can include up
    #                      to three parameters that can be passed from the RULE to include in the command
    #
    # Example:(run_show_parameter 0 ssh "show ip bgp neighbor {0} | include local" ?neighbor none none)
    #    0 - The index into the show_parameter FACT list
    #    ssh/cli - Selects method for running the show command
    #    "command" - Template for command with {} included for parmeter substition
    #    pcount - Number of parameters to substitute
    #    3 parameters - Up to 3 parameters can be passed, typically FACT data from rules to insert into the command
    #
    #
    #################################################################################################
    def run_show_parameter(self, fact_index, access_type, show_template, pcount, par1, par2, par3, no_fact, yes_fact):
        if self.control["actions"] == 1:
            index = int(fact_index)
            fact = self.control["show-parameter-fact-list"][int(index)]
            timestamp =  datetime.now().strftime("%m-%d-%Y_%H:%M:%S.%f")
            
        #######################################################################
        #
        # Generate the show command with parameters
        #
        #######################################################################
            try:
                cmdline = str(show_template)
                if self.control["debug-CLI"] == 1:
                    self.print_log("**** EMRE Debug: run_show_parameter: cmdline: " + str(cmdline))
        #
        # substitute parameters in command string if included in call from rule
        #
                if int(pcount) == 0:
                    command = str(cmdline)
                else:
                    if int(pcount) == 1:
                        command = str(show_template).format(str(par1))
                    elif int(pcount) == 2:
                        command = str(show_template).format(str(par1), str(par2))
                    elif int(pcount) == 3:
                        command = str(show_template).format(str(par1), str(par2), str(par3))
                try:
                    if self.control["debug-CLI"] == 1:
                        self.print_log("**** EMRE Debug: run_show_parameter: command: " + str(command))
        #
        # If access-type is cli use the Python CLI package to run command
        #
                    if str(access_type) == 'cli':
                        response = cli.cli(command)
                        if self.control["debug-CLI"] == 1:
                            self.print_log("**** EMRE Notice: CLI Command Executed: " + str(command) + " at: " + str(timestamp))
                    else:
        #
        # Use SSH to run the show command
        #
                        try:
                            options = '-q -oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null -oPubkeyAuthentication=no'
                            ssh_cmd = 'ssh %s@%s %s "%s"' % (self.control["mgmt-device"][2], self.control["mgmt-device"][0], options, command)
                            if self.control["debug-CLI"] == 1:
                                self.print_log("**** EMRE Debug: run_show_parameter SSH command: " + str(ssh_cmd) + "\n")
                            child = pexpect.spawn(ssh_cmd, timeout= 20, encoding='utf-8')
                            child.delaybeforesend = None
                            if self.control["debug-CLI"] == 1:
                                child.logfile = sys.stdout
                            child.expect(['\r\nPassword: ', '\r\npassword: ', 'Password: ', 'password: '])
                            child.sendline(self.control["mgmt-device"][3])
                            child.expect(pexpect.EOF) #result contains the ping result
                            response = child.before

                        except Exception as e:
                            child.close()
                            self.print_log("%%%% EMRE run_show_parameter SSH or timeout Error: " + str(ssh_cmd) + "\n")
                        child.close()
         #
         # Assert the FACTs for using the response
         #
                    fact_found = False
                    try:
                        if "error" in response:
                            self.print_log("%%%% EMRE Error: error in run_show_parameter show command response")
                            return "Error: show_and_assert show command response"
                        parser = genie_str_to_class(fact["genie_parser"])
                        if type(parser) == str:
                            return parser
                        parsed_genie_output = parser.parse(output=response)
                        if self.control["debug-CLI"] == 1:
                            self.print_log("**** EMRE Debug: run_show_parameter genie: " + str(parsed_genie_output) + "\n")
                        if parsed_genie_output == {}:
                            return "success"
        #
        # Get the starting point in the Python dictionary containing the parsed content
        #
                        sub_dictionary_list = self.find(fact["assert_fact_for_each_item_in"], parsed_genie_output)
                        import copy
                        for sub_dictionary in sub_dictionary_list:
                            for item in sub_dictionary:
                                protofact = copy.deepcopy(fact["protofact"])
                                for slot in protofact["slots"]:
                                    value = protofact["slots"][slot]
	#
	# insert the device name into the fact
	#
                                    if value == "device":
                                        protofact["slots"][slot] = value.replace("device", fact["device"])
                                    elif type(value) == str and "$" in value:
                                        protofact["slots"][slot] = value.replace("$", item)
                                fact_found = True
                                self.assert_template_fact(protofact, 'device', fact["device"], sub_dictionary)
        #
        # Test to see if a FACT should be asserted if no FACT was asserted as a result of executing the command
        #
                            try:
                                if (str(yes_fact) != 'no-fact') and (fact_found == True):
                                    self.env.assert_string(str(yes_fact))
                                if (str(no_fact) != 'no-fact') and (fact_found == False):
                                    self.env.assert_string(str(no_fact))
                            except: pass

                            return "success"

                    except Exception as e:
                        self.print_log("%%%% EMRE Error: Exception in run_show_parameter response processing: " + str(e))
                        return "Exception in ssh run_show_parameter response processing"

                except Exception as e:
                    self.print_log("%%%% EMRE run_show_parameter Error: Exception sending show command: " + str(e) + "\n")
            except Exception as e:
                self.print_log("%%%% EMRE run_show_parameter Error: Exception generating show command: " + str(e) + "\n")

    #################################################################################################
    #
    # run_cli_parameter - Runs a cli command on the host.  The show command request can include up
    #                      to three parameters that can be passed from the RULE to include in the command
    #
    # Example:(run_cli_parameter ssh "show ip bgp neighbor {0} | include local" ?neighbor none none)
    #    ssh/cli - Selects method for running the show command
    #    "command" - Template for command with {} included for parmeter substition
    #    pcount - Number of parameters to substitute
    #    3 parameters - Up to 3 parameters can be passed, typically FACT data from rules to insert into the command
    #
    #
    #################################################################################################
    def run_cli_parameter(self, access_type, show_template, pcount, par1, par2, par3):
        if self.control["actions"] == 1:
            timestamp =  datetime.now().strftime("%m-%d-%Y_%H:%M:%S.%f")
            
        #######################################################################
        #
        # Generate the show command with parameters
        #
        #######################################################################
            try:
                cmdline = str(show_template)
                if self.control["debug-CLI"] == 1:
                    self.print_log("**** EMRE Debug: run_show_parameter: cmdline: " + str(cmdline))
        #
        # substitute parameters in command string if included in call from rule
        #
                if int(pcount) == 0:
                    command = str(cmdline)
                else:
                    if int(pcount) == 1:
                        command = str(show_template).format(str(par1))
                    elif int(pcount) == 2:
                        command = str(show_template).format(str(par1), str(par2))
                    elif int(pcount) == 3:
                        command = str(show_template).format(str(par1), str(par2), str(par3))
                try:
                    if self.control["debug-CLI"] == 1:
                        self.print_log("**** EMRE Debug: run_cli_parameter: command: " + str(command))
        #
        # If access-type is cli use the Python CLI package to run command
        #
                    if str(access_type) == 'cli':
                        cli.cli(command)
                        if self.control["debug-CLI"] == 1:
                            self.print_log("**** EMRE Notice: CLI Command Executed: " + str(command) + " at: " + str(timestamp))
                    else:
        #
        # Use SSH to run the show command
        #
                        try:
                            options = '-q -oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null -oPubkeyAuthentication=no'
                            ssh_cmd = 'ssh %s@%s %s "%s"' % (self.control["mgmt-device"][2], self.control["mgmt-device"][0], options, command)
                            if self.control["debug-CLI"] == 1:
                                self.print_log("**** EMRE Debug: run_cli_parameter SSH command: " + str(ssh_cmd) + "\n")
                            child = pexpect.spawn(ssh_cmd, timeout= 20, encoding='utf-8')
                            child.delaybeforesend = None
                            if self.control["debug-CLI"] == 1:
                                child.logfile = sys.stdout
                            child.expect(['\r\nPassword: ', '\r\npassword: ', 'Password: ', 'password: '])
                            child.sendline(self.control["mgmt-device"][3])
                            child.expect(pexpect.EOF) #result contains the ping result
                            response = child.before

                        except Exception as e:
                            child.close()
                            self.print_log("%%%% EMRE run_cli_parameter SSH or timeout Error: " + str(ssh_cmd) + "\n")
                        child.close()

                except Exception as e:
                    self.print_log("%%%% EMRE run_cli_parameter Error: Exception sending show command: " + str(e) + "\n")
            except Exception as e:
                self.print_log("%%%% EMRE run_cli_parameter Error: Exception generating show command: " + str(e) + "\n")

    #################################################################################################
    #
    # run_copy_file - Copy the infile to the outfile.  Gives RULEs direct control for persisting
    #                 files storing collected data
    #
    ##################################################################################################

    def run_copy_file(self, infile, outfile):
        if self.control["actions"] == 1:
            timestamp =  datetime.now().strftime("%m-%d-%Y_%H:%M:%S.%f")
            
            try:
                with open(str(infile), 'r') as rfd:
                    indata = rfd.read()
                    rfd.close()
                out_path = str(outfile) + "_" + str(timestamp)
                with open(out_path, 'w') as wfd:
                    wfd.write(indata)
                    wfd.close()
                if self.control["debug-CLI"] == 1:
                    self.print_log("**** EMRE Debug: run_copy_file infile: " + str(infile) + " outfile: " + out_path)
            except Exception as e:
                self.print_log("%%%% EMRE run_copy_file Error: Exception command processing: " + str(e))

    #################################################################################################
    #
    # run_ssh_cli_command - Runs a CLI command on the host.  If the output from the command should
    # be redirected, for example to bootflash:, the path for the redirected output is provided.
    # The list 'cli_cmd' is defined in the FACTS file
    # The list is a nested list with each entry defining a CLI command to execute
    #
    # Commands are executed ssh to apply the CLI command to the device
    #
    #
    # Sample FACTS file content
    # cli_cmd = [[['flash:memleak-1-run-cli-log', 'show run interface GigabitEthernet 0/0 | redirect RUN_FILE_NAME ', 'none/nvram/local/both', 1,
    # , {'ndbmand':'ndbman', 'linux_iosd-imag':'ios'}]]]
    #
    #################################################################################################
    def run_ssh_cli_command(self, cli_index, filename, parameter1, parameter2, addtime):
        if self.control["actions"] == 1:
            command_idx = int(cli_index)
            timestamp =  datetime.now().strftime("%m-%d-%Y_%H:%M:%S.%f")
            
        #######################################################################
        #
        # Process each CLI command in the list identified in the RULE callback
        # If filename is not equal to 'none' include the filename argument in the data file name
        #
        #######################################################################
            try:
                cmdline = self.cli_cmd[command_idx]
                if self.control["debug-CLI"] == 1:
                    self.print_log("**** EMRE Debug: run_ssh_cli_command: cmdline: " + str(cmdline))
                if addtime == 'time':
                    timestring = "_" + timestamp
                else:
                    timestring = ""
                if filename == 'none':
                    outfile = cmdline[0] + timestring
                else:
                    outfile = cmdline[0] + "_" + str(filename) + timestring
        #
        # substitute parameters in command string if included in call from rule
        #
                if cmdline[3] == 0:
                    command = str(cmdline[1])
                else:
                    translated_value = self.translation_dict.get(str(parameter1))
                    if not translated_value:
                        return
                    if cmdline[3] == 1:
                        first = translated_value
                        command = str(cmdline[1]).format(first)
                    elif cmdline[3] == 2:
                        (first, second) = translated_value
                        command = str(cmdline[1]).format(first, second)
                    elif cmdline[3] == 3:
                        (first, second) = translated_value
                        third = parameter2
                        command = str(cmdline[1]).format(first, second, third)
        #
        # if command result is written to a file in nvram insert the file name into the cli command
        #
                if cmdline[2] == 'none':
                    out_command = command
                else:
                    out_command = command.replace('RUN_FILE_NAME', str(outfile))
        #######################################################################
        #
        # If the location to save the data is 'nvram' only write the command results to the device flash/bootflash
        #
        #######################################################################
                try:
                    options = '-q -oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null -oPubkeyAuthentication=no'
                    ssh_cmd = 'ssh %s@%s %s "%s"' % (self.control["mgmt-device"][2], self.control["mgmt-device"][0], options, out_command)
                    if self.control["debug-CLI"] == 1:
                        self.print_log("**** EMRE Debug: run_ssh_cli_command SSH command: " + str(ssh_cmd) + "\n")
                    try:
                        child = pexpect.spawn(ssh_cmd, timeout= 20, encoding='utf-8')
                        child.delaybeforesend = None
                        if self.control["debug-CLI"] == 1:
                            child.logfile = sys.stdout
                        child.expect(['\r\nPassword: ', '\r\npassword: ', 'Password: ', 'password: '])
                        child.sendline(self.control["mgmt-device"][3])
                        child.expect(pexpect.EOF) #result contains the ping result
                        result = child.before
                    except Exception as e:
                        child.close()
                        self.print_log("%%%% EMRE run_ssh_cli_command SSH or timeout Error: " + str(ssh_cmd) + "\n")

                    child.close()
                except Exception as e:
                    self.print_log("%%%% EMRE run_ssh_cli_command Error: Exception writing to nvram: " + str(e) + "\n")
            except Exception as e:
                self.print_log("%%%% EMRE run_ssh_cli_command Error: Exception command processing: " + str(e) + "\n")


    #################################################################################################
    #
    # run_command - Runs a CLI command on the host.  No output is collected or returned.
    #               Example: "clear arp 10.1.4.5"
    #               The delay argument specifies the time in ms to delay after running the command
    #
    #################################################################################################
    def run_command(self, command, delay):
        if self.control["actions"] == 1:
            try:
                if self.control["debug-CLI"] == 1:
                    self.print_log("**** EMRE Debug: run_command: " + str(command))
                result = cli.cli(command)
                if self.control["debug-CLI"] == 1:
                    self.print_log("**** EMRE Debug: run_command result: " + str(result))
                if int(delay) > 0:
                    if self.control["debug-CLI"] == 1:
                        self.print_log("**** EMRE Debug: run_command delay ms: " + str(delay))
                    time.sleep(int(delay)/1000)
                    if self.control["debug-CLI"] == 1:
                        self.print_log("**** EMRE Debug: run_command delay complete")
            except Exception as e:
                self.print_log("%%%% EMRE run_command Error: Exception: " + str(e) + "\n")

    ###########################################################################################
    #
    # run_clear_selected_facts - Clear facts in the knowledge base for template passed in the argument
    #
    ###########################################################################################
    def run_clear_selected_facts(self, template):
        for fact in self.env.facts():
            try:
                if str(template) in str(fact):
                    fact.retract()
                    break
            except Exception as e:
                self.print_log("%%%% EMRE Error: run_clear_selected_facts: " + str(e))

    ###########################################################################################
    #
    # run_nc_fact - This function called from a rule collects data using the NETCONF interface
    #               The first argument is the index into the nc_facts list and the remaining
    #               arguments include the number of substitutions and variables that will
    #               substituted into the NC operation
    #
    #               Example: (run_nc_fact 0 num-parameters slot slot-value split ?adddress ?interface)
    #                        (run_nc_fact 0 1 neighbor ?neighbor none arg1)
    ###########################################################################################
    def run_nc_fact(self, *args):
        if self.control["debug-fact"] == 1:
                self.print_log("**** EMRE Debug: run_nc_facts facts: " + str(args))
        try:
    #
    # Extract the arguments from the call from the RULE
    # 1st argument is index into "nc-fact-list"
    # 2nd argument is the number of parameters to substitute into the NETCONF request
    # Remaining arguments are inserted into the NETCONF request using string.format method
    #            
            sub_params = []
            j = 0
            split = 'none'
            try:
                for argval in args:
                    if j == 0: index = int(argval)
                    if j == 1: num_params = int(argval)
                    if j == 2: slot = argval
                    if j == 3: slot_value = argval
                    if j == 4: split = argval #This argument = 'split' if the next argument is an interface name
                    if j > 4:
                        if (j == 5) and (split == 'split'):
                            interface = argval.partition('Ethernet')
                            sub_params.append(interface[0] + interface[1])
                            sub_params.append(interface[2])
                            split = 'none'
                            num_params = num_params + 1
                        else: sub_params.append(str(argval))
                    j = j + 1
            except Exception as e:
                self.print_log("%%%%% EMRE Error: run_nc_fact argument error: " +str(sub_params) + " " + str(e))
                return

            if self.control["debug-fact"] == 1:
                self.print_log("**** EMRE Debug: run_nc_facts nc-fact-list:\n" + str(self.control["nc-fact-list"]))

            raw_fact = copy.deepcopy(self.control["nc-fact-list"][index])
            fact_data = raw_fact["data"]
            fact_msg = fact_data[3]
#
# Substitute arguments from the rule function call into the Netconf operation
#
            try:
                if num_params == 0:
                   formatted = str(fact_msg)
                elif num_params == 1:
                   formatted = str(fact_msg).format(str(sub_params[0]))
                elif num_params == 2:
                   formatted = str(fact_msg).format(str(sub_params[0]), str(sub_params[1]))
                elif num_params == 3:
                   formatted = str(fact_msg).format(str(sub_params[0]), str(sub_params[1]), str(sub_params[2]))
                elif num_params == 4:
                   formatted = str(fact_msg).format(str(sub_params[0]), str(sub_params[1]), str(sub_params[2]), str(sub_params[3]))
                else:
                    self.print_log("%%%%% EMRE Error: run_nc_fact invalid # arguments: " + str(num_params))
                    return

            except Exception as e:
                self.print_log("%%%%% EMRE Error: run_nc_fact format message: " + str(e))
               
            if self.control["debug-fact"] == 1:
                self.print_log("**** EMRE Debug: run_nc_facts facts: " + str(fact_msg))

            fact_data[3] = formatted
            raw_fact["data"] = fact_data
            fact = raw_fact

            if fact["fact_type"] == "multitemplate":
                status = self.get_template_multifacts(fact["data"], slot, slot_value)
            elif fact["fact_type"] == "multitemplate_protofact":
                status = self.get_template_multifacts_protofact(fact, slot, slot_value)
            else:
                self.print_log("%%%%% EMRE Error: run_nc_facts Invalid fact type: " + str(fact))
            if status != "success":
                self.print_log("%%%%% EMRE Error: run_nc_facts Fact Read Error: " + str(status))
#
# If required return clips facts and a dictionary representation of facts in the Service Impact Notification
# FACTs are sent before running clips to capture all facts that were present before the rules were run
#
            self.clips_facts = ''
            self.dict_facts = ''
            if self.control["send-before"] == 1:
                self.send_clips_info()
                self.save_dict_facts()

        except Exception as e:
            self.print_log("\n%%%% EMRE Error: Exception in run_nc_fact: " + str(e))

    ###########################################################################################
    #
    # run_show_fact - This function called from a rule collects data using a show command
    #                 The show command can be executed using ssh to connect to a device or
    #                 using the Python cli package to run CLI commands from the guestshell
    #
    #               Example: (run_show_fact 0)
    #                where 0 is the index into the "show_fact_list" and ssh|cli defines the collection method
    ###########################################################################################
    def run_show_fact(self, index):
        if self.control["debug-fact"] == 1:
                self.print_log("**** EMRE Debug: run_show_facts entry: " + str(index))
        try:

            fact = self.control["show-fact-list"][int(index)]
            if self.control["debug-fact"] == 1:
                    self.print_log("**** EMRE Debug: run_show_facts fact: " + str(fact))
            status = self.show_and_assert_fact(fact)
            if status != "success":
                self.print_log("%%%%% EMRE Error: run_show_facts Fact Read Error: " + str(status))
#
# If required return clips facts and a dictionary representation of facts in the Service Impact Notification
# FACTs are sent before running clips to capture all facts that were present before the rules were run
#
            self.clips_facts = ''
            self.dict_facts = ''
            if self.control["send-before"] == 1:
                self.send_clips_info()
                self.save_dict_facts()

        except Exception as e:
            self.print_log("\n%%%% EMRE Error: Exception in run_show_fact: " + str(e))


#############################################################################
#
#  run_apply_config(config_id) - This function is called from the CLIPS RULES
#    if an edit-config action is required.  'config_id' is the index for the 
#    config message in the list of lists 'edit_configs'
#
# Apply configurations using RULES action functions
# If commit is required, send the commit rpc after applying edit_config
# Configuration operations are stored as list entries.  This is an example:
#
#    edit_configs = [[0, 'none',
#                     '<config><native xmlns="http://cisco.com/ns/yang/Cisco-IOS-XE-native"><interface><Loopback>
#                       <name>111</name><description>LB111</description></Loopback></interface></native></#config>'],
#
#                    [0, 'none',
#                     '<config><native xmlns="http://cisco.com/ns/yang/Cisco-IOS-XE-native"><interface><Loopback 
#                       xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="delete"><name>111</name></Loopback></interface></native></config>']]
#
#  The first argument is the index of the device NETCONF instance for ncclient
#  The second argument is 'commit' if the device uses the candidate datastore and requires 'commit/'
#    the argument is 'none' if the device uses the 'running-configuration'
#  The third argument is the 'config' section of the edit-config operations, for example
#    copied from YangSuite
#
#############################################################################
    def run_apply_config(self, config_id):
        try:
            config_key = int(config_id)
            edit_msg = self.control["edit-configs"][config_key]
            device = self.device[edit_msg[1]]
            if self.control["actions"] == 1:
#
# Use candidate datastore and "commit" for XR configurations
#
                if edit_msg[2] == 'commit':
                    datastore = 'candidate'
                    try:
                        result = device.edit_config(str(edit_msg[3]), target=datastore)
                        if self.control["debug-config"] == 1:
                            self.print_log("**** EMRE Debug: apply configuration:\n" + str(edit_msg[3]))
                            self.print_log("**** EMRE Debug: edit_config result\n" + str(result.xml))
                        result = dedvice.commit()
                    except Exception as e:
                       self.print_log("%%%% Error applying configuration: ", str(config_key) + "\n" + str(e))
#
# Use running configuration for XE and NX-OS if commit_required = 0
#
                if edit_msg[2] == 'none':
                    datastore = 'running'
                    try:
                        result = device.edit_config(str(edit_msg[3]), target=datastore)
                        if self.control["debug-config"] == 1:
                            self.print_log("**** EMRE Debug: apply configuration:\n" + str(edit_msg[3]))
                            self.print_log("**** EMRE Debug: edit_config result\n" + str(result.xml))
                    except Exception as e:
                        self.print_log("%%%% Error applying configuration: " + str(edit_msg[3]) + "\n" + str(e))

        except Exception as e:
            self.print_log("%%%% Error in run_apply_config: " + str(e))


############################################################################################
#
# run_emre - This action function runs the CLIPs engine when called from a rule
#
############################################################################################
    def run_emre(self):
        try:
            self.print_clips_info_run(' BEFORE ')
            self.env.run()
            self.print_clips_info_run(' AFTER' )
        except Exception as e:
            self.print_log("\n%%%% EMRE Error: Exception when running inference engine in run_action" + str(e))
            self.close_sessions()
            sys.exit(0)

############################################################################################
#
# run_action - This action function invoked from a rule will cause execution of commands
#              to collect and assert FACTs and will run CLIPs to process new FACTs
#
############################################################################################
    def run_action(self, action_fact_index):
        try:
            index = int(action_fact_index)
            for fact in self.control["action-fact-list"][index]:
                if self.control["debug-fact"] == 1:
                    self.print_log("**** EMRE Debug: run_action facts: " + str(fact))
                if fact["fact_type"] == "show_and_assert":
                    if "log_message_while_running" in fact:
                        self.print_log(fact["log_message_while_running"])
                    status = self.show_and_assert_fact(fact)
                elif fact["fact_type"] == "multitemplate":
                    status = self.get_template_multifacts(fact["data"], 'none', 'none')
                elif fact["fact_type"] == "multitemplate_protofact":
                    status = self.get_template_multifacts_protofact(fact, 'none', 'none')
                else:
                    self.print_log("%%%%% EMRE Error: Invalid fact type: " + str(fact))
                if status != "success":
                    self.print_log("%%%%% EMRE Error: Fact Read Error: " + str(status))
#
# log the FACTS asserted and triggered RULES on the agenda before CLIPs runs 
#
#PVH            self.print_clips_info()
#
# If required return clips facts and a dictionary representation of facts in the Service Impact Notification
# FACTs are sent before running clips to capture all facts that were present before the rules were run
#
            self.clips_facts = ''
            self.dict_facts = ''
            if self.control["send-before"] == 1:
                self.send_clips_info()
                self.save_dict_facts()

        except Exception as e:
            self.print_log("\n%%%% EMRE Error: Exception in run_action: " + str(e))


    #################################################################################################
    #
    # get_facts - Retrun a list of FACTs to the eMRE runtime to assert
    #
    #TTT
    #################################################################################################

    def run_get_facts(self):
        return (self.assert_facts)

    #################################################################################################
    #
    # run_timer - This action function starts a thread to generate a timer to assert a FACT on
    #             a regular time interval. When the timer is running FACTs are generated of the form:
    #        (check-bgp-timer (timer TRUE) (time 4596) (system-time 2020-10-01_03:09:55)
    #TTT
    #################################################################################################

    def run_rule_timer(self):

        try:
            timestamp =  datetime.now().strftime("%m-%d-%Y_%H:%M:%S.%f")
            
            hms = datetime.now().strftime("%H:%M:%S")
            h, m, s = [int(i) for i in hms.split(':')]
            timer_time = int(3600*h + 60*m + s)
        #
        # Build timer fact
        #
            message = '(' + str(self.control["timer-fact-name"]) + ' (timer TRUE) (time ' + str(timer_time) + ') (system-time ' + str(timestamp) + '))'
            if self.control["debug-fact"] == 1:
                self.print_log("**** EMRE Debug: run_time fact: " + str(message))
            try:
                self.env.assert_string(message)
                self.env.run() #Run CLIPs to execute RULEs activated as a result of asserting the timer FACT
            except Exception as e:
                self.print_log("%%%% EMRE: Exception in run_time: " + str(e))

#PVH make time a parameter
# Run the timer
#
            Timer(float(self.control["fact-timer"]), self.rule_timer).start()
        except Exception as e:
            self.print_log("%%%% EMRE: run_timer exception: " + str(e))

    #################################################################################################
    #
    # run_ping_action - This action function called from CLIPs rules runs a ping command
    #     The rule call has this format: (run_ping_action none ?neighbor count ?min-success ?src-interface action-ping-2)
    #       mode - cli/ssh run using python cli package or using ssh 
    #       vrf - vrf-name or none - do not include a vrf in the ping command
    #       ?neighbor - ip address of neighbor to ping
    #       count - number of pings to run
    #       ?min-success - minimum % of pings that must succeed
    #       ?src-interface - interface to run ping command through
    #       action-ping-2 - name of template to store results
    #
    # command to send to device: ping [vrf Mgmt-vrf] 171.70.62.235 source GigabitEthernet0/0 repeat 100
    #################################################################################################
    def run_ping_action(self, mode , vrf, neighbor, ping_count, min_success, src_interface, pkt_size, fact_result):
        if self.control["actions"] == 1:
            try:
                if vrf == 'none':         
                    cmdline = 'ping ' + str(neighbor) + " source " + str(src_interface) + " size " + str(pkt_size) + " repeat " + str(ping_count)
                else:
                    cmdline = 'ping vrf ' + str(vrf) + ' ' + str(neighbor) + " source " + str(src_interface) + " size " + str(pkt_size) + " repeat " + str(ping_count)
                if self.control["debug-CLI"] == 1:
                    self.print_log("**** EMRE Debug: ssh run_ping_action: cmdline: " + str(cmdline))
    #
    # Use ssh to the device to perform the ping
    #
                if mode == 'ssh':
                    options = '-q -oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null -oPubkeyAuthentication=no'
                    ssh_cmd = 'ssh %s@%s %s "%s"' % (self.control["mgmt-device"][2], self.control["mgmt-device"][0], options, cmdline)
                    if self.control["debug-CLI"] == 1:
                        self.print_log("**** EMRE Debug: ssh run_ping_action SSH command: " + str(ssh_cmd) + "\n")
                    try:
                        child = pexpect.spawn(ssh_cmd, timeout= 20, encoding='utf-8')
                        child.delaybeforesend = None
                        if self.control["debug-CLI"] == 1:
                            child.logfile = sys.stdout
                        child.expect(['\r\nPassword: ', '\r\npassword: ', 'Password: ', 'password: '])
                        child.sendline(self.control["mgmt-device"][3])
                        child.expect(pexpect.EOF) #result contains the ping result
                        result = child.before
                    except Exception as e:
                        child.close()
                        self.print_log("%%%% EMRE ssh run_ping_action SSH or timeout Error: " + str(ssh_cmd) + "\n")
                        message = '(' + str(fact_result) + ' (neighbor ' + str(neighbor) + ') (percent 0) (result FALSE))'
                        if self.control["debug-CLI"] == 1:
                            self.print_log("**** EMRE Debug: Error ssh Assert run_ping_action SSH FACT: " + str(message))
                        try:
                            self.env.assert_string(message)
                        except: pass
                        return

                    child.close()
                    if self.control["debug-CLI"] == 1:
                        self.print_log("**** EMRE Debug: ssh command result \n" + str(result)) #successful ping
                    try:
                        regex = 'Success rate is.{1}(?P<percent>(\d+))'
                        p1 = re.compile(regex)

                        for line in result.splitlines():
                            line = line.strip()
                            try:
                                results = p1.match(line)
                                group = results.groupdict()
                                percent = group['percent']
                                if self.control["debug-CLI"] == 1:
                                    self.print_log("**** EMRE Debug: ssh run_ping_action: percent: " + str(percent))
                            except:  #skip lines that don't match the expected ping result
                                if self.control["debug-CLI"] == 1:
                                    self.print_log("**** EMRE Debug: ssh run_ping_action: skipline: " + str(line))

                                if result.find("% Invalid source interface") != -1:
                                    message = '(' + str(fact_result) + ' (neighbor ' + str(neighbor) + ') (percent 0) (result FALSE))'
                                    if self.control["debug-fact"] == 1:
                                        self.print_log("**** EMRE Debug: ssh Assert run_ping_action SSH FACT: " + str(message))
                                    try:
                                        self.env.assert_string(message)
                                    except: pass

                        if int(percent) >= int(min_success):
                            message = '(' + str(fact_result) + ' (neighbor ' + str(neighbor) + ') (percent ' + str(percent) + ') (result TRUE))'
                        else:
                            message = '(' + str(fact_result) + ' (neighbor ' + str(neighbor) + ') (percent ' + str(percent) + ') (result FALSE))'

                        if self.control["debug-fact"] == 1:
                            self.print_log("**** EMRE Debug: Assert ssh run_ping_action FACT: " + str(message))
                        try:
                            self.env.assert_string(message)
                        except: pass
           
                    except Exception as e:
                        self.print_log("\n%%%% EMRE ssh run_ping_action ssh command Error: " + str(e) + "\n")
                        message = '(' + str(fact_result) + ' (neighbor ' + str(neighbor) + ') (percent 0) (result FALSE))'
                        if self.control["debug-fact"] == 1:
                            self.print_log("**** EMRE Debug: ssh Error Assert run_ping_action SSH FACT: " + str(message))
                        try:
                            self.env.assert_string(message)
                        except: pass
#
# Use python cli package to perform ping
#
                elif mode == 'cli':
                    try:
                        if vrf == 'none':         
                            cmdline = 'ping ' + str(neighbor) + " source " + str(src_interface) + " size " + str(pkt_size) + " repeat " + str(ping_count)
                        else:
                             cmdline = 'ping vrf ' + str(vrf) + ' ' + str(neighbor) + " source " + str(src_interface) + " size " + str(pkt_size) + " repeat " + str(ping_count)
                        if self.control["debug-CLI"] == 1:
                            self.print_log("**** EMRE Debug: cli run_ping_action: cmdline: " + str(cmdline))
                        try:
                            regex = 'Success rate is.{1}(?P<percent>(\d+))'
                            p1 = re.compile(regex)

                            result = cli.cli(cmdline) # Run ping command to get ping results
                            for line in result.splitlines():
                                line = line.strip()
                                try:
                                    results = p1.match(line)
                                    group = results.groupdict()
                                    percent = group['percent']
                                    if self.control["debug-CLI"] == 1:
                                        self.print_log("**** EMRE Debug: cli run_ping_action: percent: " + str(percent))
                                except:  #skip lines that don't match the expected ping result
                                    if self.control["debug-CLI"] == 1:
                                        self.print_log("**** EMRE Debug: cli run_ping_action: skipline: " + str(line))

                                    if result.find("% Invalid source interface") != -1:
                                        message = message = '(' + str(fact_result) + ' (neighbor ' + str(neighbor) + ') (percent ' + str(0) + ') (result DOWN))'
                                        if self.control["debug-fact"] == 1:
                                            self.print_log("**** EMRE Debug: Assert run_ping_action FACT: " + str(message))
                                        self.env.assert_string(message)
                                        return
                                    else: continue

                            if int(percent) >= int(min_success):
                                message = '(' + str(fact_result) + ' (neighbor ' + str(neighbor) + ') (percent ' + str(percent) + ') (result TRUE))'
                            else:
                                message = '(' + str(fact_result) + ' (neighbor ' + str(neighbor) + ') (percent ' + str(percent) + ') (result FALSE))'

                            if self.control["debug-fact"] == 1:
                                self.print_log("**** EMRE Debug: cli Assert run_ping_action FACT: " + str(message))
                            self.env.assert_string(message) # Assert the ping action FACT
           
                        except Exception as e:
                            self.print_log("%%%% EMRE run_ping_action CLI command Error: " + str(e) + "\n")
                            message = '(' + str(fact_result) + ' (neighbor ' + str(neighbor) + ') (percent 0) (result FALSE))'
                            if self.control["debug-fact"] == 1:
                                self.print_log("**** EMRE Debug: cli Error Assert run_ping_action SSH FACT: " + str(message))
                            try:
                                self.env.assert_string(message)
                            except: pass
                            return

                    except Exception as e:
                        self.print_log("%%%% EMRE cli run_ping_action ssh command Error: " + str(e) + "\n")
                        message = '(' + str(fact_result) + ' (neighbor ' + str(neighbor) + ') (percent 0) (result FALSE))'
                        if self.control["debug-fact"] == 1:
                            self.print_log("**** EMRE Debug: cli Error Assert run_ping_action SSH FACT: " + str(message))
                        try:
                            self.env.assert_string(message)
                        except: pass
                        return
   #
   # else invalid mode 
   #
                else:
                    self.print_log("%%%% EMRE invalid run_ping_action ssh command Error: " + str(e) + "\n")
                    message = '(' + str(fact_result) + ' (neighbor ' + str(neighbor) + ') (percent 0) (result FALSE))'
                    if self.control["debug-fact"] == 1:
                        self.print_log("**** EMRE Debug: invalid Error Assert run_ping_action SSH FACT: " + str(message))
                    try:
                        self.env.assert_string(message)
                    except: pass

            except Exception as e:
                self.print_log("%%%% EMRE global run_ping_action ssh command Error: " + str(e) + "\n")
                message = '(' + str(fact_result) + ' (neighbor ' + str(neighbor) + ') (percent 0) (result FALSE))'
                if self.control["debug-fact"] == 1:
                    self.print_log("**** EMRE Debug: global Error Assert run_ping_action SSH FACT: " + str(message))
                try:
                    self.env.assert_string(message)
                except: pass
                return


    #################################################################################################
    #
    # run_trace - This action function called from CLIPs rules runs a ping command
    #       Rule Function Call Example: 
    #           (run_trace ?mode ?vrf ?trace-type ?neighbor ?src-interface ?timeout ?ttl ?all-addresses action-trace)
    #
    #       ?mode - cli/ssh select the method for running the traceroute using cli python package or device ssh
    #       ?vrf - vrf name or none(do not include a vrf in the ping command or provide the vrf name)
    #       ?trace-type - the type of trace to perform, default is ip
    #       ?neighbor - ip address of neighbor to ping
    #       ?src-interface - interface to run ping command through
    #       ?timeout - traceroute timeout
    #       ?ttl - maximum number of hops
    #       ?all-addresses - TRUE to return all addresses in path, FALSE to return last address
    #       action-trace - name of template to store results
    #
    # command to send to device: traceroute [vrf Mgmt-vrf] ip 172.24.115.25 source GigabitEthernet0/0 probe 1 timeout 1
    #
    # sample trace FACT: (action-trace (neighbor 10.1.7.2) (hop 8) (last-ip 10.1.7.2) (result TRUE))
    #################################################################################################
    def run_trace(self, mode, vrf, trace_type, neighbor, src_interface, probe, timeout, ttl, trace_timeout, all_addresses, system_time_raw, fact_result):
        if self.control["actions"] == 1:
            try:
                system_time = str(system_time_raw).replace(" ", "_")
                if vrf == 'none':         
                    cmdline = 'traceroute ' + str(trace_type) + " " + str(neighbor) + " source " + str(src_interface) + " probe " + str(probe) + " timeout " + str(timeout) + " ttl 1 " + str(ttl)
                else:
                    cmdline = 'traceroute vrf ' + str(trace_type) + " " + str(neighbor) + " source " + str(src_interface) + " probe " + str(probe) + " timeout " + str(timeout) + " ttl 1 " + str(ttl)
                if self.control["debug-CLI"] == 1:
                    self.print_log("**** EMRE Debug: run_trace: cmdline: " + str(cmdline))
    #
    # Use ssh to the device to perform the traceroute
    #
                if mode == 'ssh':
                    p1 = re.compile('(?P<hop>(\d+)).{1}(?P<address>(\S+)).*')
                    p2 = re.compile('(?P<nohop>(\d+)).{1}(?P<failed>(\S+)).*')
                    options = '-q -oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null -oPubkeyAuthentication=no'
                    ssh_cmd = 'ssh %s@%s %s "%s"' % (self.control["mgmt-device"][2], self.control["mgmt-device"][0], options, cmdline)
                    if self.control["debug-fact"] == 1:
                        self.print_log("**** EMRE Debug: run_trace SSH command: " + str(ssh_cmd) + "\n")
                    try:
                        child = pexpect.spawn(ssh_cmd, timeout= trace_timeout, encoding='utf-8')
                        child.delaybeforesend = None
                        if self.control["debug-CLI"] == 1:
                            child.logfile = sys.stdout
                        child.expect(['\r\nPassword: ', '\r\npassword: ', 'Password: ', 'password: '])
                        child.sendline(self.control["mgmt-device"][3])
                        child.expect(pexpect.EOF) #result contains the traceroute result
                        result = child.before
                    except Exception as e:
                        child.close()
                        self.print_log("%%%% EMRE run_trace ssh or timeout Error: " + str(ssh_cmd) + "\n")
                        message = '(' + str(fact_result) + ' (neighbor ' + str(neighbor) + ') (system-time ' + str(system_time) + ') (result FALSE))'
                        if self.control["debug-fact"] == 1:
                            self.print_log("**** EMRE Debug: Assert run_trace FACT: " + str(message))
                        try:
                            self.env.assert_string(message)
                        except: pass
                        return

                    child.close()
                    if self.control["debug-fact"] == 1:
                        self.print_log("**** EMRE Debug: ssh command result \n", result) #successful traceroute execution
    #
    # Use python cli package to perform the traceroute
    #
                elif mode == 'cli':
                    try:
                        p1 = re.compile('(?P<hop>(\d+)).{1}(?P<address>(\S+)).*')
                        p2 = re.compile('(?P<nohop>(\d+)).{1}(?P<failed>(\S+)).*')
                        result = cli.cli(cmdline) # Run trace command
                    except Exception as e:
                        child.close()
                        self.print_log("%%%% EMRE run_trace cli Error: " + str(cmdline) + "\n" + str(e))
                        message = '(' + str(fact_result) + ' (neighbor ' + str(neighbor) + ') (system-time ' + str(system_time) + ') (result FALSE))'
                        if self.control["debug-fact"] == 1:
                            self.print_log("**** EMRE Debug: Assert run_trace FACT: " + str(message))
                        try:
                            self.env.assert_string(message)
                        except: pass
                        return
    #
    # If invalid traceroute mode is selected
    #
                else:
                    self.print_log("%%%% EMRE run_trace Error: Invalid mode" + str(mode))
                    message = '(' + str(fact_result) + ' (neighbor ' + str(neighbor) + ') (system-time ' + str(system_time) + ') (result DOWN))'
                    if self.control["debug-fact"] == 1:
                        self.print_log("**** EMRE Debug: run_trace Error: Invalid mode: " + str(message))
                    try:
                        self.env.assert_string(message)
                    except: return

    #############################################################
    #
    #  The traceroute reply is now in the "result" string variable
    #  Select information and build the result FACT
    #
    #############################################################
                ipaddress = 'none'
                hop = 'none'
                domain = 'none'
                last_address = 'none'

                if self.control["debug-CLI"] == 1:
                    self.print_log("**** EMRE Debug: run_trace: result: " + str(result))
                for line in result.splitlines():
                    line = line.strip()
                    try:
                        results = p1.match(line)
                        group = results.groupdict()
                        hop = group['hop']
                        ipaddress = group['address'].strip().lstrip('(').rstrip(')')
                        if str(ipaddress) != '*':
                            last_address = ipaddress        
                        if self.control["debug-CLI"] == 1:
                            self.print_log("**** EMRE Debug: run_trace: hop address: " + str(hop) + " "+ str(ipaddress))

                    except Exception as ex: #skip lines that don't match the expected trace result
                        if self.control["debug-CLI"] == 1:
                            self.print_log("**** EMRE Debug: run_trace: skipline: " + str(line))
                        continue
    #
    # After parsing the response for the tracerout results, check to see if the interface was down
    #
                if result.find("% Invalid source interface") != -1:
                    message = '(' + str(fact_result) + ' (neighbor ' + str(neighbor) + ') (system-time ' + str(system_time) + ') (result DOWN))'
                    if self.control["debug-fact"] == 1:
                        self.print_log("**** EMRE Debug: Assert run_trace Interface Down: " + str(message))
                    try:
                        self.env.assert_string(message)
                    except: return

                else: 

    ###########################################################################
    #
    # Test to see if neighbor is found as the last element in the trace list
    #
    ###########################################################################
                    failed = 'none'
                    nohop = 'none'
                    try:
                        last_result = p2.match(line)
                        group = results.groupdict()
                        failed = group['failed']
                        nohop = group['nohop']
                    except: pass
    #
    # test for timeout as the last hop reported which indicates trace failed to complete
    #
                    if str(failed) == '*':
                        message = '(' + str(fact_result) + ' (neighbor ' + str(neighbor) + ') (hop ' + str(nohop) + ') (last-ip ' + str(last_address) + ') (system-time ' + str(system_time) +') (result FALSE))'
                    else:
                        message = '(' + str(fact_result) + ' (neighbor ' + str(neighbor) + ') (hop ' + str(hop) + ') (last-ip ' + str(last_address) + ') (system-time ' + str(system_time) +') (result TRUE))'
                    try:
                        if self.control["debug-fact"] == 1:
                            self.print_log("**** EMRE Debug: Assert run_trace Error: " + str(e))
                        self.env.assert_string(message)
                    except: return

            except Exception as e:
                self.print_log("%%%% EMRE run_trace command Error: " + str(e) + "\n")
                message = '(' + str(fact_result) + ' (neighbor ' + str(neighbor) + ') (result FALSE))'
                if self.control["debug-fact"] == 1:
                    self.print_log("**** EMRE Debug: Assert run_trace Error: " + str(e))
                try:
                    self.env.assert_string(message)
                except: return

        if self.control["debug-fact"] == 1:
            self.print_log("**** EMRE Debug: Assert run_trace FACT: " + str(message))
        try:
            self.env.assert_string(message) # Assert the action FACT
        except: return

    #################################################################################################
    #
    # run_trace_hops - This action function called from CLIPs rules runs a ping command
    #       Rule Function Call Example: 
    #           (run_trace ?mode ?vrf ?trace-type ?neighbor ?src-interface ?timeout ?ttl ?all-addresses action-trace)
    #
    #       ?mode - cli/ssh select the method for running the traceroute using cli python package or device ssh
    #       ?vrf - vrf name or none(do not include a vrf in the ping command or provide the vrf name)
    #       ?trace-type - the type of trace to perform, default is ip
    #       ?neighbor - ip address of neighbor to ping
    #       ?src-interface - interface to run ping command through
    #       ?timeout - traceroute timeout
    #       ?ttl - maximum number of hops
    #       ?all-addresses - TRUE to return all addresses in path, FALSE to return last address
    #       action-trace - name of template to store results
    #
    # command to send to device: traceroute [vrf Mgmt-vrf] ip 172.24.115.25 source GigabitEthernet0/0 probe 1 timeout 1
    #
    # sample trace FACT: (action-trace (neighbor 10.1.7.2) (hop 8) (last-ip 10.1.7.2) (result TRUE))
    #################################################################################################
    def run_trace_hops(self, mode, vrf, trace_type, neighbor, src_interface, probe, timeout, ttl, trace_timeout, all_addresses, system_time_raw, fact_result):
        try:
            message = '(trace-hops (neighbor ' + str(neighbor) + ') (hop ' + str(1) + ') (last-ip 192.168.1.24) (system-time ' + str(system_time_raw) +') (result TRUE))'
            if self.control["debug-fact"] == 1:
                self.print_log("**** EMRE Debug: Assert run_trace_hops last good hop: " + str(message))
            try:
                self.env.assert_string(message)
            except Exception as e:
                self.print_log("**** Assert run_trace_hops error: " + str(e) + str(message))

        except Exception as e:
            self.print_log("**** Assert run_trace_hops error: " + str(e))
    #################################################################################################
    #
    # run_process_file - Rule function that parses the content of "filename" stored in /bootflash/guest-share
    #                    using the file_fact_list entry identified by file_fact_index to assert
    #                    FACTs from the file content
    #
    #################################################################################################
    def run_process_file(self, file_fact_index, filename):
        if self.control["actions"] == 1:
            command_idx = int(file_fact_index)
            timestamp =  datetime.now().strftime("%m-%d-%Y_%H:%M:%S.%f")
            
        # Read the contents fo the file
        #
            try:
                with open(filename, "r") as fd:
                    file_data = fd.read()
                    fd.close()
                    if self.control["debug-file"] == 1:
                        self.print_log("\n**** EMRE Debug: run_process_file content: \n" + str(file_data))
            except Exception as e:
                self.print_log("%%%% EMRE: Error reading run_process_file: " + str(e) + "\n" + str(filename))

    #
    # process file content and generate FACTs
    #
            try:
                fact = self.control["file-fact-list"][command_idx]
                parser = genie_str_to_class(fact["genie_parser"])
                parsed_genie_output = parser.parse(output=file_data)
                if self.control["debug-action"] == 1:
                    self.print_log("\n*** EMRE Debug: run_process_file parsed output:\n" + str(parsed_genie_output))

                sub_dictionary_list = self.find(fact["assert_fact_for_each_item_in"], parsed_genie_output)
                import copy
                for sub_dictionary in sub_dictionary_list:
                    for item in sub_dictionary:
                        protofact = copy.deepcopy(fact["protofact"])
                        for slot in protofact["slots"]:
                            value = protofact["slots"][slot]
	#
	# insert the device name into the fact
	#
                            if value == "device":
                                protofact["slots"][slot] = value.replace("device", fact["device"])
                            elif type(value) == str and "$" in value:
                                protofact["slots"][slot] = value.replace("$", item)
                        self.assert_template_fact(protofact, 'device', fact["device"], sub_dictionary)
            except Exception as e:
                self.print_log("%%%% EMRE Error: Exception in run_process_file assert_fact response processing: " + str(fact) + " " + str(e))

    #################################################################################################
    #
    # run_delay - Rule function that delays execution of rules for specified number of seconds
    #             When this function is called the action function will sleep and then return
    #
    #################################################################################################
    def run_delay(self, seconds):
        if self.control["actions"] == 1:
            if self.control["debug-action"] == 1:
                timestamp =  datetime.now().strftime("%m-%d-%Y_%H:%M:%S.%f")
                
                self.print_log("\n**** EMRE Debug: run_delay seconds: " + str(seconds) + " starting at: " + str(timestamp))
                   
            time.sleep(float(seconds))

    #################################################################################################
    #
    # get_action_functions - return a list of all action functions defined for eMRE
    #
    #################################################################################################
    def get_action_functions(self):
        action_functions = [self.run_assert_message, self.run_cli_command, self.run_ssh_cli_command, self.run_apply_config, self.run_write_to_syslog, self.run_action,  self.run_ping_action, self.run_emre, self.run_rule_timer, self.run_command, self.run_clear_selected_facts, self.run_nc_fact, self.run_show_fact, self.run_trace, self.run_trace_hops, self.run_get_facts, self.run_process_file, self.run_copy_file, self.run_delay, self.run_show_parameter, self.run_cli_parameter]
        return action_functions
