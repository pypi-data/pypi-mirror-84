#!/usr/bin/env python
"""
classes for handling XAFS data in plaintext column files for various beamlines.


Basically, a class for XAFS Beamline data. This defines
  a) how to name the arrays for columns in the data file
  b) which column is most likely to hold the energy (or energy-definig) array
  c) what the energy units are most likely to be.

Specific beamline data should define a class that derives from GenericBeamlineData
and has the following attributes/methods:


  energy_column : int index for default energy column

  energy_units : str ('eV', 'keV', 'deg') for default expected energy units

  beamline_matches(): method to decide whether data may be from the beamline
     should give more false positives than false negatives.

  get_array_labels(): method to guess array labels.

The XXX__BeamlineData class will be given *only* the headerlines (a list of lines)
from the text file.

By default, that header will defined all the text before the data table.

"""

import numpy as np
from larch.io import fix_varname, read_ascii


def guess_beamline(header=None):
    """
    guess beamline data class used to parse headers from header lines
    """
    if header is not None and len(header) > 1:
        line1 = header[0].lower()
        full = '\n'.join(header).lower()

        if line1.startswith('#'):
            line1 = line1.replace('#', '')

        if 'xdi/1' in line1 and 'epics stepscan' in line1:
            return APSGSE_BeamlineData
        elif line1.startswith('; epics scan 1 dim'):
            return APSGSE_BeamlineData
        elif 'labview control panel' in line1:
            return APSXSD_BeamlineData
        elif 'mrcat_xafs' in line1:
            return APSMRCAT_BeamlineData
        elif line1.startswith('xdac'):
            return NSLSXDAC_BeamlineData
        elif 'ssrl' in line1 and 'exafs data collector' in line1:
            return SSRL_BeamlineData
        elif 'cls data acquisition' in line1:
            return CLSHXMA_BeamlineData
        elif 'kek-pf' in line1:
            return KEKPF_BeamlineData
        elif 'exafsscan' in full and 'exafs_region' in full:
            return APS12BM_BeamlineData
    return GenericBeamlineData


class GenericBeamlineData:
    """
    Generic beamline data file - use as last resort

    This parses the last header line for labels:
    First, it remove any leading '#', '#C', '#L', and 'C' as if
    collected by Spec or many other collection systems.

    Next, it removes bad characters ',#@%&' and quotes.
    Then, it splits on whitespace and fixes names to make
    sure they are valid variable names
    """
    energy_column = 1
    energy_units = 'eV'
    dspace = -1
    name = 'generic'

    def __init__(self, headerlines=None):
        if headerlines is None:
            headerlines = []
        self.headerlines = list(headerlines)

    def beamline_matches(self):
        return len(self.headerlines) > 1

    def get_array_labels(self, ncolumns=None):
        if len(self.headerlines) < 2:
            return None

        lastline = self.headerlines[-1].strip()
        for cchars in ('#L', '#C', '#', 'C'):
            if lastline.startswith(cchars):
                lastline = lastline[len(cchars):]
        for badchar in ',#@%&"\'':
            lastline = lastline.replace(badchar, ' ')
        return self._set_labels(lastline.split(), ncolumns=ncolumns)

    def _set_labels(self, labels, ncolumns=None):
        """
        final parsing, cleaning, ensuring number of columns is satisfied
        """
        labels = [fix_varname(word.strip().lower()) for word in labels]
        for i, lab in enumerate(labels):
            if lab in labels[:i]:
                labels[i] = lab + '_col%d' % i

        if ncolumns is not None and len(labels) < ncolumns:
            for i in range(len(labels), ncolumns):
                labels.append('col%d' % (i+1))
        self.labels = labels
        return labels


class APSGSE_BeamlineData(GenericBeamlineData):
    """
    GSECARS EpicsScan data, APS 13ID, some NSLS-II XFM 4BM data
    """
    name = 'GSE EpicsScan'
    energy_column = 1

    def __init__(self, headerlines=None):
        GenericBeamlineData.__init__(self, headerlines=headerlines)

    def beamline_matches(self):
        line1  = ''
        if len(self.headerlines) > 0:
            line1 = self.headerlines[0].lower()
        return (('xdi/1' in line1 and 'epics stepscan' in line1) or
                line1.startswith('; epics scan 1 dim'))


    def get_array_labels(self, ncolumns=None):
        if not self.beamline_matches():
            raise ValueError('header is not from beamline %s' % self.name)

        line1 = self.headerlines[0].lower()
        oldstyle = line1.startswith('; epics scan 1 dim')

        labels = []
        if oldstyle:
            mode = 'search'
            for line in self.headerlines:
                line = line[1:].strip()
                if mode == 'found legend':
                    if len(line) < 2 or '-->' not in line:
                        mode = 'legend done'
                    else:
                        pref, suff = line.split('-->', 1)
                        pid, arg = pref.split('=')
                        arg = arg.replace('{', '').replace('}','')
                        labels.append(arg.strip())
                elif mode == 'search' and 'column labels:' in line:
                    mode = 'found legend'


        else:
            for line in self.headerlines:
                if line.startswith('#'):
                    line = line[1:].strip()
                else:
                    break
                if line.lower().startswith('column.') and '||' in line:
                    label, pvname = line.split('||', 1)
                    label, entry = label.split(':')
                    entry = entry.strip()
                    if ' ' in entry:
                        entry, units = entry.split(' ')
                        if 'energy' in entry.lower() and len(units) > 1:
                            self.energy_units = units
                    labels.append(entry)
        return self._set_labels(labels, ncolumns=ncolumns)


class APS12BM_BeamlineData(GenericBeamlineData):
    """
    APS sector 12BM data
    """
    name = 'APS 12BM'
    energy_column = 1

    def __init__(self, headerlines=None):
        GenericBeamlineData.__init__(self, headerlines=headerlines)

    def beamline_matches(self):
        """ must see 'exafs_region' """
        match = False
        if len(self.headerlines) > 0:
            for line in self.headerlines:
                if not line.startswith('#'):
                    match = False
                    break
                if 'exafs_region' in line:
                    match = True
        return match

    def get_array_labels(self, ncolumns=None):
        if not self.beamline_matches():
            raise ValueError('header is not from beamline %s' % self.name)

        labelline = self.headerlines[-1].replace('#C', ' ').strip()
        words = labelline.split()

        labels = []
        for word in words:
            if '_' in word:
                pref, suff = word.split('_')
                isint = False
                try:
                    ipref = int(pref)
                    isint = True
                except ValueError:
                    pass
                if isint: labels.append(suff)
            elif len(labels) == 1:
                word = word.replace('(', '').replace(')', '')
                self.energy_units = word
        return self._set_labels(labels, ncolumns=ncolumns)


class APSMRCAT_BeamlineData(GenericBeamlineData):
    """
    APS sector 10ID or 10BM data
    """
    name = 'APS MRCAT'
    energy_column = 1

    def __init__(self, headerlines=None):
        GenericBeamlineData.__init__(self, headerlines=headerlines)

    def beamline_matches(self):
        line1  = ''
        if len(self.headerlines) > 0:
            line1 = self.headerlines[0]
        return ('MRCAT_XAFS' in line1)

    def get_array_labels(self, ncolumns=None):
        if not self.beamline_matches():
            raise ValueError('header is not from beamline %s' % self.name)

        labels = []
        mode = 'search'
        for line in self.headerlines:
            if mode == 'found':
                labels = line.strip().split()
                break
            if mode == 'search' and '-------' in line:
                mode = 'found'

        return self._set_labels(labels, ncolumns=ncolumns)


class APSXSD_BeamlineData(GenericBeamlineData):
    """
    APS sector 20ID, 20BM, 9BM
    """
    name = 'APS XSD'
    energy_column = 1

    def __init__(self, headerlines=None):
        GenericBeamlineData.__init__(self, headerlines=headerlines)

    def beamline_matches(self):
        line1  = ''
        if len(self.headerlines) > 0:
            line1 = self.headerlines[0]
        return ('LabVIEW Control Panel' in line1)

    def get_array_labels(self, ncolumns=None):
        if not self.beamline_matches():
            raise ValueError('header is not from beamline %s' % self.name)

        # here we try two different ways for "older" and "newer" 20BM/9BM fles
        labels = []
        mode = 'search'
        for line in self.headerlines:
            line = line[1:].strip()
            if mode == 'found legend':
                if len(line) < 2:
                    mode = 'legend done'
                else:
                    if ')' in line:
                        pref, suff = line.replace('*', '').split(')', 1)
                        labels.append(suff)
            elif mode == 'search' and 'is a readable list of column' in line:
                mode = 'found legend'

        # older version: no explicit legend, parse last header line, uses '*'
        if len(labels) == 0:
            labelline = self.headerlines[-1].replace('#', '')
            words = labelline.split('*')
            if len(words) > 1:
                lastword = words.pop()
                words.extend(lastword.split())
            labels = words

        return self._set_labels(labels, ncolumns=ncolumns)


class NSLSXDAC_BeamlineData(GenericBeamlineData):
    """
    NSLS (I) XDAC collected data
    """
    name = 'NSLS XDAC'
    energy_column = 1

    def __init__(self, headerlines=None):
        GenericBeamlineData.__init__(self, headerlines=headerlines)

    def beamline_matches(self):
        line1  = ''
        if len(self.headerlines) > 0:
            line1 = self.headerlines[0].replace('#', '').strip()
        return line1.startswith('XDAC')

    def get_array_labels(self, ncolumns=None):
        if not self.beamline_matches():
            raise ValueError('header is not from beamline %s' % self.name)

        labels = []
        mode = 'search'
        for line in self.headerlines:
            if mode == 'found':
                labels = line.strip().split()
                break
            if mode == 'search' and '-------' in line:
                mode = 'found'

        return self._set_labels(labels, ncolumns=ncolumns)


class SSRL_BeamlineData(GenericBeamlineData):
    """
    SSRL EXAFS Data Collect beamline data
    """
    name = 'SSRL'
    energy_column = 1

    def __init__(self, headerlines=None):
        GenericBeamlineData.__init__(self, headerlines=headerlines)

    def beamline_matches(self):
        line1  = ''
        if len(self.headerlines) > 0:
            line1 = self.headerlines[0]
        return ('ssrl' in line1.lower() and 'exafs data collector' in line1.lower())

    def get_array_labels(self, ncolumns=None):
        if not self.beamline_matches():
            raise ValueError('header is not from beamline %s' % self.name)

        labels = []
        mode = 'search'
        for line in self.headerlines:
            line = line.strip()
            if mode == 'found legend':
                if len(line) < 2:
                    mode = 'legend done'
                    break
                else:
                    labels.append(line)
                    if 'energy' in line.lower():
                        self.energy_column = len(labels)
            elif mode == 'search' and line == 'Data:':
                mode = 'found legend'

        return self._set_labels(labels, ncolumns=ncolumns)


class CLSHXMA_BeamlineData(GenericBeamlineData):
    """
    CLS HXMA beamline data
    """
    name = 'CLS HXMA'
    energy_column = 1

    def __init__(self, headerlines=None):
        GenericBeamlineData.__init__(self, headerlines=headerlines)

    def beamline_matches(self):
        line1  = ''
        if len(self.headerlines) > 0:
            line1 = self.headerlines[0]
        return ('cls data acquisition' in line1.lower())

    def get_array_labels(self, ncolumns=None):
        if not self.beamline_matches():
            raise ValueError('header is not from beamline %s' % self.name)

        labels = []
        for line in self.headerlines:
            line = line.strip()
            if line.startswith('#(1)')  and '$(' in line:
                line = line.replace('#(1)', '')
                for bchar in '"#$()\t':
                    line = line.replace(bchar, ' ')
                labels = line.split()

        labels = [fix_varname(word.strip().lower()) for word in labels]
        for i, label in enumerate(labels):
            if 'energy' in label:
                self.energy_column = i+1
        return self._set_labels(labels, ncolumns=ncolumns)


class KEKPF_BeamlineData(GenericBeamlineData):
    """
    KEK-PF (Photon Factory Data), as from BL12C
    """
    name = 'KEK PF'
    energy_column = 2
    energy_units = 'deg'

    def __init__(self, headerlines=None):
        GenericBeamlineData.__init__(self, headerlines=headerlines)

    def beamline_matches(self):
        line1  = ''
        if len(self.headerlines) > 0:
            line1 = self.headerlines[0].replace('#', '').strip()
        return 'KEK-PF' in line1

    def get_array_labels(self, ncolumns=None):
        if not self.beamline_matches():
            raise ValueError('header is not from beamline %s' % self.name)

        labels = []
        dspace = 0

        for line in self.headerlines:
            line = line.lower().replace('#', ' ').strip()
            if 'mono :' in line:
                words = ['_'] + line.replace('=', ' ').split()
                for i, w in enumerate(words):
                    if i == 0: continue
                    if words[i-1] == 'd':
                        try:
                            self.dspace = float(w)
                        except ValueError:
                            pass
        lastline = self.headerlines[-1]
        ncols = len(lastline.strip().split())
        if ncolumns is not None:
            ncols = max(ncols, ncolumns)

        labels= ['angle_drive', 'angle_read', 'time']
        return self._set_labels(labels, ncolumns=ncols)



def _tester(fname):
    group = read_ascii(fname)
    cls = guess_beamline(group.header)
    bldat = cls(group.header)
    labels = bldat.get_array_labels()
    print(fname, cls.__name__, len(labels), group.data.shape, labels)
    return bldat, labels

def test_apsxsd_new(fname):
    bldat, labels = _tester(fname) # , APSXSD_BeamlineData)
    assert('aps xsd' in bldat.name.lower())
    assert(1 == bldat.energy_column)
    assert('eV' == bldat.energy_units)
    assert(labels[0]  == 'mono_energy')
    assert(labels[1].startswith('scaler_pre'))
    assert(labels[4].startswith('i0'))


def test_apsxsd_old(fname):
    bldat, labels = _tester(fname) # , APSXSD_BeamlineData)
    assert('aps xsd' in bldat.name.lower())
    assert(1 == bldat.energy_column)
    assert('eV' == bldat.energy_units)
    assert(labels[0]  == 'mono_energy')
    assert(labels[1].startswith('scaler_pre'))
    assert(labels[2] == 'i0')


def test_apsmrcat(fname):
    bldat, labels = _tester(fname) #, APSMRCAT_BeamlineData)
    assert('aps mrcat' in bldat.name.lower())
    assert(1 == bldat.energy_column)
    assert('eV' == bldat.energy_units)
    assert(len(labels) == 5)
    assert(labels[0]  == 'energy')
    assert(labels[1]  == 'io')
    assert(labels[2]  == 'it')
    assert(labels[3]  == 'iref')


def test_apsgse(fname):
    bldat, labels = _tester(fname) # , APSGSE_BeamlineData)
    assert('gse epicsscan' in bldat.name.lower())
    assert(1 == bldat.energy_column)
    assert('eV' == bldat.energy_units)
    assert(len(labels) == 21)
    assert(labels[0]  == 'energy')
    assert(labels[1]  == 'tscaler')
    assert(labels[2]  == 'i0')
    assert(labels[3]  == 'i1')
    assert(labels[4]  == 'i2')
    assert(labels[5]  == 'mn_ka_mca1')

def test_apsgse_old(fname):
    bldat, labels = _tester(fname) # , APSGSE_BeamlineData)
    assert('gse epicsscan' in bldat.name.lower())
    assert(1 == bldat.energy_column)
    assert('eV' == bldat.energy_units)
    assert(len(labels) == 4)
    assert(labels[0]  == 'energy')
    assert(labels[1]  == 'scaler_count_time')
    assert(labels[2]  == 'i0')
    assert(labels[3]  == 'i1')


def test_aps12bm(fname):
    bldat, labels = _tester(fname) # , APS12BM_BeamlineData)
    assert('12bm' in bldat.name.lower())
    assert(1 == bldat.energy_column)
    assert('keV' == bldat.energy_units)
    assert(len(labels) == 26)
    assert(labels[0]  == 'energy')
    assert(labels[1]  == 'sec')
    assert(labels[2]  == 'mononrg')
    assert(labels[3]  == 'i0')
    assert(labels[4]  == 'i1')
    assert(labels[5]  == 'i2')

def test_aps9bm2006(fname):
    bldat, labels = _tester(fname)  #, GenericBeamlineData)
    assert(1 == bldat.energy_column)
    assert('eV' == bldat.energy_units)
    assert(len(labels) > 5)
    assert(labels[0]  == 'energy')
    assert('i0' in labels)

def test_esrfsnbl(fname):
    bldat, labels = _tester(fname) # , GenericBeamlineData)
    assert(1 == bldat.energy_column)
    assert('eV' == bldat.energy_units)
    assert(len(labels) > 5)
    assert(labels[0]  == 'mon')
    assert(labels[1]  == 'det1')
    assert(labels[2]  == 'det2')

def test_nsls2_8id(fname):
    bldat, labels = _tester(fname) # , GenericBeamlineData)
    assert(1 == bldat.energy_column)
    assert('eV' == bldat.energy_units)
    assert(len(labels) > 5)
    assert(labels[0]  == 'energy')
    assert(labels[1]  == 'i0')
    assert(labels[2]  == 'ir')
    assert(labels[3]  == 'it')
    assert(labels[4]  == 'iff')

def test_ssrl1(fname):
    bldat, labels = _tester(fname) # , SSRL_BeamlineData)
    assert(3 == bldat.energy_column)
    assert('eV' == bldat.energy_units)
    assert(len(labels) == 6)
    assert(labels[0]  == 'real_time_clock')
    assert(labels[1]  == 'requested_energy')
    assert(labels[2]  == 'achieved_energy')
    assert(labels[3]  == 'i0')
    assert(labels[4]  == 'i1')
    assert(labels[5]  == 'i2')

def test_ssrl2(fname):
    bldat, labels = _tester(fname) # , SSRL_BeamlineData)
    assert(2 == bldat.energy_column)
    assert('eV' == bldat.energy_units)
    assert(len(labels) > 65)
    assert(labels[0]  == 'real_time_clock')
    assert(labels[1]  == 'requested_energy')
    assert(labels[2]  == 'i0')
    assert(labels[3]  == 'i1')
    assert(labels[4]  == 'i2')
    assert(labels[5]  == 'sca1_1')

def test_nslsxdac(fname):
    bldat, labels = _tester(fname) # , NSLSXDAC_BeamlineData)
    assert(1 == bldat.energy_column)
    assert('eV' == bldat.energy_units)
    assert(len(labels) > 15)
    assert(labels[0]  == 'energy')
    assert(labels[1]  == 'i0')
    assert(labels[2]  == 'it')
    assert(labels[3]  == 'ifch1')
    assert(labels[4]  == 'ifch2')

def test_clshxma(fname):
    bldat, labels = _tester(fname) # , CLSHXMA_BeamlineData)
    assert(4 == bldat.energy_column)
    assert('eV' == bldat.energy_units)
    assert(len(labels) > 10)
    assert(labels[0]  == 'event_id')
    assert(labels[1]  == 'absenergyname')
    assert(labels[2]  == 'energyfeedback')
    assert(labels[3]  == 'energyachieved')
    assert(labels[4]  == 'detector1')

def test_kekpf12c(fname):
    bldat, labels = _tester(fname) # , CLSHXMA_BeamlineData)
    assert(2 == bldat.energy_column)
    assert('deg' == bldat.energy_units)
    assert(bldat.dspace > 3)
    assert(len(labels) == 5)

if __name__ == '__main__':
    test_apsxsd_new('APS9BM_2019.dat')
    test_apsxsd_old('APS20BM_2001.dat')
    test_apsgse('APS13ID_2019.dat')
    test_apsgse_old('APS13ID_2008.dat')
    test_apsmrcat('APS10BM_2019.dat')
    test_aps12bm('APS12BM_2019.dat')
    test_aps9bm2006('APS9BM_2006.dat')
    test_esrfsnbl('ESRF_SNBL_2013.dat')
    test_nsls2_8id('NSLS8ID_2019.dat')
    test_ssrl1('SSRL1_2006.dat')
    test_ssrl2('SSRLmicro_2008.dat')
    test_nslsxdac('NSLS_XDAC_2011.dat')
    test_clshxma('CLSHXMA.dat')
    test_kekpf12c('PFBL12C_2005.dat')
