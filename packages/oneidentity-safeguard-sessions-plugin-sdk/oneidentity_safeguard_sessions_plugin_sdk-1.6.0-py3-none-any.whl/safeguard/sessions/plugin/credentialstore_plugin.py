#
# Copyright (c) 2006-2020 Balabit
# All Rights Reserved.
#
"""
.. py:module:: safeguard.sessions.plugin.credentialstore_plugin
    :synopsis: Credential store plugin base class

CredentialStorePlugin way of working
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When SPS calls the CredentialStorePlugin, it does so by creating a CredentialStorePlugin (or more likely derived class)
instance. The initialization of the instance processes the given plugin configuration and sets the logging level
appropriately.

On the new plugin instance SPS will make a call to ``get_password_list`` and/or ``get_private_key_list`` to fetch
passwords and ssh private keys to be used against the target server of the user session. If the authentication on the
server is successful, then SPS will once again instantiate the plugin and call ``authentication_completed``. Note that
this step is not called if the authentication fails. When the session is closed, SPS will call the ``session_ended``
method of yet another instance of the plugin.

In all cases CredentialStorePlugin implements the methods above and  first collects the input parameters in
:class:`self.connection <safeguard.sessions.plugin.connection_info.ConnectionInfo>` and sets up
:py:attr:`self.cookie <CredentialStorePlugin.cookie>`.

When self is set up, CredentialStorePlugin calls the user defined implementation in
:meth:`do_get_password_list() <CredentialStorePlugin.do_get_password_list>`,
:meth:`do_get_private_key_list() <CredentialStorePlugin.do_get_private_key_list>` for all account, asset pairs
generated by :meth:`_generate_accounts() <CredentialStorePlugin._generate_accounts>`,
:meth:`_generate_assets() <CredentialStorePlugin._generate_assets>` methods until either a credential is found or
there are no more accounts to check. The :py:attr:`self.account <CredentialStorePlugin.account>` and
:py:attr:`self.asset <CredentialStorePlugin.asset>` attributes are set to the account, asset to be checked out and
are also put into the cookie so they are available in the later plugin invocations.

The :meth:`do_authentication_completed() <CredentialStorePlugin.do_authentication_completed>` and
:meth:`do_session_ended() <CredentialStorePlugin.do_session_ended>` may be implemented to implement different
methods regarding successful authentication on the target server and at the end of the session.

To ensure that credentials are checked in even in the case of failed target server authentication, the
:meth:`do_check_in_credential() <CredentialStorePlugin.do_check_in_credential>` method should be implemented which is
called in these cases:

* ``authentication_completed`` when authentication on the target server was successful,
* ``get_password_list`` when a private key was checked out previously, but was not successfully used on the target
  server,
* ``session_ended`` when authentication on the target server failed.


CredentialStorePlugin methods and attributes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

"""
from .connection_info import ConnectionInfo
from .exceptions import PluginSDKRuntimeError
from .plugin_base import cookie_property, lazy_property, PluginBase


class InvalidUsageException(PluginSDKRuntimeError):
    def __init__(self, variables=None):
        super().__init__(("Connection information is not initialized. "
                          "Please use in do_get_password_list or do_get_private_key_list methods"), variables)


class CredentialStorePlugin(PluginBase):
    """
    The :class:`CredentialStorePlugin` class implements the common functionality of credential store plugins.
    The following methods and attributes are available outside the constructor - on top of the ones inherited from
    :class:`PluginBase <safeguard.sessions.plugin.plugin_base.PluginBase` class:

    *New in version 1.6.0.*

    .. py:attribute:: authentication_username

        The :py:attr:`self.authentication_username <authentication_username>` attribute is the calculated username to use
        for authenticate to credential store.
        It can be username from the plugin configuration or the gateway username from the
        :py:attr:`self.connection <safeguard.sessions.plugin.connection_info.ConnectionInfo>`

    .. py:attribute:: authentication_password

        The :py:attr:`self.authentication_password <authentication_password>` attribute is the calculated password to use
        for authenticate to credential store.
        It can be password from the plugin configuration or the gateway password from the
        :py:attr:`self.connection <safeguard.sessions.plugin.connection_info.ConnectionInfo>`

    Both attributes can be used after the :py:attr:`self.connection <safeguard.sessions.plugin.connection_info.ConnectionInfo>` is initialized
    Usually in the the :meth:`self.do_get_password_list <do_get_password_list>` and :meth:`self.do_get_private_key_list <do_get_private_key_list>`

    *New in version 1.2.0.*

    .. py:attribute:: connection

        The :py:attr:`self.connection <safeguard.sessions.plugin.connection_info.ConnectionInfo>` provides a read-only
        view of the parameters passed to the currently executing plugin hook, e.g. :meth:`do_get_password_list`.

    .. py:attribute:: cookie

    The :py:attr:`self.cookie <cookie>` attribute is a dict that retains its contents between invocations of
    :meth:`do_get_password_list`, :meth:`do_get_private_key_list`, :meth:`do_authentication_completed`,
    :meth:`do_check_in_credential` and :meth:`do_session_ended`. This is the way to pass data between these functions.

    When the plugin returns the contents are automatically returned to SPS.

    .. py:attribute:: session_cookie

    The :py:attr:`self.session_cookie <session_cookie>` is similar to :py:attr:`self.cookie <cookie>`, but it is
    also visible in other plugins in the same session. When the plugin returns the contents are automatically
    returned to SPS.

    .. py:attribute:: account

    The :py:attr:`self.account <account>` attribute contains the account identifier that should be checked out.
    This value is also kept in the cookie. The list of candidates is generated by the :meth:`_generate_accounts`
    method.

    .. py:attribute:: asset

    The :py:attr:`self.asset <asset>` attribute contains the asset identifier that should be checked out.
    This value is also kept in the cookie. The list of candidates is generated by the :meth:`_generate_assets`
    method.
    """

    def __init__(self, configuration, defaults=None, logger=None, configuration_section=None):
        """
         *New in version 1.6.0.*

        .. py:param:: configuration_section

        The :py:param:`configuration_section` represents the name of the configuration section related to the
        credential store. This parameter is required when someone wants to use the
        :py:attr:`self.authentication_username <authentication_username> and the
        :py:attr:`self.authentication_password <authentication_password>` attributes
        """
        super().__init__(configuration, defaults, logger)
        self._configuration_section = configuration_section

    CHECK_IN_TRIGGER_SECTION = "check-in-trigger"
    CHECK_IN_TRIGGER_SESSION_ENDED = "session-ended"
    CHECK_IN_TRIGGER_AUTHENTICATION_COMPLETED = "authentication-completed"

    def do_get_password_list(self):
        """
        The :meth:`do_get_password_list` method should implement fetching passwords for the given
        :meth:`account <CredentialStorePlugin.account>` name and possible :meth:`assets <CredentialStorePlugin.assets>`
        names.

        :return: a dict containing a list of passwords: {'passwords': ['secret', 'topsecret']} or empty list [] if \
        no password could be fetched.
        """
        raise NotImplementedError("do_get_password_list")

    def do_get_private_key_list(self):
        """
        The :meth:`do_get_private_key_list` method should be implemented like :meth:`do_get_password_list`, but return
        ssh private keys instead.
        :return: a dict containing a list of ssh private keys: {'private_keys': [('ssh-rsa', 'secret-rsa-key-data'), \
        ('ssh-dss': 'secret-dsa-key-data')]} or empty list [] if no private keys could be fetched.
        """
        raise NotImplementedError("do_get_private_key_list")

    def do_authentication_completed(self):
        """
        The :meth:`do_authentication_completed` method can be used to implement logic to run in case of successful
        authentication on the target server.

        Note: ``self.connection`` will only contain session_id.

        :returns: None
        """
        pass

    def do_check_in_credential(self):
        """
        The :meth:`do_check_in_credential` method can be used to implement logic to check-in the passwords and keys
        previously checked out by ``do_get_password_list`` or ``do_get_private_key_list``.

        Note: ``self.connection`` will only contain session_id.

        :returns: None
        """
        pass

    def do_session_ended(self):
        """
        The :meth:`do_session_ended` method can be used to implement logic related to the end of a session.

        Note: ``self.connection`` will only contain session_id.

        :returns: None
        """
        pass

    @cookie_property
    def account(self):
        return None

    @cookie_property
    def asset(self):
        return None

    def _generate_accounts(self):
        """
        The :meth:`_generate_accounts` method generates a list of account identifiers in the credential store.

        :return: a generator of account identifiers.
        """
        account = self._add_account_prefix_suffix_if_configured(self.connection.server_username)
        yield account

    def _add_account_prefix_suffix_if_configured(self, base_account):
        return "{}{}{}".format(self.account_prefix, base_account, self.account_suffix)

    def map_option_to_generator_function(self, option):
        generator_mapping = {
            'ip': self.generate_asset_for_server_ip,
            'domain': self.generate_asset_for_server_domain,
            'hostname': self.generate_asset_for_server_hostname,
            'domain_asset_mapping': self.generate_domain_asset_mapping
        }
        return generator_mapping.get(option, None) or getattr(self, option, None)

    def _generate_assets(self):
        """
        The :meth:`_generate_assets` method generates a list of asset identifiers in the credential store.
        It can be configured under the [assets] generator section.
        Default values for the generator methods are "hostname", "ip", "domain", "domain_asset_mapping"

        :return: a generator of asset identifiers.
        """
        options = self.plugin_configuration.getlist(
            'assets',
            'generator',
            default='hostname, ip, domain, domain_asset_mapping'
        )
        for config_option in options:
            generator_function = self.map_option_to_generator_function(config_option)
            if generator_function:
                asset = generator_function()
                # We should check for None value to keep backward compatibility
                if asset:
                    yield asset
            else:
                self.logger.error('No matching method for asset generator function: {}'.format(config_option))

    def generate_asset_for_server_ip(self):
        return self.connection.server_ip

    def generate_asset_for_server_domain(self):
        if self.domain_suffix:
            return '{}.{}'.format(self.connection.server_domain, self.domain_suffix)
        return self.connection.server_domain

    def generate_asset_for_server_hostname(self):
        if self.domain_suffix:
            return '{}.{}'.format(self.connection.server_hostname, self.domain_suffix)
        return self.connection.server_hostname

    def generate_domain_asset_mapping(self):
        return self.plugin_configuration.get('domain_asset_mapping', self.connection.server_domain)

    def get_private_key_list(
        self,
        cookie,
        session_cookie,
        # base credential store arguments
        session_id,
        protocol,
        client_ip,
        client_hostname,
        gateway_domain,
        gateway_username,
        gateway_password,
        gateway_groups,
        # get secret arguments
        server_domain,
        server_username,
        server_ip,
        server_port,
        server_hostname,
    ):
        self._setup_self(
            cookie,
            session_cookie,
            ConnectionInfo(
                session_id=session_id,
                protocol=protocol,
                client_ip=client_ip,
                client_hostname=client_hostname,
                gateway_domain=gateway_domain,
                gateway_username=gateway_username,
                gateway_password=gateway_password,
                gateway_groups=gateway_groups,
                server_domain=server_domain,
                server_username=server_username,
                server_ip=server_ip,
                server_port=server_port,
                server_hostname=server_hostname
            )
        )
        self._set_check_in_trigger()
        return self.finalize_hook(self.__fetch_credentials(self.do_get_private_key_list, "private_keys"))

    def get_password_list(
        self,
        cookie,
        session_cookie,
        # base credential store arguments
        session_id,
        protocol,
        client_ip,
        client_hostname,
        gateway_domain,
        gateway_username,
        gateway_password,
        gateway_groups,
        # get secret arguments
        server_domain,
        server_username,
        server_ip,
        server_port,
        server_hostname,
    ):
        self._setup_self(
            cookie,
            session_cookie,
            ConnectionInfo(
                session_id=session_id,
                protocol=protocol,
                client_ip=client_ip,
                client_hostname=client_hostname,
                gateway_domain=gateway_domain,
                gateway_username=gateway_username,
                gateway_password=gateway_password,
                gateway_groups=gateway_groups,
                server_domain=server_domain,
                server_username=server_username,
                server_ip=server_ip,
                server_port=server_port,
                server_hostname=server_hostname
            )
        )
        self._set_check_in_trigger()
        return self.finalize_hook(self.__fetch_credentials(self.do_get_password_list, "passwords"))

    def _set_check_in_trigger(self):
        choices = (self.CHECK_IN_TRIGGER_SESSION_ENDED, self.CHECK_IN_TRIGGER_AUTHENTICATION_COMPLETED)
        setting = self.plugin_configuration.getienum(
            self.CHECK_IN_TRIGGER_SECTION, self.connection.protocol.lower(), choices
        ) or self.plugin_configuration.getienum(
            self.CHECK_IN_TRIGGER_SECTION, "default", choices, default=self.CHECK_IN_TRIGGER_SESSION_ENDED
        )
        self._set_private("check_in_trigger", setting)

    def __fetch_credentials(self, method, key):
        if self.account:
            self.logger.info(
                "Executing check-in as it failed for the previous check out account={} asset={}".format(
                    self.account, self.asset
                )
            )
            self.do_check_in_credential()

        try:
            for account in self._generate_accounts():
                self.account = account
                for asset in self._generate_assets():
                    self.asset = asset
                    self.logger.info("Fetching {} for account={} asset={}".format(key, account, asset))
                    result = method()
                    if isinstance(result, dict) and result.get(key):
                        self.logger.info("Found {} for account={} asset={}".format(key, account, asset))
                        return self._add_cookies(result)
                    self.logger.info("No {} for account={} asset={}".format(key, account, asset))
        except NotImplementedError:
            self.logger.info("This plugin does not support fetching {}".format(key))
        self.account = None
        self.asset = None
        return self._add_cookies({key: []})

    def authentication_completed(self, cookie, session_cookie, session_id):
        self._setup_self(cookie, session_cookie, ConnectionInfo(session_id=session_id))
        self.do_authentication_completed()
        self.logger.info(
            "Executing check-in after successful authentication account={} asset={}".format(self.account, self.asset)
        )
        if self._get_private("check_in_trigger") != self.CHECK_IN_TRIGGER_AUTHENTICATION_COMPLETED:
            self.logger.info("Postpone check-in according to configuration")
        else:
            self.do_check_in_credential()
            self._set_private("check_in_called", True)
        return self.finalize_hook(self._add_cookies({}))

    def session_ended(self, cookie, session_cookie, session_id):
        self._setup_self(cookie, session_cookie, ConnectionInfo(session_id=session_id))
        if not self._get_private("check_in_called", False) and self.account:
            reason = (
                "postponed"
                if self._get_private("check_in_trigger") == self.CHECK_IN_TRIGGER_SESSION_ENDED
                else "missed"
            )
            self.logger.info(
                "Executing check-in as it was {} in authentication_completed account={} asset={}".format(
                    reason, self.account, self.asset
                )
            )
            self.do_check_in_credential()
            self._set_private("check_in_called", True)
        self.do_session_ended()
        return self.finalize_hook()

    def _setup_self(self, cookie, session_cookie, connection_info):
        self.connection = connection_info
        self.cookie = cookie
        self.session_cookie = session_cookie

    def determine_key_type(self, key):
        if key.startswith('-----BEGIN RSA PRIVATE KEY-----'):
            return 'ssh-rsa'
        else:
            self.logger.error('Unsupported key type')

    @lazy_property
    def authentication_username(self):
        """Calculated username to use to authenticate to credential store

        :returns: str or None when no configuration_section provided
        :raises: :class:`InvalidUsageException`
        """
        if self._configuration_section:
            return self._credential_from_config("username") or self._get_connection_property("gateway_username")

    @lazy_property
    def authentication_password(self):
        """Calculated password to use to authenticate to credential store

        :returns: str or None when no configuration_section provided
        :raises: :class:`InvalidUsageException`
        """
        if self._configuration_section:
            return self._credential_from_config("password") or self._get_connection_property("gateway_password")

    @lazy_property
    def domain_suffix(self):
        """Calculated domain suffix to use when generating hostname and domain assets

        :returns: str or None when not configured
        """
        return self.plugin_configuration.get('assets', 'domain_suffix')

    @lazy_property
    def account_prefix(self):
        """Calculated prefix to use when generating account name

        :returns: str or empty string when not configured
        """
        return self.plugin_configuration.get('account', 'prefix', default='')

    @lazy_property
    def account_suffix(self):
        """Calculated suffix to use when generating account name

        :returns: str or empty string when not configured
        """
        return self.plugin_configuration.get('account', 'suffix', default='')

    def _credential_from_config(self, option_name):
        return (
            self.plugin_configuration.get(self._configuration_section, option_name, required=True)
            if self.plugin_configuration.getienum(self._configuration_section, "use_credential", ("explicit", "gateway"), default="gateway") == "explicit"
            else None
        )

    def _get_connection_property(self, connection_property):
        if not self.connection:
            raise InvalidUsageException
        return getattr(self.connection, connection_property)
