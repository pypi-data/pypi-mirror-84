#
# Copyright (c) 2006-2020 Balabit
# All Rights Reserved.
#
from glob import glob
from invoke import call, task, Exit
import logging
from .manifest import Manifest
from .dummy_plugin import Plugin as DummyPlugin
from .aa_plugin_tester import AAPluginTester
from .default_config import (
    AA_PLUGIN_DEFAULT_CONFIG,
    CREDENTIAL_STORE_PLUGIN_DEFAULT_CONFIG,
    SIGNING_CA_PLUGIN_DEFAULT_CONFIG,
)
from .task_utils import plugin_sdk_installed

import os
import sys
import re
import importlib.util
from shutil import copyfile, rmtree
from tempfile import mkstemp
from textwrap import dedent
from zipfile import ZipFile
from safeguard.sessions.plugin import __version__ as plugin_sdk_version, __sps_min_version__ as sps_min_version
from safeguard.sessions.plugin.data.aa_sample import scenarios, GatewayAndTargetUserDiffer


log = logging.getLogger(__name__)
BUILD_DIR = "build"
VENV_DIR = os.path.join(BUILD_DIR, "venv")
DIST_DIR = "dist"


DIST_PACKAGE_EXCLUDE_LIST = ("pip", "pkg-resources", "setuptools", "wheel")
DIST_ZIP_EXCLUDE_LIST = (
    os.path.join("pip", ".*"),
    os.path.join("wheel", ".*"),
    os.path.join("setuptools", ".*"),
    os.path.join("pkg_resources", ".*"),
    "easy_install.*",
)
DIST_ZIP_EXCLUDE_METADATA_LIST = (os.path.join(".*[.]dist-info", ".*"), os.path.join(".*[.]egg-info", ".*"))
DIST_EXTRA_FILES = ("MANIFEST", "CHANGELOG", "NEWS", "README", "README.md", "default.cfg", "LICENSE.txt")


@task
def check_manifest(c):
    manifest = Manifest.from_file()
    manifest.check_api_version(plugin_sdk_version)


@task
def check_entry_point(c):
    manifest = Manifest.from_file()
    assert os.path.exists(manifest.entry_point), "MANIFEST entry_point file must exist"


@task(help={"dirname": "Name of directory to check and create"})
def ensure_dir(c, dirname):
    if os.path.isdir(dirname):
        return
    log.info("Creating directory = {}".format(dirname))
    os.mkdir(dirname)


@task
def ensure_setup_py(c):
    if os.path.exists("setup.py"):
        return
    log.warning("Auto generating setup.py")
    manifest = Manifest.from_file()
    with open("setup.py", "w") as f:
        f.write(
            dedent(
                """
            # Auto generated by pluginv {func} task
            from setuptools import find_packages, setup
            setup(
                name="{name}".lower(),
                version="{version}",
                packages=find_packages(exclude=[
                    "*.tests",
                    "*.tests.*",
                    "tests.*",
                    "tests"
                ]),
                py_modules=["{module}"]
            )
       """
            ).format(
                func=ensure_setup_py.__name__,
                name=manifest.name,
                version=manifest.version,
                module=calc_module_name(manifest.entry_point),
            )
        )


@task
def ensure_conftest_py(c):
    if os.path.exists("conftest.py"):
        return
    log.warning("Auto generating conftest.py")
    with open("conftest.py", "w") as f:
        f.write(
            dedent(
                """
            # Auto generated by pluginv {func} task
            # Import common pytest fixtures
            from safeguard.sessions.plugin_impl.tasks.common_conftest import *  # noqa: F401,F403
        """
            ).format(func=ensure_conftest_py.__name__)
        )


@task
def ensure_default_cfg(c):
    def write_default_cfg(content):
        with open("default.cfg", "w") as _file:
            _file.write(content)

    config_file_strategy = dict(
        credentialstore=CREDENTIAL_STORE_PLUGIN_DEFAULT_CONFIG,
        aa=AA_PLUGIN_DEFAULT_CONFIG,
        signingca=SIGNING_CA_PLUGIN_DEFAULT_CONFIG,
    )

    manifest = Manifest.from_file()
    plugin_type = manifest.type
    common_configuration_options = config_file_strategy.get(plugin_type)

    if common_configuration_options is None:
        raise Exit(message="Unsupported plugin type: {}".format(plugin_type), code=1)

    if os.path.exists("default.cfg"):
        log.warning("default.cfg already exists. Won't override.")
        return

    if os.path.exists("default.cfg.plugin"):
        log.warning("Using default.cfg.plugin plus adding common configuration to generate default.cfg")
        with open("default.cfg.plugin") as _file:
            plugin_config = _file.read()
        content = plugin_config + "\n" + common_configuration_options
        write_default_cfg(content)
    else:
        log.warning("Generationg default.cfg with common configuration options")
        write_default_cfg(common_configuration_options)


def calc_module_name(entry_point):
    tokens = entry_point.split(".")
    if tokens[-1] == "py":
        tokens = tokens[:-1]
    return ".".join(tokens)


@task
def create_dist_virtualenv(c):
    create_virtualenv(c)
    pip_requirements = dist_pip_requirements(c)
    if plugin_sdk_installed(pip_requirements):
        raise Exit(
            message=(
                "Plugin SDK should not be part of the plugin ZIP.\n"
                "Make sure your Pipfile does not contain Plugin SDK as runtime dependency in [packages] section.\n"
                "See the Getting started section of the documentation."
            ),
            code=1,
        )
    if pip_has_package_requirement(pip_requirements):
        pip_install_requirements(c, pip_requirements)
        generate_3rdparty_license_file(c)
    pip_install_plugin(c)


@task
def copy_dist_files(c):
    for name in DIST_EXTRA_FILES:
        if not os.path.exists(name):
            continue
        collect_dir = get_collect_dir()
        copyfile(name, os.path.join(collect_dir, name))


PREPARE_COLLECT_DIR_STEPS = [
    call(ensure_dir, dirname=BUILD_DIR),
    call(ensure_dir, dirname=DIST_DIR),
    check_manifest,
    check_entry_point,
    ensure_setup_py,
    ensure_default_cfg,
    create_dist_virtualenv,
    copy_dist_files,
]


def check_zipfile_size(zipname):
    zipname = os.path.join(DIST_DIR, zipname)
    zip_stats = os.stat(zipname)
    zip_size = zip_stats.st_size / (1024 * 1024)
    if zip_size >= 20:
        raise Exit(
            message=(
                "The size of the generated Zip exceeds 20MB and you won't be able to upload it to your SPS."
                "\nPlease check the content of the Zip file."
            ),
            code=1,
        )


@task(help="Build snapshot plugin ZIP distribution package", pre=PREPARE_COLLECT_DIR_STEPS)
def dist(c, exclude_metadata=False):
    manifest = Manifest.from_file(os.path.join(get_collect_dir(), "MANIFEST"))
    manifest.make_snapshot_version()
    manifest.write_file()
    zipname = get_plugin_zip_filename(manifest)
    create_zip_file(c, zipname, exclude_metadata)
    check_zipfile_size(zipname=zipname)


@task(help="Build release plugin ZIP distribution package", pre=PREPARE_COLLECT_DIR_STEPS)
def release(c, suffix=None, exclude_metadata=False):
    manifest = Manifest.from_file(os.path.join(get_collect_dir(), "MANIFEST"))
    if suffix:
        manifest.add_version_suffix(suffix)
        manifest.write_file()
    zipname = get_plugin_zip_filename(manifest)
    create_zip_file(c, zipname, exclude_metadata)
    check_zipfile_size(zipname=zipname)


@task(
    help={
        "name": "Name of scenario",
        "list-scenarios": "List scenario names",
        "config-file": "Name of config file",
        "self-test": "Run standalone self-test on dummy plugin",
        "server-username": "Username on the server.",
        "target-username": "DEPRECATED use server-username",
        "gateway-username": "Username on the gateway",
    },
    pre=[check_manifest, check_entry_point],
)
def run_scenario(
        c, name=None, list_scenarios=False, config_file=None, self_test=False, server_username=None, target_username=None, gateway_username=None
):
    if list_scenarios:
        [print(n) for n in scenarios.keys()]
        raise Exit(code=0)

    config = ""
    if config_file:
        with open(config_file) as f:
            config = f.read()

    manifest = Manifest.from_file("MANIFEST")

    sys.path.append(os.getcwd())

    plugin_class = DummyPlugin if self_test else load_source("plugintotest", manifest.entry_point).Plugin
    scenarios_to_run = [name] if name else list(scenarios.keys())
    username_on_server = server_username or target_username
    for scenario_name in scenarios_to_run:
        print("Running scenario: {}".format(scenario_name))
        try:
            AAPluginTester.run_scenario(
                plugin_class, config, scenarios[scenario_name], username_on_server, gateway_username
            )
        except GatewayAndTargetUserDiffer:
            raise Exit("Gateway and target username should be the same for a scenario without gateway authentication")


def load_source(name, pathname):
    module_spec = importlib.util.spec_from_file_location(name, pathname)
    module = importlib.util.module_from_spec(module_spec)
    module_spec.loader.exec_module(module)
    return module


def dist_pip_requirements(c):
    log.debug("Dumping runtime requirements with pipenv lock --requirements")
    result = c.run("pipenv lock --requirements")
    return result.stdout


def pip_has_package_requirement(pip_requirements):
    # exclude pip parameters starting with - (dash) and empty lines
    return len([line for line in pip_requirements.splitlines() if re.fullmatch("[^-].+", line)]) > 0


def create_virtualenv(c):
    log.debug("Removing existing virtualenv {}".format(VENV_DIR))
    rmtree(VENV_DIR, ignore_errors=True)
    c.run("virtualenv -p python3.6 {path}".format(path=VENV_DIR))


def pip_install_requirements(c, requirements):
    (tmp_file, tmp_name) = mkstemp()

    os.write(tmp_file, requirements.encode("utf-8"))
    os.close(tmp_file)
    log.debug("Installing runtime requirements to {} from temp file {}".format(VENV_DIR, tmp_name))
    c.run("{pip} install -r {reqs}".format(pip=pip_path(), reqs=tmp_name))

    os.unlink(tmp_name)


def pip_install_plugin(c):
    c.run("{pip} install .".format(pip=pip_path()))


def generate_3rdparty_license_file(c):
    pip_list_result = c.run("{pip} list".format(pip=pip_path()))
    package_lines = pip_list_result.stdout.splitlines()[2:]
    with open(os.path.join(get_venv_python_lib_dir(), "site-packages", "3rdparty-licenses.txt"), "w") as license_file:
        for line in package_lines:
            packagename = line.split()[0]
            if packagename in DIST_PACKAGE_EXCLUDE_LIST:
                continue
            show_result = c.run("{pip} show {pkg}".format(pip=pip_path(), pkg=packagename))
            show_lines = show_result.stdout.splitlines()
            relevant_lines = [line for line in show_lines if re.fullmatch("(Name|Home-page|License).*", line)]
            relevant_lines = relevant_lines + ["", ""]  # visual separator
            license_file.write("\n".join(relevant_lines))


def pip_path():
    return os.path.join(VENV_DIR, "bin", "pip")


def get_collect_dir():
    return os.path.join(get_venv_python_lib_dir(), "site-packages")


def get_venv_python_lib_dir():
    result = glob(os.path.join(VENV_DIR, "lib", "python*"))[0]
    log.debug("Detected python lib dir = {}".format(result))
    return result


def create_zip_file(c, zipname, exclude_metadata):
    collect_dir = get_collect_dir()
    exclude_pattern = "|".join(DIST_ZIP_EXCLUDE_LIST)
    if exclude_metadata:
        exclude_pattern = "|".join((exclude_pattern,) + DIST_ZIP_EXCLUDE_METADATA_LIST)
    zipname = os.path.join(DIST_DIR, zipname)
    log.warning("Creating ZIP file={}".format(zipname))
    log.debug("Creating ZIP file from dir={} and exclude={}".format(collect_dir, exclude_pattern))

    with ZipFile(zipname, "w") as z:
        for (dirpath, dirnames, filenames) in os.walk(collect_dir):
            for name in filenames:
                fullname = os.path.join(dirpath, name)
                shortname = fullname[len(collect_dir) + 1 :]
                if re.fullmatch(exclude_pattern, shortname):
                    continue
                log.debug("Adding {}".format(fullname))
                z.write(fullname, shortname)


def get_plugin_zip_filename(manifest):
    return manifest.name + "-" + manifest.version + ".zip"


@task(help="Run Python pep standard checks")
def check_codingstandard(c):
    c.run("flake8 --max-line-length=120 --exclude='.git,__pycache__,./build/*' --show-source --format=pylint")


@task(help="Shorthand for check_codingstandard", pre=[check_codingstandard])
def check_cs(c):
    pass


@task(
    help=dedent(
        """
        Run tests in non-interactive mode. Equivalent to
        $ pytest --backend-service=replay
        or simply
        $ pytest
    """
    ),
    pre=[ensure_conftest_py],
)
def run_tests(c):
    c.run("pytest")


@task(
    help=dedent(
        """
        Run tests in interactive mode, do not modify test data. Equivalent to
        $ pytest --backend-service=use --capture=sys
    """
    ),
    pre=[ensure_conftest_py],
)
def run_interactive_tests(c):
    c.run("pytest --backend-service=use --capture=sys")


@task(
    help=dedent(
        """
        Run tests in interactive mode, save modified test data. Equivalent to
        $ pytest --backend-service=record --capture=sys
    """
    ),
    pre=[ensure_conftest_py],
)
def run_recording_tests(c):
    c.run("pytest --backend-service=record --capture=sys")


@task(help="Print Plugin SDK version")
def version_sdk(c):
    print(plugin_sdk_version)


@task(help="Print SPS min version defined by Plugin SDK")
def version_sps(c):
    print(sps_min_version)
