// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MESSAGE_BLUEFOG_COMMON_WIRE_H_
#define FLATBUFFERS_GENERATED_MESSAGE_BLUEFOG_COMMON_WIRE_H_

#include "flatbuffers/flatbuffers.h"

namespace bluefog {
namespace common {
namespace wire {

struct Request;
struct RequestBuilder;

struct RequestList;
struct RequestListBuilder;

struct Response;
struct ResponseBuilder;

struct ResponseList;
struct ResponseListBuilder;

enum DataType {
  DataType_BLUEFOG_UINT8 = 0,
  DataType_BLUEFOG_INT8 = 1,
  DataType_BLUEFOG_UINT16 = 2,
  DataType_BLUEFOG_INT16 = 3,
  DataType_BLUEFOG_INT32 = 4,
  DataType_BLUEFOG_INT64 = 5,
  DataType_BLUEFOG_FLOAT16 = 6,
  DataType_BLUEFOG_FLOAT32 = 7,
  DataType_BLUEFOG_FLOAT64 = 8,
  DataType_BLUEFOG_BOOL = 9,
  DataType_BLUEFOG_BYTE = 10,
  DataType_MIN = DataType_BLUEFOG_UINT8,
  DataType_MAX = DataType_BLUEFOG_BYTE
};

inline const DataType (&EnumValuesDataType())[11] {
  static const DataType values[] = {
    DataType_BLUEFOG_UINT8,
    DataType_BLUEFOG_INT8,
    DataType_BLUEFOG_UINT16,
    DataType_BLUEFOG_INT16,
    DataType_BLUEFOG_INT32,
    DataType_BLUEFOG_INT64,
    DataType_BLUEFOG_FLOAT16,
    DataType_BLUEFOG_FLOAT32,
    DataType_BLUEFOG_FLOAT64,
    DataType_BLUEFOG_BOOL,
    DataType_BLUEFOG_BYTE
  };
  return values;
}

inline const char * const *EnumNamesDataType() {
  static const char * const names[12] = {
    "BLUEFOG_UINT8",
    "BLUEFOG_INT8",
    "BLUEFOG_UINT16",
    "BLUEFOG_INT16",
    "BLUEFOG_INT32",
    "BLUEFOG_INT64",
    "BLUEFOG_FLOAT16",
    "BLUEFOG_FLOAT32",
    "BLUEFOG_FLOAT64",
    "BLUEFOG_BOOL",
    "BLUEFOG_BYTE",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataType(DataType e) {
  if (flatbuffers::IsOutRange(e, DataType_BLUEFOG_UINT8, DataType_BLUEFOG_BYTE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataType()[index];
}

enum RequestType {
  RequestType_UNKNOWN = 0,
  RequestType_ALLREDUCE = 1,
  RequestType_ALLGATHER = 2,
  RequestType_BROADCAST = 3,
  RequestType_NEIGHBOR_ALLREDUCE = 4,
  RequestType_NEIGHBOR_ALLGATHER = 5,
  RequestType_WIN_CREATE = 6,
  RequestType_WIN_FREE = 7,
  RequestType_WIN_PUT = 8,
  RequestType_WIN_GET = 9,
  RequestType_WIN_ACCUMULATE = 10,
  RequestType_BARRIER = 11,
  RequestType_PAIR_GOSSIP = 12,
  RequestType_MIN = RequestType_UNKNOWN,
  RequestType_MAX = RequestType_PAIR_GOSSIP
};

inline const RequestType (&EnumValuesRequestType())[13] {
  static const RequestType values[] = {
    RequestType_UNKNOWN,
    RequestType_ALLREDUCE,
    RequestType_ALLGATHER,
    RequestType_BROADCAST,
    RequestType_NEIGHBOR_ALLREDUCE,
    RequestType_NEIGHBOR_ALLGATHER,
    RequestType_WIN_CREATE,
    RequestType_WIN_FREE,
    RequestType_WIN_PUT,
    RequestType_WIN_GET,
    RequestType_WIN_ACCUMULATE,
    RequestType_BARRIER,
    RequestType_PAIR_GOSSIP
  };
  return values;
}

inline const char * const *EnumNamesRequestType() {
  static const char * const names[14] = {
    "UNKNOWN",
    "ALLREDUCE",
    "ALLGATHER",
    "BROADCAST",
    "NEIGHBOR_ALLREDUCE",
    "NEIGHBOR_ALLGATHER",
    "WIN_CREATE",
    "WIN_FREE",
    "WIN_PUT",
    "WIN_GET",
    "WIN_ACCUMULATE",
    "BARRIER",
    "PAIR_GOSSIP",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestType(RequestType e) {
  if (flatbuffers::IsOutRange(e, RequestType_UNKNOWN, RequestType_PAIR_GOSSIP)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestType()[index];
}

enum ResponseType {
  ResponseType_ERROR = 0,
  ResponseType_ALLREDUCE = 1,
  ResponseType_ALLGATHER = 2,
  ResponseType_BROADCAST = 3,
  ResponseType_NEIGHBOR_ALLREDUCE = 4,
  ResponseType_NEIGHBOR_ALLGATHER = 5,
  ResponseType_WIN_CREATE = 6,
  ResponseType_WIN_FREE = 7,
  ResponseType_MIN = ResponseType_ERROR,
  ResponseType_MAX = ResponseType_WIN_FREE
};

inline const ResponseType (&EnumValuesResponseType())[8] {
  static const ResponseType values[] = {
    ResponseType_ERROR,
    ResponseType_ALLREDUCE,
    ResponseType_ALLGATHER,
    ResponseType_BROADCAST,
    ResponseType_NEIGHBOR_ALLREDUCE,
    ResponseType_NEIGHBOR_ALLGATHER,
    ResponseType_WIN_CREATE,
    ResponseType_WIN_FREE
  };
  return values;
}

inline const char * const *EnumNamesResponseType() {
  static const char * const names[9] = {
    "ERROR",
    "ALLREDUCE",
    "ALLGATHER",
    "BROADCAST",
    "NEIGHBOR_ALLREDUCE",
    "NEIGHBOR_ALLGATHER",
    "WIN_CREATE",
    "WIN_FREE",
    nullptr
  };
  return names;
}

inline const char *EnumNameResponseType(ResponseType e) {
  if (flatbuffers::IsOutRange(e, ResponseType_ERROR, ResponseType_WIN_FREE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResponseType()[index];
}

struct Request FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REQUEST_RANK = 4,
    VT_REQUEST_TYPE = 6,
    VT_TENSOR_TYPE = 8,
    VT_TENSOR_NAME = 10,
    VT_ROOT_RANK = 12,
    VT_DEVICE = 14,
    VT_TENSOR_SHAPE = 16,
    VT_IS_HIERARCHICAL = 18
  };
  int32_t request_rank() const {
    return GetField<int32_t>(VT_REQUEST_RANK, 0);
  }
  bluefog::common::wire::RequestType request_type() const {
    return static_cast<bluefog::common::wire::RequestType>(GetField<int8_t>(VT_REQUEST_TYPE, 0));
  }
  bluefog::common::wire::DataType tensor_type() const {
    return static_cast<bluefog::common::wire::DataType>(GetField<int8_t>(VT_TENSOR_TYPE, 0));
  }
  const flatbuffers::String *tensor_name() const {
    return GetPointer<const flatbuffers::String *>(VT_TENSOR_NAME);
  }
  int32_t root_rank() const {
    return GetField<int32_t>(VT_ROOT_RANK, 0);
  }
  int32_t device() const {
    return GetField<int32_t>(VT_DEVICE, 0);
  }
  const flatbuffers::Vector<int64_t> *tensor_shape() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_TENSOR_SHAPE);
  }
  bool is_hierarchical() const {
    return GetField<uint8_t>(VT_IS_HIERARCHICAL, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REQUEST_RANK) &&
           VerifyField<int8_t>(verifier, VT_REQUEST_TYPE) &&
           VerifyField<int8_t>(verifier, VT_TENSOR_TYPE) &&
           VerifyOffset(verifier, VT_TENSOR_NAME) &&
           verifier.VerifyString(tensor_name()) &&
           VerifyField<int32_t>(verifier, VT_ROOT_RANK) &&
           VerifyField<int32_t>(verifier, VT_DEVICE) &&
           VerifyOffset(verifier, VT_TENSOR_SHAPE) &&
           verifier.VerifyVector(tensor_shape()) &&
           VerifyField<uint8_t>(verifier, VT_IS_HIERARCHICAL) &&
           verifier.EndTable();
  }
};

struct RequestBuilder {
  typedef Request Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_request_rank(int32_t request_rank) {
    fbb_.AddElement<int32_t>(Request::VT_REQUEST_RANK, request_rank, 0);
  }
  void add_request_type(bluefog::common::wire::RequestType request_type) {
    fbb_.AddElement<int8_t>(Request::VT_REQUEST_TYPE, static_cast<int8_t>(request_type), 0);
  }
  void add_tensor_type(bluefog::common::wire::DataType tensor_type) {
    fbb_.AddElement<int8_t>(Request::VT_TENSOR_TYPE, static_cast<int8_t>(tensor_type), 0);
  }
  void add_tensor_name(flatbuffers::Offset<flatbuffers::String> tensor_name) {
    fbb_.AddOffset(Request::VT_TENSOR_NAME, tensor_name);
  }
  void add_root_rank(int32_t root_rank) {
    fbb_.AddElement<int32_t>(Request::VT_ROOT_RANK, root_rank, 0);
  }
  void add_device(int32_t device) {
    fbb_.AddElement<int32_t>(Request::VT_DEVICE, device, 0);
  }
  void add_tensor_shape(flatbuffers::Offset<flatbuffers::Vector<int64_t>> tensor_shape) {
    fbb_.AddOffset(Request::VT_TENSOR_SHAPE, tensor_shape);
  }
  void add_is_hierarchical(bool is_hierarchical) {
    fbb_.AddElement<uint8_t>(Request::VT_IS_HIERARCHICAL, static_cast<uint8_t>(is_hierarchical), 0);
  }
  explicit RequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestBuilder &operator=(const RequestBuilder &);
  flatbuffers::Offset<Request> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request> CreateRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t request_rank = 0,
    bluefog::common::wire::RequestType request_type = bluefog::common::wire::RequestType_UNKNOWN,
    bluefog::common::wire::DataType tensor_type = bluefog::common::wire::DataType_BLUEFOG_UINT8,
    flatbuffers::Offset<flatbuffers::String> tensor_name = 0,
    int32_t root_rank = 0,
    int32_t device = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> tensor_shape = 0,
    bool is_hierarchical = false) {
  RequestBuilder builder_(_fbb);
  builder_.add_tensor_shape(tensor_shape);
  builder_.add_device(device);
  builder_.add_root_rank(root_rank);
  builder_.add_tensor_name(tensor_name);
  builder_.add_request_rank(request_rank);
  builder_.add_is_hierarchical(is_hierarchical);
  builder_.add_tensor_type(tensor_type);
  builder_.add_request_type(request_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request> CreateRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t request_rank = 0,
    bluefog::common::wire::RequestType request_type = bluefog::common::wire::RequestType_UNKNOWN,
    bluefog::common::wire::DataType tensor_type = bluefog::common::wire::DataType_BLUEFOG_UINT8,
    const char *tensor_name = nullptr,
    int32_t root_rank = 0,
    int32_t device = 0,
    const std::vector<int64_t> *tensor_shape = nullptr,
    bool is_hierarchical = false) {
  auto tensor_name__ = tensor_name ? _fbb.CreateString(tensor_name) : 0;
  auto tensor_shape__ = tensor_shape ? _fbb.CreateVector<int64_t>(*tensor_shape) : 0;
  return bluefog::common::wire::CreateRequest(
      _fbb,
      request_rank,
      request_type,
      tensor_type,
      tensor_name__,
      root_rank,
      device,
      tensor_shape__,
      is_hierarchical);
}

struct RequestList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RequestListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REQUESTS = 4,
    VT_SHUTDOWN = 6,
    VT_CHANGE_TOPO = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<bluefog::common::wire::Request>> *requests() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<bluefog::common::wire::Request>> *>(VT_REQUESTS);
  }
  bool shutdown() const {
    return GetField<uint8_t>(VT_SHUTDOWN, 0) != 0;
  }
  bool change_topo() const {
    return GetField<uint8_t>(VT_CHANGE_TOPO, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REQUESTS) &&
           verifier.VerifyVector(requests()) &&
           verifier.VerifyVectorOfTables(requests()) &&
           VerifyField<uint8_t>(verifier, VT_SHUTDOWN) &&
           VerifyField<uint8_t>(verifier, VT_CHANGE_TOPO) &&
           verifier.EndTable();
  }
};

struct RequestListBuilder {
  typedef RequestList Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_requests(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<bluefog::common::wire::Request>>> requests) {
    fbb_.AddOffset(RequestList::VT_REQUESTS, requests);
  }
  void add_shutdown(bool shutdown) {
    fbb_.AddElement<uint8_t>(RequestList::VT_SHUTDOWN, static_cast<uint8_t>(shutdown), 0);
  }
  void add_change_topo(bool change_topo) {
    fbb_.AddElement<uint8_t>(RequestList::VT_CHANGE_TOPO, static_cast<uint8_t>(change_topo), 0);
  }
  explicit RequestListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestListBuilder &operator=(const RequestListBuilder &);
  flatbuffers::Offset<RequestList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RequestList>(end);
    return o;
  }
};

inline flatbuffers::Offset<RequestList> CreateRequestList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<bluefog::common::wire::Request>>> requests = 0,
    bool shutdown = false,
    bool change_topo = false) {
  RequestListBuilder builder_(_fbb);
  builder_.add_requests(requests);
  builder_.add_change_topo(change_topo);
  builder_.add_shutdown(shutdown);
  return builder_.Finish();
}

inline flatbuffers::Offset<RequestList> CreateRequestListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<bluefog::common::wire::Request>> *requests = nullptr,
    bool shutdown = false,
    bool change_topo = false) {
  auto requests__ = requests ? _fbb.CreateVector<flatbuffers::Offset<bluefog::common::wire::Request>>(*requests) : 0;
  return bluefog::common::wire::CreateRequestList(
      _fbb,
      requests__,
      shutdown,
      change_topo);
}

struct Response FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESPONSE_TYPE = 4,
    VT_TENSOR_NAMES = 6,
    VT_ERROR_MESSAGE = 8,
    VT_DEVICES = 10
  };
  bluefog::common::wire::ResponseType response_type() const {
    return static_cast<bluefog::common::wire::ResponseType>(GetField<int8_t>(VT_RESPONSE_TYPE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *tensor_names() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TENSOR_NAMES);
  }
  const flatbuffers::String *error_message() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  const flatbuffers::Vector<int32_t> *devices() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DEVICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_RESPONSE_TYPE) &&
           VerifyOffset(verifier, VT_TENSOR_NAMES) &&
           verifier.VerifyVector(tensor_names()) &&
           verifier.VerifyVectorOfStrings(tensor_names()) &&
           VerifyOffset(verifier, VT_ERROR_MESSAGE) &&
           verifier.VerifyString(error_message()) &&
           VerifyOffset(verifier, VT_DEVICES) &&
           verifier.VerifyVector(devices()) &&
           verifier.EndTable();
  }
};

struct ResponseBuilder {
  typedef Response Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_response_type(bluefog::common::wire::ResponseType response_type) {
    fbb_.AddElement<int8_t>(Response::VT_RESPONSE_TYPE, static_cast<int8_t>(response_type), 0);
  }
  void add_tensor_names(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tensor_names) {
    fbb_.AddOffset(Response::VT_TENSOR_NAMES, tensor_names);
  }
  void add_error_message(flatbuffers::Offset<flatbuffers::String> error_message) {
    fbb_.AddOffset(Response::VT_ERROR_MESSAGE, error_message);
  }
  void add_devices(flatbuffers::Offset<flatbuffers::Vector<int32_t>> devices) {
    fbb_.AddOffset(Response::VT_DEVICES, devices);
  }
  explicit ResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResponseBuilder &operator=(const ResponseBuilder &);
  flatbuffers::Offset<Response> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Response>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response> CreateResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    bluefog::common::wire::ResponseType response_type = bluefog::common::wire::ResponseType_ERROR,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tensor_names = 0,
    flatbuffers::Offset<flatbuffers::String> error_message = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> devices = 0) {
  ResponseBuilder builder_(_fbb);
  builder_.add_devices(devices);
  builder_.add_error_message(error_message);
  builder_.add_tensor_names(tensor_names);
  builder_.add_response_type(response_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Response> CreateResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bluefog::common::wire::ResponseType response_type = bluefog::common::wire::ResponseType_ERROR,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *tensor_names = nullptr,
    const char *error_message = nullptr,
    const std::vector<int32_t> *devices = nullptr) {
  auto tensor_names__ = tensor_names ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*tensor_names) : 0;
  auto error_message__ = error_message ? _fbb.CreateString(error_message) : 0;
  auto devices__ = devices ? _fbb.CreateVector<int32_t>(*devices) : 0;
  return bluefog::common::wire::CreateResponse(
      _fbb,
      response_type,
      tensor_names__,
      error_message__,
      devices__);
}

struct ResponseList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResponseListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESPONSES = 4,
    VT_SHUTDOWN = 6,
    VT_CHANGE_TOPO = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<bluefog::common::wire::Response>> *responses() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<bluefog::common::wire::Response>> *>(VT_RESPONSES);
  }
  bool shutdown() const {
    return GetField<uint8_t>(VT_SHUTDOWN, 0) != 0;
  }
  bool change_topo() const {
    return GetField<uint8_t>(VT_CHANGE_TOPO, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RESPONSES) &&
           verifier.VerifyVector(responses()) &&
           verifier.VerifyVectorOfTables(responses()) &&
           VerifyField<uint8_t>(verifier, VT_SHUTDOWN) &&
           VerifyField<uint8_t>(verifier, VT_CHANGE_TOPO) &&
           verifier.EndTable();
  }
};

struct ResponseListBuilder {
  typedef ResponseList Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_responses(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<bluefog::common::wire::Response>>> responses) {
    fbb_.AddOffset(ResponseList::VT_RESPONSES, responses);
  }
  void add_shutdown(bool shutdown) {
    fbb_.AddElement<uint8_t>(ResponseList::VT_SHUTDOWN, static_cast<uint8_t>(shutdown), 0);
  }
  void add_change_topo(bool change_topo) {
    fbb_.AddElement<uint8_t>(ResponseList::VT_CHANGE_TOPO, static_cast<uint8_t>(change_topo), 0);
  }
  explicit ResponseListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResponseListBuilder &operator=(const ResponseListBuilder &);
  flatbuffers::Offset<ResponseList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResponseList>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResponseList> CreateResponseList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<bluefog::common::wire::Response>>> responses = 0,
    bool shutdown = false,
    bool change_topo = false) {
  ResponseListBuilder builder_(_fbb);
  builder_.add_responses(responses);
  builder_.add_change_topo(change_topo);
  builder_.add_shutdown(shutdown);
  return builder_.Finish();
}

inline flatbuffers::Offset<ResponseList> CreateResponseListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<bluefog::common::wire::Response>> *responses = nullptr,
    bool shutdown = false,
    bool change_topo = false) {
  auto responses__ = responses ? _fbb.CreateVector<flatbuffers::Offset<bluefog::common::wire::Response>>(*responses) : 0;
  return bluefog::common::wire::CreateResponseList(
      _fbb,
      responses__,
      shutdown,
      change_topo);
}

}  // namespace wire
}  // namespace common
}  // namespace bluefog

#endif  // FLATBUFFERS_GENERATED_MESSAGE_BLUEFOG_COMMON_WIRE_H_
