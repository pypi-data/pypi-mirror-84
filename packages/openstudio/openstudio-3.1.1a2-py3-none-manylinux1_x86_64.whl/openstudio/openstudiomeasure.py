# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _openstudiomeasure
else:
    import _openstudiomeasure

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomeasure.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _openstudiomeasure.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _openstudiomeasure.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _openstudiomeasure.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _openstudiomeasure.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _openstudiomeasure.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _openstudiomeasure.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _openstudiomeasure.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _openstudiomeasure.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _openstudiomeasure.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _openstudiomeasure.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _openstudiomeasure.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _openstudiomeasure.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _openstudiomeasure.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _openstudiomeasure.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _openstudiomeasure.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _openstudiomeasure.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _openstudiomeasure:
_openstudiomeasure.SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _openstudiomeasure.SHARED_PTR_DISOWN
from .import openstudioutilities
from .import openstudioutilitiescore
from .import openstudioutilitiestime
from .import openstudioutilitiesdata
from .import openstudioutilitiesunits
from .import openstudioutilitiesplot
from .import openstudioutilitiesgeometry
from .import openstudioutilitiessql
from .import openstudioutilitiesbcl
from .import openstudioutilitiesidd
from .import openstudioutilitiesidf
from .import openstudioutilitiesfiletypes
from .import openstudiomodel
from .import openstudiomodelcore
from .import openstudiomodelsimulation
from .import openstudiomodelresources
from .import openstudiomodelgeometry
from .import openstudiomodelhvac
from .import openstudiomodelzonehvac
from .import openstudiomodelavailabilitymanager
from .import openstudiomodelplantequipmentoperationscheme
from .import openstudiomodelstraightcomponent
from .import openstudiomodelairflow
from .import openstudiomodelrefrigeration
from .import openstudiomodelgenerators
class OSArgumentVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomeasure.OSArgumentVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomeasure.OSArgumentVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomeasure.OSArgumentVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::measure::OSArgument >::size_type":
        return _openstudiomeasure.OSArgumentVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::measure::OSArgument >::difference_type", j: "std::vector< openstudio::measure::OSArgument >::difference_type") -> "std::vector< openstudio::measure::OSArgument,std::allocator< openstudio::measure::OSArgument > > *":
        return _openstudiomeasure.OSArgumentVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomeasure.OSArgumentVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::measure::OSArgument >::difference_type", j: "std::vector< openstudio::measure::OSArgument >::difference_type") -> "void":
        return _openstudiomeasure.OSArgumentVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomeasure.OSArgumentVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::measure::OSArgument >::value_type const &":
        return _openstudiomeasure.OSArgumentVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomeasure.OSArgumentVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::measure::OSArgument >::value_type":
        return _openstudiomeasure.OSArgumentVector_pop(self)

    def append(self, x: "OSArgument") -> "void":
        return _openstudiomeasure.OSArgumentVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomeasure.OSArgumentVector_empty(self)

    def size(self) -> "std::vector< openstudio::measure::OSArgument >::size_type":
        return _openstudiomeasure.OSArgumentVector_size(self)

    def swap(self, v: "OSArgumentVector") -> "void":
        return _openstudiomeasure.OSArgumentVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::measure::OSArgument >::iterator":
        return _openstudiomeasure.OSArgumentVector_begin(self)

    def end(self) -> "std::vector< openstudio::measure::OSArgument >::iterator":
        return _openstudiomeasure.OSArgumentVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::measure::OSArgument >::reverse_iterator":
        return _openstudiomeasure.OSArgumentVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::measure::OSArgument >::reverse_iterator":
        return _openstudiomeasure.OSArgumentVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomeasure.OSArgumentVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::measure::OSArgument >::allocator_type":
        return _openstudiomeasure.OSArgumentVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomeasure.OSArgumentVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::measure::OSArgument >::iterator":
        return _openstudiomeasure.OSArgumentVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomeasure.OSArgumentVector_swiginit(self, _openstudiomeasure.new_OSArgumentVector(*args))

    def push_back(self, x: "OSArgument") -> "void":
        return _openstudiomeasure.OSArgumentVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::measure::OSArgument >::value_type const &":
        return _openstudiomeasure.OSArgumentVector_front(self)

    def back(self) -> "std::vector< openstudio::measure::OSArgument >::value_type const &":
        return _openstudiomeasure.OSArgumentVector_back(self)

    def assign(self, n: "std::vector< openstudio::measure::OSArgument >::size_type", x: "OSArgument") -> "void":
        return _openstudiomeasure.OSArgumentVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudiomeasure.OSArgumentVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudiomeasure.OSArgumentVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::measure::OSArgument >::size_type") -> "void":
        return _openstudiomeasure.OSArgumentVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::measure::OSArgument >::size_type":
        return _openstudiomeasure.OSArgumentVector_capacity(self)
    __swig_destroy__ = _openstudiomeasure.delete_OSArgumentVector

# Register OSArgumentVector in _openstudiomeasure:
_openstudiomeasure.OSArgumentVector_swigregister(OSArgumentVector)

class OptionalOSArgument(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomeasure.OptionalOSArgument_swiginit(self, _openstudiomeasure.new_OptionalOSArgument(*args))

    def reset(self) -> "void":
        return _openstudiomeasure.OptionalOSArgument_reset(self)

    def __ref__(self) -> "openstudio::measure::OSArgument":
        return _openstudiomeasure.OptionalOSArgument___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomeasure.OptionalOSArgument_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomeasure.OptionalOSArgument_isNull(self)

    def get(self) -> "openstudio::measure::OSArgument":
        return _openstudiomeasure.OptionalOSArgument_get(self)

    def set(self, t: "OSArgument") -> "void":
        return _openstudiomeasure.OptionalOSArgument_set(self, t)
    __swig_destroy__ = _openstudiomeasure.delete_OptionalOSArgument

# Register OptionalOSArgument in _openstudiomeasure:
_openstudiomeasure.OptionalOSArgument_swigregister(OptionalOSArgument)

class OSArgumentMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomeasure.OSArgumentMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomeasure.OSArgumentMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomeasure.OSArgumentMap___bool__(self)

    def __len__(self) -> "std::map< std::string,openstudio::measure::OSArgument >::size_type":
        return _openstudiomeasure.OSArgumentMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::map< std::string,openstudio::measure::OSArgument >::key_type const &") -> "std::map< std::string,openstudio::measure::OSArgument >::mapped_type const &":
        return _openstudiomeasure.OSArgumentMap___getitem__(self, key)

    def __delitem__(self, key: "std::map< std::string,openstudio::measure::OSArgument >::key_type const &") -> "void":
        return _openstudiomeasure.OSArgumentMap___delitem__(self, key)

    def has_key(self, key: "std::map< std::string,openstudio::measure::OSArgument >::key_type const &") -> "bool":
        return _openstudiomeasure.OSArgumentMap_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _openstudiomeasure.OSArgumentMap_keys(self)

    def values(self) -> "PyObject *":
        return _openstudiomeasure.OSArgumentMap_values(self)

    def items(self) -> "PyObject *":
        return _openstudiomeasure.OSArgumentMap_items(self)

    def __contains__(self, key: "std::map< std::string,openstudio::measure::OSArgument >::key_type const &") -> "bool":
        return _openstudiomeasure.OSArgumentMap___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomeasure.OSArgumentMap_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomeasure.OSArgumentMap_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _openstudiomeasure.OSArgumentMap___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _openstudiomeasure.OSArgumentMap_asdict(self)

    def __init__(self, *args):
        _openstudiomeasure.OSArgumentMap_swiginit(self, _openstudiomeasure.new_OSArgumentMap(*args))

    def empty(self) -> "bool":
        return _openstudiomeasure.OSArgumentMap_empty(self)

    def size(self) -> "std::map< std::string,openstudio::measure::OSArgument >::size_type":
        return _openstudiomeasure.OSArgumentMap_size(self)

    def swap(self, v: "OSArgumentMap") -> "void":
        return _openstudiomeasure.OSArgumentMap_swap(self, v)

    def begin(self) -> "std::map< std::string,openstudio::measure::OSArgument >::iterator":
        return _openstudiomeasure.OSArgumentMap_begin(self)

    def end(self) -> "std::map< std::string,openstudio::measure::OSArgument >::iterator":
        return _openstudiomeasure.OSArgumentMap_end(self)

    def rbegin(self) -> "std::map< std::string,openstudio::measure::OSArgument >::reverse_iterator":
        return _openstudiomeasure.OSArgumentMap_rbegin(self)

    def rend(self) -> "std::map< std::string,openstudio::measure::OSArgument >::reverse_iterator":
        return _openstudiomeasure.OSArgumentMap_rend(self)

    def clear(self) -> "void":
        return _openstudiomeasure.OSArgumentMap_clear(self)

    def get_allocator(self) -> "std::map< std::string,openstudio::measure::OSArgument >::allocator_type":
        return _openstudiomeasure.OSArgumentMap_get_allocator(self)

    def count(self, x: "std::map< std::string,openstudio::measure::OSArgument >::key_type const &") -> "std::map< std::string,openstudio::measure::OSArgument >::size_type":
        return _openstudiomeasure.OSArgumentMap_count(self, x)

    def erase(self, *args) -> "void":
        return _openstudiomeasure.OSArgumentMap_erase(self, *args)

    def find(self, x: "std::map< std::string,openstudio::measure::OSArgument >::key_type const &") -> "std::map< std::string,openstudio::measure::OSArgument >::iterator":
        return _openstudiomeasure.OSArgumentMap_find(self, x)

    def lower_bound(self, x: "std::map< std::string,openstudio::measure::OSArgument >::key_type const &") -> "std::map< std::string,openstudio::measure::OSArgument >::iterator":
        return _openstudiomeasure.OSArgumentMap_lower_bound(self, x)

    def upper_bound(self, x: "std::map< std::string,openstudio::measure::OSArgument >::key_type const &") -> "std::map< std::string,openstudio::measure::OSArgument >::iterator":
        return _openstudiomeasure.OSArgumentMap_upper_bound(self, x)
    __swig_destroy__ = _openstudiomeasure.delete_OSArgumentMap

# Register OSArgumentMap in _openstudiomeasure:
_openstudiomeasure.OSArgumentMap_swigregister(OSArgumentMap)

class OSOutputVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomeasure.OSOutputVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomeasure.OSOutputVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomeasure.OSOutputVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::measure::OSOutput >::size_type":
        return _openstudiomeasure.OSOutputVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::measure::OSOutput >::difference_type", j: "std::vector< openstudio::measure::OSOutput >::difference_type") -> "std::vector< openstudio::measure::OSOutput,std::allocator< openstudio::measure::OSOutput > > *":
        return _openstudiomeasure.OSOutputVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomeasure.OSOutputVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::measure::OSOutput >::difference_type", j: "std::vector< openstudio::measure::OSOutput >::difference_type") -> "void":
        return _openstudiomeasure.OSOutputVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomeasure.OSOutputVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::measure::OSOutput >::value_type const &":
        return _openstudiomeasure.OSOutputVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomeasure.OSOutputVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::measure::OSOutput >::value_type":
        return _openstudiomeasure.OSOutputVector_pop(self)

    def append(self, x: "OSOutput") -> "void":
        return _openstudiomeasure.OSOutputVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomeasure.OSOutputVector_empty(self)

    def size(self) -> "std::vector< openstudio::measure::OSOutput >::size_type":
        return _openstudiomeasure.OSOutputVector_size(self)

    def swap(self, v: "OSOutputVector") -> "void":
        return _openstudiomeasure.OSOutputVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::measure::OSOutput >::iterator":
        return _openstudiomeasure.OSOutputVector_begin(self)

    def end(self) -> "std::vector< openstudio::measure::OSOutput >::iterator":
        return _openstudiomeasure.OSOutputVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::measure::OSOutput >::reverse_iterator":
        return _openstudiomeasure.OSOutputVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::measure::OSOutput >::reverse_iterator":
        return _openstudiomeasure.OSOutputVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomeasure.OSOutputVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::measure::OSOutput >::allocator_type":
        return _openstudiomeasure.OSOutputVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomeasure.OSOutputVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::measure::OSOutput >::iterator":
        return _openstudiomeasure.OSOutputVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomeasure.OSOutputVector_swiginit(self, _openstudiomeasure.new_OSOutputVector(*args))

    def push_back(self, x: "OSOutput") -> "void":
        return _openstudiomeasure.OSOutputVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::measure::OSOutput >::value_type const &":
        return _openstudiomeasure.OSOutputVector_front(self)

    def back(self) -> "std::vector< openstudio::measure::OSOutput >::value_type const &":
        return _openstudiomeasure.OSOutputVector_back(self)

    def assign(self, n: "std::vector< openstudio::measure::OSOutput >::size_type", x: "OSOutput") -> "void":
        return _openstudiomeasure.OSOutputVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::measure::OSOutput >::size_type", x: "OSOutput") -> "void":
        return _openstudiomeasure.OSOutputVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomeasure.OSOutputVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::measure::OSOutput >::size_type") -> "void":
        return _openstudiomeasure.OSOutputVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::measure::OSOutput >::size_type":
        return _openstudiomeasure.OSOutputVector_capacity(self)
    __swig_destroy__ = _openstudiomeasure.delete_OSOutputVector

# Register OSOutputVector in _openstudiomeasure:
_openstudiomeasure.OSOutputVector_swigregister(OSOutputVector)

class OptionalOSOutput(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomeasure.OptionalOSOutput_swiginit(self, _openstudiomeasure.new_OptionalOSOutput(*args))

    def reset(self) -> "void":
        return _openstudiomeasure.OptionalOSOutput_reset(self)

    def __ref__(self) -> "openstudio::measure::OSOutput":
        return _openstudiomeasure.OptionalOSOutput___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomeasure.OptionalOSOutput_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomeasure.OptionalOSOutput_isNull(self)

    def get(self) -> "openstudio::measure::OSOutput":
        return _openstudiomeasure.OptionalOSOutput_get(self)

    def set(self, t: "OSOutput") -> "void":
        return _openstudiomeasure.OptionalOSOutput_set(self, t)
    __swig_destroy__ = _openstudiomeasure.delete_OptionalOSOutput

# Register OptionalOSOutput in _openstudiomeasure:
_openstudiomeasure.OptionalOSOutput_swigregister(OptionalOSOutput)

class OSArgumentType(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomeasure.OSArgumentType_swiginit(self, _openstudiomeasure.new_OSArgumentType(*args))

    def valueName(self) -> "std::string":
        return _openstudiomeasure.OSArgumentType_valueName(self)

    def value(self) -> "int":
        return _openstudiomeasure.OSArgumentType_value(self)

    def valueDescription(self) -> "std::string":
        return _openstudiomeasure.OSArgumentType_valueDescription(self)

    def __eq__(self, other: "OSArgumentType") -> "bool":
        return _openstudiomeasure.OSArgumentType___eq__(self, other)

    def __ne__(self, other: "OSArgumentType") -> "bool":
        return _openstudiomeasure.OSArgumentType___ne__(self, other)

    def __gt__(self, other: "OSArgumentType") -> "bool":
        return _openstudiomeasure.OSArgumentType___gt__(self, other)

    def __ge__(self, other: "OSArgumentType") -> "bool":
        return _openstudiomeasure.OSArgumentType___ge__(self, other)

    def __lt__(self, other: "OSArgumentType") -> "bool":
        return _openstudiomeasure.OSArgumentType___lt__(self, other)

    def __le__(self, other: "OSArgumentType") -> "bool":
        return _openstudiomeasure.OSArgumentType___le__(self, other)

    @staticmethod
    def enumName() -> "std::string":
        return _openstudiomeasure.OSArgumentType_enumName()

    @staticmethod
    def getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
        return _openstudiomeasure.OSArgumentType_getValues()

    def __str__(self) -> "std::string":
        return _openstudiomeasure.OSArgumentType___str__(self)
    __swig_destroy__ = _openstudiomeasure.delete_OSArgumentType

# Register OSArgumentType in _openstudiomeasure:
_openstudiomeasure.OSArgumentType_swigregister(OSArgumentType)

def OSArgumentType_enumName() -> "std::string":
    return _openstudiomeasure.OSArgumentType_enumName()

def OSArgumentType_getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
    return _openstudiomeasure.OSArgumentType_getValues()

class OSDomainType(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomeasure.OSDomainType_swiginit(self, _openstudiomeasure.new_OSDomainType(*args))

    def valueName(self) -> "std::string":
        return _openstudiomeasure.OSDomainType_valueName(self)

    def value(self) -> "int":
        return _openstudiomeasure.OSDomainType_value(self)

    def valueDescription(self) -> "std::string":
        return _openstudiomeasure.OSDomainType_valueDescription(self)

    def __eq__(self, other: "OSDomainType") -> "bool":
        return _openstudiomeasure.OSDomainType___eq__(self, other)

    def __ne__(self, other: "OSDomainType") -> "bool":
        return _openstudiomeasure.OSDomainType___ne__(self, other)

    def __gt__(self, other: "OSDomainType") -> "bool":
        return _openstudiomeasure.OSDomainType___gt__(self, other)

    def __ge__(self, other: "OSDomainType") -> "bool":
        return _openstudiomeasure.OSDomainType___ge__(self, other)

    def __lt__(self, other: "OSDomainType") -> "bool":
        return _openstudiomeasure.OSDomainType___lt__(self, other)

    def __le__(self, other: "OSDomainType") -> "bool":
        return _openstudiomeasure.OSDomainType___le__(self, other)

    @staticmethod
    def enumName() -> "std::string":
        return _openstudiomeasure.OSDomainType_enumName()

    @staticmethod
    def getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
        return _openstudiomeasure.OSDomainType_getValues()

    def __str__(self) -> "std::string":
        return _openstudiomeasure.OSDomainType___str__(self)
    __swig_destroy__ = _openstudiomeasure.delete_OSDomainType

# Register OSDomainType in _openstudiomeasure:
_openstudiomeasure.OSDomainType_swigregister(OSDomainType)

def OSDomainType_enumName() -> "std::string":
    return _openstudiomeasure.OSDomainType_enumName()

def OSDomainType_getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
    return _openstudiomeasure.OSDomainType_getValues()

class OSArgument(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomeasure.OSArgument_swiginit(self, _openstudiomeasure.new_OSArgument(*args))

    def clone(self) -> "openstudio::measure::OSArgument":
        return _openstudiomeasure.OSArgument_clone(self)

    @staticmethod
    def makeBoolArgument(name: "std::string const &", required: "bool"=True, modelDependent: "bool"=False) -> "openstudio::measure::OSArgument":
        return _openstudiomeasure.OSArgument_makeBoolArgument(name, required, modelDependent)

    @staticmethod
    def makeDoubleArgument(name: "std::string const &", required: "bool"=True, modelDependent: "bool"=False) -> "openstudio::measure::OSArgument":
        return _openstudiomeasure.OSArgument_makeDoubleArgument(name, required, modelDependent)

    @staticmethod
    def makeIntegerArgument(name: "std::string const &", required: "bool"=True, modelDependent: "bool"=False) -> "openstudio::measure::OSArgument":
        return _openstudiomeasure.OSArgument_makeIntegerArgument(name, required, modelDependent)

    @staticmethod
    def makeStringArgument(name: "std::string const &", required: "bool"=True, modelDependent: "bool"=False) -> "openstudio::measure::OSArgument":
        return _openstudiomeasure.OSArgument_makeStringArgument(name, required, modelDependent)

    @staticmethod
    def makeChoiceArgument(*args) -> "openstudio::measure::OSArgument":
        return _openstudiomeasure.OSArgument_makeChoiceArgument(*args)

    @staticmethod
    def makePathArgument(name: "std::string const &", isRead: "bool", extension: "std::string const &", required: "bool"=True, modelDependent: "bool"=False) -> "openstudio::measure::OSArgument":
        return _openstudiomeasure.OSArgument_makePathArgument(name, isRead, extension, required, modelDependent)

    @staticmethod
    def makeSeparatorArgument(name: "std::string const &", modelDependent: "bool"=False) -> "openstudio::measure::OSArgument":
        return _openstudiomeasure.OSArgument_makeSeparatorArgument(name, modelDependent)

    def name(self) -> "std::string":
        return _openstudiomeasure.OSArgument_name(self)

    def displayName(self) -> "std::string":
        return _openstudiomeasure.OSArgument_displayName(self)

    def description(self) -> "boost::optional< std::string >":
        return _openstudiomeasure.OSArgument_description(self)

    def type(self) -> "openstudio::measure::OSArgumentType":
        return _openstudiomeasure.OSArgument_type(self)

    def units(self) -> "boost::optional< std::string >":
        return _openstudiomeasure.OSArgument_units(self)

    def required(self) -> "bool":
        return _openstudiomeasure.OSArgument_required(self)

    def modelDependent(self) -> "bool":
        return _openstudiomeasure.OSArgument_modelDependent(self)

    def hasValue(self) -> "bool":
        return _openstudiomeasure.OSArgument_hasValue(self)

    def valueAsBool(self) -> "bool":
        return _openstudiomeasure.OSArgument_valueAsBool(self)

    def valueAsDouble(self) -> "double":
        return _openstudiomeasure.OSArgument_valueAsDouble(self)

    def valueAsInteger(self) -> "int":
        return _openstudiomeasure.OSArgument_valueAsInteger(self)

    def valueAsString(self) -> "std::string":
        return _openstudiomeasure.OSArgument_valueAsString(self)

    def valueAsPath(self) -> "openstudio::path":
        return _openstudiomeasure.OSArgument_valueAsPath(self)

    def hasDefaultValue(self) -> "bool":
        return _openstudiomeasure.OSArgument_hasDefaultValue(self)

    def defaultValueAsBool(self) -> "bool":
        return _openstudiomeasure.OSArgument_defaultValueAsBool(self)

    def defaultValueAsDouble(self) -> "double":
        return _openstudiomeasure.OSArgument_defaultValueAsDouble(self)

    def defaultValueAsInteger(self) -> "int":
        return _openstudiomeasure.OSArgument_defaultValueAsInteger(self)

    def defaultValueAsString(self) -> "std::string":
        return _openstudiomeasure.OSArgument_defaultValueAsString(self)

    def defaultValueAsPath(self) -> "openstudio::path":
        return _openstudiomeasure.OSArgument_defaultValueAsPath(self)

    def hasDomain(self) -> "bool":
        return _openstudiomeasure.OSArgument_hasDomain(self)

    def domainType(self) -> "openstudio::measure::OSDomainType":
        return _openstudiomeasure.OSArgument_domainType(self)

    def domainAsBool(self) -> "std::vector< bool,std::allocator< bool > >":
        return _openstudiomeasure.OSArgument_domainAsBool(self)

    def domainAsDouble(self) -> "std::vector< double,std::allocator< double > >":
        return _openstudiomeasure.OSArgument_domainAsDouble(self)

    def domainAsInteger(self) -> "std::vector< int,std::allocator< int > >":
        return _openstudiomeasure.OSArgument_domainAsInteger(self)

    def domainAsString(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomeasure.OSArgument_domainAsString(self)

    def domainAsPath(self) -> "std::vector< openstudio::path,std::allocator< openstudio::path > >":
        return _openstudiomeasure.OSArgument_domainAsPath(self)

    def choiceValues(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomeasure.OSArgument_choiceValues(self)

    def choiceValueDisplayNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomeasure.OSArgument_choiceValueDisplayNames(self)

    def valueDisplayName(self) -> "std::string":
        return _openstudiomeasure.OSArgument_valueDisplayName(self)

    def defaultValueDisplayName(self) -> "std::string":
        return _openstudiomeasure.OSArgument_defaultValueDisplayName(self)

    def isRead(self) -> "bool":
        return _openstudiomeasure.OSArgument_isRead(self)

    def extension(self) -> "std::string":
        return _openstudiomeasure.OSArgument_extension(self)

    def setDisplayName(self, displayName: "std::string const &") -> "void":
        return _openstudiomeasure.OSArgument_setDisplayName(self, displayName)

    def setDescription(self, description: "std::string const &") -> "void":
        return _openstudiomeasure.OSArgument_setDescription(self, description)

    def setUnits(self, units: "std::string const &") -> "void":
        return _openstudiomeasure.OSArgument_setUnits(self, units)

    def setValue(self, *args) -> "bool":
        return _openstudiomeasure.OSArgument_setValue(self, *args)

    def clearValue(self) -> "void":
        return _openstudiomeasure.OSArgument_clearValue(self)

    def setDefaultValue(self, *args) -> "bool":
        return _openstudiomeasure.OSArgument_setDefaultValue(self, *args)

    def setDomainType(self, domainType: "OSDomainType") -> "bool":
        return _openstudiomeasure.OSArgument_setDomainType(self, domainType)

    def setDomain(self, *args) -> "bool":
        return _openstudiomeasure.OSArgument_setDomain(self, *args)

    def clearDomain(self) -> "void":
        return _openstudiomeasure.OSArgument_clearDomain(self)

    def setMinValue(self, *args) -> "bool":
        return _openstudiomeasure.OSArgument_setMinValue(self, *args)

    def setMaxValue(self, *args) -> "bool":
        return _openstudiomeasure.OSArgument_setMaxValue(self, *args)

    def _print(self) -> "std::string":
        return _openstudiomeasure.OSArgument__print(self)

    def printValue(self, printDefault: "bool"=True) -> "std::string":
        return _openstudiomeasure.OSArgument_printValue(self, printDefault)

    def printDefaultValue(self) -> "std::string":
        return _openstudiomeasure.OSArgument_printDefaultValue(self)

    def __str__(self) -> "std::string":
        return _openstudiomeasure.OSArgument___str__(self)
    __swig_destroy__ = _openstudiomeasure.delete_OSArgument

# Register OSArgument in _openstudiomeasure:
_openstudiomeasure.OSArgument_swigregister(OSArgument)

def OSArgument_makeBoolArgument(name: "std::string const &", required: "bool"=True, modelDependent: "bool"=False) -> "openstudio::measure::OSArgument":
    return _openstudiomeasure.OSArgument_makeBoolArgument(name, required, modelDependent)

def OSArgument_makeDoubleArgument(name: "std::string const &", required: "bool"=True, modelDependent: "bool"=False) -> "openstudio::measure::OSArgument":
    return _openstudiomeasure.OSArgument_makeDoubleArgument(name, required, modelDependent)

def OSArgument_makeIntegerArgument(name: "std::string const &", required: "bool"=True, modelDependent: "bool"=False) -> "openstudio::measure::OSArgument":
    return _openstudiomeasure.OSArgument_makeIntegerArgument(name, required, modelDependent)

def OSArgument_makeStringArgument(name: "std::string const &", required: "bool"=True, modelDependent: "bool"=False) -> "openstudio::measure::OSArgument":
    return _openstudiomeasure.OSArgument_makeStringArgument(name, required, modelDependent)

def OSArgument_makeChoiceArgument(*args) -> "openstudio::measure::OSArgument":
    return _openstudiomeasure.OSArgument_makeChoiceArgument(*args)

def OSArgument_makePathArgument(name: "std::string const &", isRead: "bool", extension: "std::string const &", required: "bool"=True, modelDependent: "bool"=False) -> "openstudio::measure::OSArgument":
    return _openstudiomeasure.OSArgument_makePathArgument(name, isRead, extension, required, modelDependent)

def OSArgument_makeSeparatorArgument(name: "std::string const &", modelDependent: "bool"=False) -> "openstudio::measure::OSArgument":
    return _openstudiomeasure.OSArgument_makeSeparatorArgument(name, modelDependent)


def makeChoiceArgumentOfWorkspaceObjects(*args) -> "openstudio::measure::OSArgument":
    return _openstudiomeasure.makeChoiceArgumentOfWorkspaceObjects(*args)

def convertOSArgumentVectorToMap(arguments: "OSArgumentVector") -> "std::map< std::string,openstudio::measure::OSArgument,std::less< std::string >,std::allocator< std::pair< std::string const,openstudio::measure::OSArgument > > >":
    return _openstudiomeasure.convertOSArgumentVectorToMap(arguments)
class OSOutputType(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomeasure.OSOutputType_swiginit(self, _openstudiomeasure.new_OSOutputType(*args))

    def valueName(self) -> "std::string":
        return _openstudiomeasure.OSOutputType_valueName(self)

    def value(self) -> "int":
        return _openstudiomeasure.OSOutputType_value(self)

    def valueDescription(self) -> "std::string":
        return _openstudiomeasure.OSOutputType_valueDescription(self)

    def __eq__(self, other: "OSOutputType") -> "bool":
        return _openstudiomeasure.OSOutputType___eq__(self, other)

    def __ne__(self, other: "OSOutputType") -> "bool":
        return _openstudiomeasure.OSOutputType___ne__(self, other)

    def __gt__(self, other: "OSOutputType") -> "bool":
        return _openstudiomeasure.OSOutputType___gt__(self, other)

    def __ge__(self, other: "OSOutputType") -> "bool":
        return _openstudiomeasure.OSOutputType___ge__(self, other)

    def __lt__(self, other: "OSOutputType") -> "bool":
        return _openstudiomeasure.OSOutputType___lt__(self, other)

    def __le__(self, other: "OSOutputType") -> "bool":
        return _openstudiomeasure.OSOutputType___le__(self, other)

    @staticmethod
    def enumName() -> "std::string":
        return _openstudiomeasure.OSOutputType_enumName()

    @staticmethod
    def getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
        return _openstudiomeasure.OSOutputType_getValues()

    def __str__(self) -> "std::string":
        return _openstudiomeasure.OSOutputType___str__(self)
    __swig_destroy__ = _openstudiomeasure.delete_OSOutputType

# Register OSOutputType in _openstudiomeasure:
_openstudiomeasure.OSOutputType_swigregister(OSOutputType)

def OSOutputType_enumName() -> "std::string":
    return _openstudiomeasure.OSOutputType_enumName()

def OSOutputType_getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
    return _openstudiomeasure.OSOutputType_getValues()

class OSOutput(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomeasure.OSOutput_swiginit(self, _openstudiomeasure.new_OSOutput(*args))

    @staticmethod
    def makeBoolOutput(name: "std::string const &", modelDependent: "bool"=False) -> "openstudio::measure::OSOutput":
        return _openstudiomeasure.OSOutput_makeBoolOutput(name, modelDependent)

    @staticmethod
    def makeDoubleOutput(name: "std::string const &", modelDependent: "bool"=False) -> "openstudio::measure::OSOutput":
        return _openstudiomeasure.OSOutput_makeDoubleOutput(name, modelDependent)

    @staticmethod
    def makeIntegerOutput(name: "std::string const &", modelDependent: "bool"=False) -> "openstudio::measure::OSOutput":
        return _openstudiomeasure.OSOutput_makeIntegerOutput(name, modelDependent)

    @staticmethod
    def makeStringOutput(name: "std::string const &", modelDependent: "bool"=False) -> "openstudio::measure::OSOutput":
        return _openstudiomeasure.OSOutput_makeStringOutput(name, modelDependent)

    def name(self) -> "std::string":
        return _openstudiomeasure.OSOutput_name(self)

    def displayName(self) -> "std::string":
        return _openstudiomeasure.OSOutput_displayName(self)

    def shortName(self) -> "std::string":
        return _openstudiomeasure.OSOutput_shortName(self)

    def description(self) -> "boost::optional< std::string >":
        return _openstudiomeasure.OSOutput_description(self)

    def type(self) -> "openstudio::measure::OSOutputType":
        return _openstudiomeasure.OSOutput_type(self)

    def units(self) -> "boost::optional< std::string >":
        return _openstudiomeasure.OSOutput_units(self)

    def modelDependent(self) -> "bool":
        return _openstudiomeasure.OSOutput_modelDependent(self)

    def setDisplayName(self, displayName: "std::string const &") -> "void":
        return _openstudiomeasure.OSOutput_setDisplayName(self, displayName)

    def setShortName(self, shortName: "std::string const &") -> "void":
        return _openstudiomeasure.OSOutput_setShortName(self, shortName)

    def setDescription(self, description: "std::string const &") -> "void":
        return _openstudiomeasure.OSOutput_setDescription(self, description)

    def setUnits(self, units: "std::string const &") -> "void":
        return _openstudiomeasure.OSOutput_setUnits(self, units)

    def _print(self) -> "std::string":
        return _openstudiomeasure.OSOutput__print(self)

    def __str__(self) -> "std::string":
        return _openstudiomeasure.OSOutput___str__(self)
    __swig_destroy__ = _openstudiomeasure.delete_OSOutput

# Register OSOutput in _openstudiomeasure:
_openstudiomeasure.OSOutput_swigregister(OSOutput)

def OSOutput_makeBoolOutput(name: "std::string const &", modelDependent: "bool"=False) -> "openstudio::measure::OSOutput":
    return _openstudiomeasure.OSOutput_makeBoolOutput(name, modelDependent)

def OSOutput_makeDoubleOutput(name: "std::string const &", modelDependent: "bool"=False) -> "openstudio::measure::OSOutput":
    return _openstudiomeasure.OSOutput_makeDoubleOutput(name, modelDependent)

def OSOutput_makeIntegerOutput(name: "std::string const &", modelDependent: "bool"=False) -> "openstudio::measure::OSOutput":
    return _openstudiomeasure.OSOutput_makeIntegerOutput(name, modelDependent)

def OSOutput_makeStringOutput(name: "std::string const &", modelDependent: "bool"=False) -> "openstudio::measure::OSOutput":
    return _openstudiomeasure.OSOutput_makeStringOutput(name, modelDependent)


def __lshift__(*args) -> "std::ostream &":
    return _openstudiomeasure.__lshift__(*args)
class OSRunner(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, workflow: "WorkflowJSON"):
        if self.__class__ == OSRunner:
            _self = None
        else:
            _self = self
        _openstudiomeasure.OSRunner_swiginit(self, _openstudiomeasure.new_OSRunner(_self, workflow))
    __swig_destroy__ = _openstudiomeasure.delete_OSRunner

    def workflow(self) -> "openstudio::WorkflowJSON":
        return _openstudiomeasure.OSRunner_workflow(self)

    def unitsPreference(self) -> "std::string":
        return _openstudiomeasure.OSRunner_unitsPreference(self)

    def languagePreference(self) -> "std::string":
        return _openstudiomeasure.OSRunner_languagePreference(self)

    def result(self) -> "openstudio::WorkflowStepResult":
        return _openstudiomeasure.OSRunner_result(self)

    def halted(self) -> "bool":
        return _openstudiomeasure.OSRunner_halted(self)

    def lastOpenStudioModel(self) -> "boost::optional< openstudio::model::Model >":
        return _openstudiomeasure.OSRunner_lastOpenStudioModel(self)

    def lastEnergyPlusWorkspace(self) -> "boost::optional< openstudio::Workspace >":
        return _openstudiomeasure.OSRunner_lastEnergyPlusWorkspace(self)

    def lastEnergyPlusSqlFile(self) -> "boost::optional< openstudio::SqlFile >":
        return _openstudiomeasure.OSRunner_lastEnergyPlusSqlFile(self)

    def lastEpwFile(self) -> "boost::optional< openstudio::EpwFile >":
        return _openstudiomeasure.OSRunner_lastEpwFile(self)

    def lastEpwFilePath(self) -> "boost::optional< openstudio::path >":
        return _openstudiomeasure.OSRunner_lastEpwFilePath(self)

    def inSelection(self, modelObject: "ModelObject") -> "bool":
        return _openstudiomeasure.OSRunner_inSelection(self, modelObject)

    def getUserInput(self, arguments: "OSArgumentVector") -> "std::map< std::string,openstudio::measure::OSArgument,std::less< std::string >,std::allocator< std::pair< std::string const,openstudio::measure::OSArgument > > >":
        return _openstudiomeasure.OSRunner_getUserInput(self, arguments)

    def prepareForMeasureRun(self, measure: "OSMeasure") -> "void":
        return _openstudiomeasure.OSRunner_prepareForMeasureRun(self, measure)

    def registerError(self, message: "std::string const &") -> "void":
        return _openstudiomeasure.OSRunner_registerError(self, message)

    def registerWarning(self, message: "std::string const &") -> "bool":
        return _openstudiomeasure.OSRunner_registerWarning(self, message)

    def registerInfo(self, message: "std::string const &") -> "bool":
        return _openstudiomeasure.OSRunner_registerInfo(self, message)

    def registerAsNotApplicable(self, message: "std::string const &") -> "void":
        return _openstudiomeasure.OSRunner_registerAsNotApplicable(self, message)

    def registerInitialCondition(self, message: "std::string const &") -> "void":
        return _openstudiomeasure.OSRunner_registerInitialCondition(self, message)

    def registerFinalCondition(self, message: "std::string const &") -> "void":
        return _openstudiomeasure.OSRunner_registerFinalCondition(self, message)

    def registerValue(self, *args) -> "void":
        return _openstudiomeasure.OSRunner_registerValue(self, *args)

    def haltWorkflow(self, *args) -> "void":
        return _openstudiomeasure.OSRunner_haltWorkflow(self, *args)

    def createProgressBar(self, text: "std::string const &") -> "void":
        return _openstudiomeasure.OSRunner_createProgressBar(self, text)

    def updateProgress(self, value: "double const &") -> "void":
        return _openstudiomeasure.OSRunner_updateProgress(self, value)

    def destroyProgressBar(self) -> "void":
        return _openstudiomeasure.OSRunner_destroyProgressBar(self)

    def validateUserArguments(self, script_arguments: "OSArgumentVector", user_arguments: "OSArgumentMap") -> "bool":
        return _openstudiomeasure.OSRunner_validateUserArguments(self, script_arguments, user_arguments)

    def getBoolArgumentValue(self, argument_name: "std::string const &", user_arguments: "OSArgumentMap") -> "bool":
        return _openstudiomeasure.OSRunner_getBoolArgumentValue(self, argument_name, user_arguments)

    def getDoubleArgumentValue(self, argument_name: "std::string const &", user_arguments: "OSArgumentMap") -> "double":
        return _openstudiomeasure.OSRunner_getDoubleArgumentValue(self, argument_name, user_arguments)

    def getOptionalDoubleArgumentValue(self, argument_name: "std::string const &", user_arguments: "OSArgumentMap") -> "boost::optional< double >":
        return _openstudiomeasure.OSRunner_getOptionalDoubleArgumentValue(self, argument_name, user_arguments)

    def getIntegerArgumentValue(self, argument_name: "std::string const &", user_arguments: "OSArgumentMap") -> "int":
        return _openstudiomeasure.OSRunner_getIntegerArgumentValue(self, argument_name, user_arguments)

    def getOptionalIntegerArgumentValue(self, argument_name: "std::string const &", user_arguments: "OSArgumentMap") -> "boost::optional< int >":
        return _openstudiomeasure.OSRunner_getOptionalIntegerArgumentValue(self, argument_name, user_arguments)

    def getStringArgumentValue(self, argument_name: "std::string const &", user_arguments: "OSArgumentMap") -> "std::string":
        return _openstudiomeasure.OSRunner_getStringArgumentValue(self, argument_name, user_arguments)

    def getOptionalStringArgumentValue(self, argument_name: "std::string const &", user_arguments: "OSArgumentMap") -> "boost::optional< std::string >":
        return _openstudiomeasure.OSRunner_getOptionalStringArgumentValue(self, argument_name, user_arguments)

    def getPathArgumentValue(self, argument_name: "std::string const &", user_arguments: "OSArgumentMap") -> "openstudio::path":
        return _openstudiomeasure.OSRunner_getPathArgumentValue(self, argument_name, user_arguments)

    def getOptionalPathArgumentValue(self, argument_name: "std::string const &", user_arguments: "OSArgumentMap") -> "boost::optional< openstudio::path >":
        return _openstudiomeasure.OSRunner_getOptionalPathArgumentValue(self, argument_name, user_arguments)

    def getOptionalWorkspaceObjectChoiceValue(self, argument_name: "std::string const &", user_arguments: "OSArgumentMap", workspace: "Workspace") -> "boost::optional< openstudio::WorkspaceObject >":
        return _openstudiomeasure.OSRunner_getOptionalWorkspaceObjectChoiceValue(self, argument_name, user_arguments, workspace)

    def reset(self) -> "void":
        return _openstudiomeasure.OSRunner_reset(self)

    def incrementStep(self) -> "bool":
        return _openstudiomeasure.OSRunner_incrementStep(self)

    def setLastOpenStudioModel(self, lastOpenStudioModel: "Model") -> "void":
        return _openstudiomeasure.OSRunner_setLastOpenStudioModel(self, lastOpenStudioModel)

    def resetLastOpenStudioModel(self) -> "void":
        return _openstudiomeasure.OSRunner_resetLastOpenStudioModel(self)

    def setLastOpenStudioModelPath(self, lastOpenStudioModelPath: "path") -> "void":
        return _openstudiomeasure.OSRunner_setLastOpenStudioModelPath(self, lastOpenStudioModelPath)

    def resetLastOpenStudioModelPath(self) -> "void":
        return _openstudiomeasure.OSRunner_resetLastOpenStudioModelPath(self)

    def setLastEnergyPlusWorkspace(self, lastEnergyPlusWorkspace: "Workspace") -> "void":
        return _openstudiomeasure.OSRunner_setLastEnergyPlusWorkspace(self, lastEnergyPlusWorkspace)

    def resetLastEnergyPlusWorkspace(self) -> "void":
        return _openstudiomeasure.OSRunner_resetLastEnergyPlusWorkspace(self)

    def setLastEnergyPlusWorkspacePath(self, lastEnergyPlusWorkspacePath: "path") -> "void":
        return _openstudiomeasure.OSRunner_setLastEnergyPlusWorkspacePath(self, lastEnergyPlusWorkspacePath)

    def resetLastEnergyPlusWorkspacePath(self) -> "void":
        return _openstudiomeasure.OSRunner_resetLastEnergyPlusWorkspacePath(self)

    def setLastEnergyPlusSqlFilePath(self, lastEnergyPlusSqlFilePath: "path") -> "void":
        return _openstudiomeasure.OSRunner_setLastEnergyPlusSqlFilePath(self, lastEnergyPlusSqlFilePath)

    def resetLastEnergyPlusSqlFilePath(self) -> "void":
        return _openstudiomeasure.OSRunner_resetLastEnergyPlusSqlFilePath(self)

    def setLastEpwFilePath(self, lastEpwFilePath: "path") -> "void":
        return _openstudiomeasure.OSRunner_setLastEpwFilePath(self, lastEpwFilePath)

    def resetLastEpwFilePath(self) -> "void":
        return _openstudiomeasure.OSRunner_resetLastEpwFilePath(self)

    def setUnitsPreference(self, unitsPreference: "std::string const &") -> "bool":
        return _openstudiomeasure.OSRunner_setUnitsPreference(self, unitsPreference)

    def resetUnitsPreference(self) -> "void":
        return _openstudiomeasure.OSRunner_resetUnitsPreference(self)

    def setLanguagePreference(self, languagePreference: "std::string const &") -> "bool":
        return _openstudiomeasure.OSRunner_setLanguagePreference(self, languagePreference)

    def resetLanguagePreference(self) -> "void":
        return _openstudiomeasure.OSRunner_resetLanguagePreference(self)
    def __disown__(self):
        self.this.disown()
        _openstudiomeasure.disown_OSRunner(self)
        return weakref.proxy(self)

# Register OSRunner in _openstudiomeasure:
_openstudiomeasure.OSRunner_swigregister(OSRunner)

class OSMeasure(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomeasure.delete_OSMeasure

    def name(self) -> "std::string":
        return _openstudiomeasure.OSMeasure_name(self)

    def description(self) -> "std::string":
        return _openstudiomeasure.OSMeasure_description(self)

    def taxonomy(self) -> "std::string":
        return _openstudiomeasure.OSMeasure_taxonomy(self)

    def modeler_description(self) -> "std::string":
        return _openstudiomeasure.OSMeasure_modeler_description(self)

    def registerWithSketchUp(self) -> "bool":
        return _openstudiomeasure.OSMeasure_registerWithSketchUp(self)

    def registerWithApplication(self) -> "bool":
        return _openstudiomeasure.OSMeasure_registerWithApplication(self)

    def __init__(self):
        if self.__class__ == OSMeasure:
            _self = None
        else:
            _self = self
        _openstudiomeasure.OSMeasure_swiginit(self, _openstudiomeasure.new_OSMeasure(_self, ))
    def __disown__(self):
        self.this.disown()
        _openstudiomeasure.disown_OSMeasure(self)
        return weakref.proxy(self)

# Register OSMeasure in _openstudiomeasure:
_openstudiomeasure.OSMeasure_swigregister(OSMeasure)

class ModelMeasure(OSMeasure):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomeasure.delete_ModelMeasure

    def arguments(self, model: "Model") -> "std::vector< openstudio::measure::OSArgument,std::allocator< openstudio::measure::OSArgument > >":
        return _openstudiomeasure.ModelMeasure_arguments(self, model)

    def outputs(self) -> "std::vector< openstudio::measure::OSOutput,std::allocator< openstudio::measure::OSOutput > >":
        return _openstudiomeasure.ModelMeasure_outputs(self)

    def run(self, model: "Model", runner: "OSRunner", user_arguments: "OSArgumentMap") -> "bool":
        return _openstudiomeasure.ModelMeasure_run(self, model, runner, user_arguments)

    def __init__(self):
        if self.__class__ == ModelMeasure:
            _self = None
        else:
            _self = self
        _openstudiomeasure.ModelMeasure_swiginit(self, _openstudiomeasure.new_ModelMeasure(_self, ))
    def __disown__(self):
        self.this.disown()
        _openstudiomeasure.disown_ModelMeasure(self)
        return weakref.proxy(self)

# Register ModelMeasure in _openstudiomeasure:
_openstudiomeasure.ModelMeasure_swigregister(ModelMeasure)

class EnergyPlusMeasure(OSMeasure):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomeasure.delete_EnergyPlusMeasure

    def arguments(self, workspace: "Workspace") -> "std::vector< openstudio::measure::OSArgument,std::allocator< openstudio::measure::OSArgument > >":
        return _openstudiomeasure.EnergyPlusMeasure_arguments(self, workspace)

    def outputs(self) -> "std::vector< openstudio::measure::OSOutput,std::allocator< openstudio::measure::OSOutput > >":
        return _openstudiomeasure.EnergyPlusMeasure_outputs(self)

    def run(self, workspace: "Workspace", runner: "OSRunner", user_arguments: "OSArgumentMap") -> "bool":
        return _openstudiomeasure.EnergyPlusMeasure_run(self, workspace, runner, user_arguments)

    def __init__(self):
        if self.__class__ == EnergyPlusMeasure:
            _self = None
        else:
            _self = self
        _openstudiomeasure.EnergyPlusMeasure_swiginit(self, _openstudiomeasure.new_EnergyPlusMeasure(_self, ))
    def __disown__(self):
        self.this.disown()
        _openstudiomeasure.disown_EnergyPlusMeasure(self)
        return weakref.proxy(self)

# Register EnergyPlusMeasure in _openstudiomeasure:
_openstudiomeasure.EnergyPlusMeasure_swigregister(EnergyPlusMeasure)

class ReportingMeasure(OSMeasure):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomeasure.delete_ReportingMeasure

    def arguments(self, model: "Model") -> "std::vector< openstudio::measure::OSArgument,std::allocator< openstudio::measure::OSArgument > >":
        return _openstudiomeasure.ReportingMeasure_arguments(self, model)

    def outputs(self) -> "std::vector< openstudio::measure::OSOutput,std::allocator< openstudio::measure::OSOutput > >":
        return _openstudiomeasure.ReportingMeasure_outputs(self)

    def run(self, runner: "OSRunner", user_arguments: "OSArgumentMap") -> "bool":
        return _openstudiomeasure.ReportingMeasure_run(self, runner, user_arguments)

    def energyPlusOutputRequests(self, runner: "OSRunner", user_arguments: "OSArgumentMap") -> "std::vector< openstudio::IdfObject,std::allocator< openstudio::IdfObject > >":
        return _openstudiomeasure.ReportingMeasure_energyPlusOutputRequests(self, runner, user_arguments)

    def __init__(self):
        if self.__class__ == ReportingMeasure:
            _self = None
        else:
            _self = self
        _openstudiomeasure.ReportingMeasure_swiginit(self, _openstudiomeasure.new_ReportingMeasure(_self, ))
    def __disown__(self):
        self.this.disown()
        _openstudiomeasure.disown_ReportingMeasure(self)
        return weakref.proxy(self)

# Register ReportingMeasure in _openstudiomeasure:
_openstudiomeasure.ReportingMeasure_swigregister(ReportingMeasure)



