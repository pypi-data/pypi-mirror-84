# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _openstudioutilitiesdata
else:
    import _openstudioutilitiesdata

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudioutilitiesdata.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _openstudioutilitiesdata.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _openstudioutilitiesdata.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _openstudioutilitiesdata.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _openstudioutilitiesdata.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _openstudioutilitiesdata.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _openstudioutilitiesdata.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _openstudioutilitiesdata.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _openstudioutilitiesdata.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _openstudioutilitiesdata.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _openstudioutilitiesdata.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _openstudioutilitiesdata.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _openstudioutilitiesdata:
_openstudioutilitiesdata.SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _openstudioutilitiesdata.SHARED_PTR_DISOWN
from .import openstudioutilitiestime
from .import openstudioutilitiescore
from .import openstudioutilitiesunits
class InstallLocationTypeVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.InstallLocationTypeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.InstallLocationTypeVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.InstallLocationTypeVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::InstallLocationType >::size_type":
        return _openstudioutilitiesdata.InstallLocationTypeVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::InstallLocationType >::difference_type", j: "std::vector< openstudio::InstallLocationType >::difference_type") -> "std::vector< openstudio::InstallLocationType,std::allocator< openstudio::InstallLocationType > > *":
        return _openstudioutilitiesdata.InstallLocationTypeVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.InstallLocationTypeVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::InstallLocationType >::difference_type", j: "std::vector< openstudio::InstallLocationType >::difference_type") -> "void":
        return _openstudioutilitiesdata.InstallLocationTypeVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.InstallLocationTypeVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::InstallLocationType >::value_type const &":
        return _openstudioutilitiesdata.InstallLocationTypeVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.InstallLocationTypeVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::InstallLocationType >::value_type":
        return _openstudioutilitiesdata.InstallLocationTypeVector_pop(self)

    def append(self, x: "InstallLocationType") -> "void":
        return _openstudioutilitiesdata.InstallLocationTypeVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.InstallLocationTypeVector_empty(self)

    def size(self) -> "std::vector< openstudio::InstallLocationType >::size_type":
        return _openstudioutilitiesdata.InstallLocationTypeVector_size(self)

    def swap(self, v: "InstallLocationTypeVector") -> "void":
        return _openstudioutilitiesdata.InstallLocationTypeVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::InstallLocationType >::iterator":
        return _openstudioutilitiesdata.InstallLocationTypeVector_begin(self)

    def end(self) -> "std::vector< openstudio::InstallLocationType >::iterator":
        return _openstudioutilitiesdata.InstallLocationTypeVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::InstallLocationType >::reverse_iterator":
        return _openstudioutilitiesdata.InstallLocationTypeVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::InstallLocationType >::reverse_iterator":
        return _openstudioutilitiesdata.InstallLocationTypeVector_rend(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.InstallLocationTypeVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::InstallLocationType >::allocator_type":
        return _openstudioutilitiesdata.InstallLocationTypeVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.InstallLocationTypeVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::InstallLocationType >::iterator":
        return _openstudioutilitiesdata.InstallLocationTypeVector_erase(self, *args)

    def __init__(self, *args):
        _openstudioutilitiesdata.InstallLocationTypeVector_swiginit(self, _openstudioutilitiesdata.new_InstallLocationTypeVector(*args))

    def push_back(self, x: "InstallLocationType") -> "void":
        return _openstudioutilitiesdata.InstallLocationTypeVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::InstallLocationType >::value_type const &":
        return _openstudioutilitiesdata.InstallLocationTypeVector_front(self)

    def back(self) -> "std::vector< openstudio::InstallLocationType >::value_type const &":
        return _openstudioutilitiesdata.InstallLocationTypeVector_back(self)

    def assign(self, n: "std::vector< openstudio::InstallLocationType >::size_type", x: "InstallLocationType") -> "void":
        return _openstudioutilitiesdata.InstallLocationTypeVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudioutilitiesdata.InstallLocationTypeVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.InstallLocationTypeVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::InstallLocationType >::size_type") -> "void":
        return _openstudioutilitiesdata.InstallLocationTypeVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::InstallLocationType >::size_type":
        return _openstudioutilitiesdata.InstallLocationTypeVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_InstallLocationTypeVector

# Register InstallLocationTypeVector in _openstudioutilitiesdata:
_openstudioutilitiesdata.InstallLocationTypeVector_swigregister(InstallLocationTypeVector)

class OptionalInstallLocationType(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudioutilitiesdata.OptionalInstallLocationType_swiginit(self, _openstudioutilitiesdata.new_OptionalInstallLocationType(*args))

    def reset(self) -> "void":
        return _openstudioutilitiesdata.OptionalInstallLocationType_reset(self)

    def __ref__(self) -> "openstudio::InstallLocationType":
        return _openstudioutilitiesdata.OptionalInstallLocationType___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudioutilitiesdata.OptionalInstallLocationType_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudioutilitiesdata.OptionalInstallLocationType_isNull(self)

    def get(self) -> "openstudio::InstallLocationType":
        return _openstudioutilitiesdata.OptionalInstallLocationType_get(self)

    def set(self, t: "InstallLocationType") -> "void":
        return _openstudioutilitiesdata.OptionalInstallLocationType_set(self, t)
    __swig_destroy__ = _openstudioutilitiesdata.delete_OptionalInstallLocationType

# Register OptionalInstallLocationType in _openstudioutilitiesdata:
_openstudioutilitiesdata.OptionalInstallLocationType_swigregister(OptionalInstallLocationType)

class FuelTypeVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.FuelTypeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.FuelTypeVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.FuelTypeVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::FuelType >::size_type":
        return _openstudioutilitiesdata.FuelTypeVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::FuelType >::difference_type", j: "std::vector< openstudio::FuelType >::difference_type") -> "std::vector< openstudio::FuelType,std::allocator< openstudio::FuelType > > *":
        return _openstudioutilitiesdata.FuelTypeVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.FuelTypeVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::FuelType >::difference_type", j: "std::vector< openstudio::FuelType >::difference_type") -> "void":
        return _openstudioutilitiesdata.FuelTypeVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.FuelTypeVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::FuelType >::value_type const &":
        return _openstudioutilitiesdata.FuelTypeVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.FuelTypeVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::FuelType >::value_type":
        return _openstudioutilitiesdata.FuelTypeVector_pop(self)

    def append(self, x: "FuelType") -> "void":
        return _openstudioutilitiesdata.FuelTypeVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.FuelTypeVector_empty(self)

    def size(self) -> "std::vector< openstudio::FuelType >::size_type":
        return _openstudioutilitiesdata.FuelTypeVector_size(self)

    def swap(self, v: "FuelTypeVector") -> "void":
        return _openstudioutilitiesdata.FuelTypeVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::FuelType >::iterator":
        return _openstudioutilitiesdata.FuelTypeVector_begin(self)

    def end(self) -> "std::vector< openstudio::FuelType >::iterator":
        return _openstudioutilitiesdata.FuelTypeVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::FuelType >::reverse_iterator":
        return _openstudioutilitiesdata.FuelTypeVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::FuelType >::reverse_iterator":
        return _openstudioutilitiesdata.FuelTypeVector_rend(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.FuelTypeVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::FuelType >::allocator_type":
        return _openstudioutilitiesdata.FuelTypeVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.FuelTypeVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::FuelType >::iterator":
        return _openstudioutilitiesdata.FuelTypeVector_erase(self, *args)

    def __init__(self, *args):
        _openstudioutilitiesdata.FuelTypeVector_swiginit(self, _openstudioutilitiesdata.new_FuelTypeVector(*args))

    def push_back(self, x: "FuelType") -> "void":
        return _openstudioutilitiesdata.FuelTypeVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::FuelType >::value_type const &":
        return _openstudioutilitiesdata.FuelTypeVector_front(self)

    def back(self) -> "std::vector< openstudio::FuelType >::value_type const &":
        return _openstudioutilitiesdata.FuelTypeVector_back(self)

    def assign(self, n: "std::vector< openstudio::FuelType >::size_type", x: "FuelType") -> "void":
        return _openstudioutilitiesdata.FuelTypeVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudioutilitiesdata.FuelTypeVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.FuelTypeVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::FuelType >::size_type") -> "void":
        return _openstudioutilitiesdata.FuelTypeVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::FuelType >::size_type":
        return _openstudioutilitiesdata.FuelTypeVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_FuelTypeVector

# Register FuelTypeVector in _openstudioutilitiesdata:
_openstudioutilitiesdata.FuelTypeVector_swigregister(FuelTypeVector)

class OptionalFuelType(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudioutilitiesdata.OptionalFuelType_swiginit(self, _openstudioutilitiesdata.new_OptionalFuelType(*args))

    def reset(self) -> "void":
        return _openstudioutilitiesdata.OptionalFuelType_reset(self)

    def __ref__(self) -> "openstudio::FuelType":
        return _openstudioutilitiesdata.OptionalFuelType___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudioutilitiesdata.OptionalFuelType_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudioutilitiesdata.OptionalFuelType_isNull(self)

    def get(self) -> "openstudio::FuelType":
        return _openstudioutilitiesdata.OptionalFuelType_get(self)

    def set(self, t: "FuelType") -> "void":
        return _openstudioutilitiesdata.OptionalFuelType_set(self, t)
    __swig_destroy__ = _openstudioutilitiesdata.delete_OptionalFuelType

# Register OptionalFuelType in _openstudioutilitiesdata:
_openstudioutilitiesdata.OptionalFuelType_swigregister(OptionalFuelType)

class EndUseFuelTypeVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.EndUseFuelTypeVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.EndUseFuelTypeVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::EndUseFuelType >::size_type":
        return _openstudioutilitiesdata.EndUseFuelTypeVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::EndUseFuelType >::difference_type", j: "std::vector< openstudio::EndUseFuelType >::difference_type") -> "std::vector< openstudio::EndUseFuelType,std::allocator< openstudio::EndUseFuelType > > *":
        return _openstudioutilitiesdata.EndUseFuelTypeVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseFuelTypeVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::EndUseFuelType >::difference_type", j: "std::vector< openstudio::EndUseFuelType >::difference_type") -> "void":
        return _openstudioutilitiesdata.EndUseFuelTypeVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseFuelTypeVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::EndUseFuelType >::value_type const &":
        return _openstudioutilitiesdata.EndUseFuelTypeVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseFuelTypeVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::EndUseFuelType >::value_type":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_pop(self)

    def append(self, x: "EndUseFuelType") -> "void":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_empty(self)

    def size(self) -> "std::vector< openstudio::EndUseFuelType >::size_type":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_size(self)

    def swap(self, v: "EndUseFuelTypeVector") -> "void":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::EndUseFuelType >::iterator":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_begin(self)

    def end(self) -> "std::vector< openstudio::EndUseFuelType >::iterator":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::EndUseFuelType >::reverse_iterator":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::EndUseFuelType >::reverse_iterator":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_rend(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::EndUseFuelType >::allocator_type":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::EndUseFuelType >::iterator":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_erase(self, *args)

    def __init__(self, *args):
        _openstudioutilitiesdata.EndUseFuelTypeVector_swiginit(self, _openstudioutilitiesdata.new_EndUseFuelTypeVector(*args))

    def push_back(self, x: "EndUseFuelType") -> "void":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::EndUseFuelType >::value_type const &":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_front(self)

    def back(self) -> "std::vector< openstudio::EndUseFuelType >::value_type const &":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_back(self)

    def assign(self, n: "std::vector< openstudio::EndUseFuelType >::size_type", x: "EndUseFuelType") -> "void":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::EndUseFuelType >::size_type") -> "void":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::EndUseFuelType >::size_type":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_EndUseFuelTypeVector

# Register EndUseFuelTypeVector in _openstudioutilitiesdata:
_openstudioutilitiesdata.EndUseFuelTypeVector_swigregister(EndUseFuelTypeVector)

class OptionalEndUseFuelType(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudioutilitiesdata.OptionalEndUseFuelType_swiginit(self, _openstudioutilitiesdata.new_OptionalEndUseFuelType(*args))

    def reset(self) -> "void":
        return _openstudioutilitiesdata.OptionalEndUseFuelType_reset(self)

    def __ref__(self) -> "openstudio::EndUseFuelType":
        return _openstudioutilitiesdata.OptionalEndUseFuelType___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudioutilitiesdata.OptionalEndUseFuelType_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudioutilitiesdata.OptionalEndUseFuelType_isNull(self)

    def get(self) -> "openstudio::EndUseFuelType":
        return _openstudioutilitiesdata.OptionalEndUseFuelType_get(self)

    def set(self, t: "EndUseFuelType") -> "void":
        return _openstudioutilitiesdata.OptionalEndUseFuelType_set(self, t)
    __swig_destroy__ = _openstudioutilitiesdata.delete_OptionalEndUseFuelType

# Register OptionalEndUseFuelType in _openstudioutilitiesdata:
_openstudioutilitiesdata.OptionalEndUseFuelType_swigregister(OptionalEndUseFuelType)

class EndUseCategoryTypeVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::EndUseCategoryType >::size_type":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::EndUseCategoryType >::difference_type", j: "std::vector< openstudio::EndUseCategoryType >::difference_type") -> "std::vector< openstudio::EndUseCategoryType,std::allocator< openstudio::EndUseCategoryType > > *":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::EndUseCategoryType >::difference_type", j: "std::vector< openstudio::EndUseCategoryType >::difference_type") -> "void":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::EndUseCategoryType >::value_type const &":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::EndUseCategoryType >::value_type":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_pop(self)

    def append(self, x: "EndUseCategoryType") -> "void":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_empty(self)

    def size(self) -> "std::vector< openstudio::EndUseCategoryType >::size_type":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_size(self)

    def swap(self, v: "EndUseCategoryTypeVector") -> "void":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::EndUseCategoryType >::iterator":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_begin(self)

    def end(self) -> "std::vector< openstudio::EndUseCategoryType >::iterator":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::EndUseCategoryType >::reverse_iterator":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::EndUseCategoryType >::reverse_iterator":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_rend(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::EndUseCategoryType >::allocator_type":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::EndUseCategoryType >::iterator":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_erase(self, *args)

    def __init__(self, *args):
        _openstudioutilitiesdata.EndUseCategoryTypeVector_swiginit(self, _openstudioutilitiesdata.new_EndUseCategoryTypeVector(*args))

    def push_back(self, x: "EndUseCategoryType") -> "void":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::EndUseCategoryType >::value_type const &":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_front(self)

    def back(self) -> "std::vector< openstudio::EndUseCategoryType >::value_type const &":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_back(self)

    def assign(self, n: "std::vector< openstudio::EndUseCategoryType >::size_type", x: "EndUseCategoryType") -> "void":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::EndUseCategoryType >::size_type") -> "void":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::EndUseCategoryType >::size_type":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_EndUseCategoryTypeVector

# Register EndUseCategoryTypeVector in _openstudioutilitiesdata:
_openstudioutilitiesdata.EndUseCategoryTypeVector_swigregister(EndUseCategoryTypeVector)

class OptionalEndUseCategoryType(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudioutilitiesdata.OptionalEndUseCategoryType_swiginit(self, _openstudioutilitiesdata.new_OptionalEndUseCategoryType(*args))

    def reset(self) -> "void":
        return _openstudioutilitiesdata.OptionalEndUseCategoryType_reset(self)

    def __ref__(self) -> "openstudio::EndUseCategoryType":
        return _openstudioutilitiesdata.OptionalEndUseCategoryType___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudioutilitiesdata.OptionalEndUseCategoryType_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudioutilitiesdata.OptionalEndUseCategoryType_isNull(self)

    def get(self) -> "openstudio::EndUseCategoryType":
        return _openstudioutilitiesdata.OptionalEndUseCategoryType_get(self)

    def set(self, t: "EndUseCategoryType") -> "void":
        return _openstudioutilitiesdata.OptionalEndUseCategoryType_set(self, t)
    __swig_destroy__ = _openstudioutilitiesdata.delete_OptionalEndUseCategoryType

# Register OptionalEndUseCategoryType in _openstudioutilitiesdata:
_openstudioutilitiesdata.OptionalEndUseCategoryType_swigregister(OptionalEndUseCategoryType)

class EndUseTypeVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.EndUseTypeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.EndUseTypeVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.EndUseTypeVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::EndUseType >::size_type":
        return _openstudioutilitiesdata.EndUseTypeVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::EndUseType >::difference_type", j: "std::vector< openstudio::EndUseType >::difference_type") -> "std::vector< openstudio::EndUseType,std::allocator< openstudio::EndUseType > > *":
        return _openstudioutilitiesdata.EndUseTypeVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseTypeVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::EndUseType >::difference_type", j: "std::vector< openstudio::EndUseType >::difference_type") -> "void":
        return _openstudioutilitiesdata.EndUseTypeVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseTypeVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::EndUseType >::value_type const &":
        return _openstudioutilitiesdata.EndUseTypeVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseTypeVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::EndUseType >::value_type":
        return _openstudioutilitiesdata.EndUseTypeVector_pop(self)

    def append(self, x: "EndUseType") -> "void":
        return _openstudioutilitiesdata.EndUseTypeVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.EndUseTypeVector_empty(self)

    def size(self) -> "std::vector< openstudio::EndUseType >::size_type":
        return _openstudioutilitiesdata.EndUseTypeVector_size(self)

    def swap(self, v: "EndUseTypeVector") -> "void":
        return _openstudioutilitiesdata.EndUseTypeVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::EndUseType >::iterator":
        return _openstudioutilitiesdata.EndUseTypeVector_begin(self)

    def end(self) -> "std::vector< openstudio::EndUseType >::iterator":
        return _openstudioutilitiesdata.EndUseTypeVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::EndUseType >::reverse_iterator":
        return _openstudioutilitiesdata.EndUseTypeVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::EndUseType >::reverse_iterator":
        return _openstudioutilitiesdata.EndUseTypeVector_rend(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.EndUseTypeVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::EndUseType >::allocator_type":
        return _openstudioutilitiesdata.EndUseTypeVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.EndUseTypeVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::EndUseType >::iterator":
        return _openstudioutilitiesdata.EndUseTypeVector_erase(self, *args)

    def __init__(self, *args):
        _openstudioutilitiesdata.EndUseTypeVector_swiginit(self, _openstudioutilitiesdata.new_EndUseTypeVector(*args))

    def push_back(self, x: "EndUseType") -> "void":
        return _openstudioutilitiesdata.EndUseTypeVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::EndUseType >::value_type const &":
        return _openstudioutilitiesdata.EndUseTypeVector_front(self)

    def back(self) -> "std::vector< openstudio::EndUseType >::value_type const &":
        return _openstudioutilitiesdata.EndUseTypeVector_back(self)

    def assign(self, n: "std::vector< openstudio::EndUseType >::size_type", x: "EndUseType") -> "void":
        return _openstudioutilitiesdata.EndUseTypeVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseTypeVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseTypeVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::EndUseType >::size_type") -> "void":
        return _openstudioutilitiesdata.EndUseTypeVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::EndUseType >::size_type":
        return _openstudioutilitiesdata.EndUseTypeVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_EndUseTypeVector

# Register EndUseTypeVector in _openstudioutilitiesdata:
_openstudioutilitiesdata.EndUseTypeVector_swigregister(EndUseTypeVector)

class OptionalEndUseType(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudioutilitiesdata.OptionalEndUseType_swiginit(self, _openstudioutilitiesdata.new_OptionalEndUseType(*args))

    def reset(self) -> "void":
        return _openstudioutilitiesdata.OptionalEndUseType_reset(self)

    def __ref__(self) -> "openstudio::EndUseType":
        return _openstudioutilitiesdata.OptionalEndUseType___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudioutilitiesdata.OptionalEndUseType_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudioutilitiesdata.OptionalEndUseType_isNull(self)

    def get(self) -> "openstudio::EndUseType":
        return _openstudioutilitiesdata.OptionalEndUseType_get(self)

    def set(self, t: "EndUseType") -> "void":
        return _openstudioutilitiesdata.OptionalEndUseType_set(self, t)
    __swig_destroy__ = _openstudioutilitiesdata.delete_OptionalEndUseType

# Register OptionalEndUseType in _openstudioutilitiesdata:
_openstudioutilitiesdata.OptionalEndUseType_swigregister(OptionalEndUseType)

class BuildingSectorVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.BuildingSectorVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.BuildingSectorVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.BuildingSectorVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::BuildingSector >::size_type":
        return _openstudioutilitiesdata.BuildingSectorVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::BuildingSector >::difference_type", j: "std::vector< openstudio::BuildingSector >::difference_type") -> "std::vector< openstudio::BuildingSector,std::allocator< openstudio::BuildingSector > > *":
        return _openstudioutilitiesdata.BuildingSectorVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.BuildingSectorVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::BuildingSector >::difference_type", j: "std::vector< openstudio::BuildingSector >::difference_type") -> "void":
        return _openstudioutilitiesdata.BuildingSectorVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.BuildingSectorVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::BuildingSector >::value_type const &":
        return _openstudioutilitiesdata.BuildingSectorVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.BuildingSectorVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::BuildingSector >::value_type":
        return _openstudioutilitiesdata.BuildingSectorVector_pop(self)

    def append(self, x: "BuildingSector") -> "void":
        return _openstudioutilitiesdata.BuildingSectorVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.BuildingSectorVector_empty(self)

    def size(self) -> "std::vector< openstudio::BuildingSector >::size_type":
        return _openstudioutilitiesdata.BuildingSectorVector_size(self)

    def swap(self, v: "BuildingSectorVector") -> "void":
        return _openstudioutilitiesdata.BuildingSectorVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::BuildingSector >::iterator":
        return _openstudioutilitiesdata.BuildingSectorVector_begin(self)

    def end(self) -> "std::vector< openstudio::BuildingSector >::iterator":
        return _openstudioutilitiesdata.BuildingSectorVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::BuildingSector >::reverse_iterator":
        return _openstudioutilitiesdata.BuildingSectorVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::BuildingSector >::reverse_iterator":
        return _openstudioutilitiesdata.BuildingSectorVector_rend(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.BuildingSectorVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::BuildingSector >::allocator_type":
        return _openstudioutilitiesdata.BuildingSectorVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.BuildingSectorVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::BuildingSector >::iterator":
        return _openstudioutilitiesdata.BuildingSectorVector_erase(self, *args)

    def __init__(self, *args):
        _openstudioutilitiesdata.BuildingSectorVector_swiginit(self, _openstudioutilitiesdata.new_BuildingSectorVector(*args))

    def push_back(self, x: "BuildingSector") -> "void":
        return _openstudioutilitiesdata.BuildingSectorVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::BuildingSector >::value_type const &":
        return _openstudioutilitiesdata.BuildingSectorVector_front(self)

    def back(self) -> "std::vector< openstudio::BuildingSector >::value_type const &":
        return _openstudioutilitiesdata.BuildingSectorVector_back(self)

    def assign(self, n: "std::vector< openstudio::BuildingSector >::size_type", x: "BuildingSector") -> "void":
        return _openstudioutilitiesdata.BuildingSectorVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudioutilitiesdata.BuildingSectorVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.BuildingSectorVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::BuildingSector >::size_type") -> "void":
        return _openstudioutilitiesdata.BuildingSectorVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::BuildingSector >::size_type":
        return _openstudioutilitiesdata.BuildingSectorVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_BuildingSectorVector

# Register BuildingSectorVector in _openstudioutilitiesdata:
_openstudioutilitiesdata.BuildingSectorVector_swigregister(BuildingSectorVector)

class OptionalBuildingSector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudioutilitiesdata.OptionalBuildingSector_swiginit(self, _openstudioutilitiesdata.new_OptionalBuildingSector(*args))

    def reset(self) -> "void":
        return _openstudioutilitiesdata.OptionalBuildingSector_reset(self)

    def __ref__(self) -> "openstudio::BuildingSector":
        return _openstudioutilitiesdata.OptionalBuildingSector___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudioutilitiesdata.OptionalBuildingSector_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudioutilitiesdata.OptionalBuildingSector_isNull(self)

    def get(self) -> "openstudio::BuildingSector":
        return _openstudioutilitiesdata.OptionalBuildingSector_get(self)

    def set(self, t: "BuildingSector") -> "void":
        return _openstudioutilitiesdata.OptionalBuildingSector_set(self, t)
    __swig_destroy__ = _openstudioutilitiesdata.delete_OptionalBuildingSector

# Register OptionalBuildingSector in _openstudioutilitiesdata:
_openstudioutilitiesdata.OptionalBuildingSector_swigregister(OptionalBuildingSector)

class InstallLocationType(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudioutilitiesdata.InstallLocationType_swiginit(self, _openstudioutilitiesdata.new_InstallLocationType(*args))

    def valueName(self) -> "std::string":
        return _openstudioutilitiesdata.InstallLocationType_valueName(self)

    def value(self) -> "int":
        return _openstudioutilitiesdata.InstallLocationType_value(self)

    def valueDescription(self) -> "std::string":
        return _openstudioutilitiesdata.InstallLocationType_valueDescription(self)

    def __eq__(self, other: "InstallLocationType") -> "bool":
        return _openstudioutilitiesdata.InstallLocationType___eq__(self, other)

    def __ne__(self, other: "InstallLocationType") -> "bool":
        return _openstudioutilitiesdata.InstallLocationType___ne__(self, other)

    def __gt__(self, other: "InstallLocationType") -> "bool":
        return _openstudioutilitiesdata.InstallLocationType___gt__(self, other)

    def __ge__(self, other: "InstallLocationType") -> "bool":
        return _openstudioutilitiesdata.InstallLocationType___ge__(self, other)

    def __lt__(self, other: "InstallLocationType") -> "bool":
        return _openstudioutilitiesdata.InstallLocationType___lt__(self, other)

    def __le__(self, other: "InstallLocationType") -> "bool":
        return _openstudioutilitiesdata.InstallLocationType___le__(self, other)

    @staticmethod
    def enumName() -> "std::string":
        return _openstudioutilitiesdata.InstallLocationType_enumName()

    @staticmethod
    def getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
        return _openstudioutilitiesdata.InstallLocationType_getValues()

    def __str__(self) -> "std::string":
        return _openstudioutilitiesdata.InstallLocationType___str__(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_InstallLocationType

# Register InstallLocationType in _openstudioutilitiesdata:
_openstudioutilitiesdata.InstallLocationType_swigregister(InstallLocationType)

def InstallLocationType_enumName() -> "std::string":
    return _openstudioutilitiesdata.InstallLocationType_enumName()

def InstallLocationType_getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
    return _openstudioutilitiesdata.InstallLocationType_getValues()

class FuelType(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudioutilitiesdata.FuelType_swiginit(self, _openstudioutilitiesdata.new_FuelType(*args))

    def valueName(self) -> "std::string":
        return _openstudioutilitiesdata.FuelType_valueName(self)

    def value(self) -> "int":
        return _openstudioutilitiesdata.FuelType_value(self)

    def valueDescription(self) -> "std::string":
        return _openstudioutilitiesdata.FuelType_valueDescription(self)

    def __eq__(self, other: "FuelType") -> "bool":
        return _openstudioutilitiesdata.FuelType___eq__(self, other)

    def __ne__(self, other: "FuelType") -> "bool":
        return _openstudioutilitiesdata.FuelType___ne__(self, other)

    def __gt__(self, other: "FuelType") -> "bool":
        return _openstudioutilitiesdata.FuelType___gt__(self, other)

    def __ge__(self, other: "FuelType") -> "bool":
        return _openstudioutilitiesdata.FuelType___ge__(self, other)

    def __lt__(self, other: "FuelType") -> "bool":
        return _openstudioutilitiesdata.FuelType___lt__(self, other)

    def __le__(self, other: "FuelType") -> "bool":
        return _openstudioutilitiesdata.FuelType___le__(self, other)

    @staticmethod
    def enumName() -> "std::string":
        return _openstudioutilitiesdata.FuelType_enumName()

    @staticmethod
    def getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
        return _openstudioutilitiesdata.FuelType_getValues()

    def __str__(self) -> "std::string":
        return _openstudioutilitiesdata.FuelType___str__(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_FuelType

# Register FuelType in _openstudioutilitiesdata:
_openstudioutilitiesdata.FuelType_swigregister(FuelType)

def FuelType_enumName() -> "std::string":
    return _openstudioutilitiesdata.FuelType_enumName()

def FuelType_getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
    return _openstudioutilitiesdata.FuelType_getValues()

class EndUseFuelType(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudioutilitiesdata.EndUseFuelType_swiginit(self, _openstudioutilitiesdata.new_EndUseFuelType(*args))

    def valueName(self) -> "std::string":
        return _openstudioutilitiesdata.EndUseFuelType_valueName(self)

    def value(self) -> "int":
        return _openstudioutilitiesdata.EndUseFuelType_value(self)

    def valueDescription(self) -> "std::string":
        return _openstudioutilitiesdata.EndUseFuelType_valueDescription(self)

    def __eq__(self, other: "EndUseFuelType") -> "bool":
        return _openstudioutilitiesdata.EndUseFuelType___eq__(self, other)

    def __ne__(self, other: "EndUseFuelType") -> "bool":
        return _openstudioutilitiesdata.EndUseFuelType___ne__(self, other)

    def __gt__(self, other: "EndUseFuelType") -> "bool":
        return _openstudioutilitiesdata.EndUseFuelType___gt__(self, other)

    def __ge__(self, other: "EndUseFuelType") -> "bool":
        return _openstudioutilitiesdata.EndUseFuelType___ge__(self, other)

    def __lt__(self, other: "EndUseFuelType") -> "bool":
        return _openstudioutilitiesdata.EndUseFuelType___lt__(self, other)

    def __le__(self, other: "EndUseFuelType") -> "bool":
        return _openstudioutilitiesdata.EndUseFuelType___le__(self, other)

    @staticmethod
    def enumName() -> "std::string":
        return _openstudioutilitiesdata.EndUseFuelType_enumName()

    @staticmethod
    def getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
        return _openstudioutilitiesdata.EndUseFuelType_getValues()

    def __str__(self) -> "std::string":
        return _openstudioutilitiesdata.EndUseFuelType___str__(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_EndUseFuelType

# Register EndUseFuelType in _openstudioutilitiesdata:
_openstudioutilitiesdata.EndUseFuelType_swigregister(EndUseFuelType)

def EndUseFuelType_enumName() -> "std::string":
    return _openstudioutilitiesdata.EndUseFuelType_enumName()

def EndUseFuelType_getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
    return _openstudioutilitiesdata.EndUseFuelType_getValues()

class EndUseCategoryType(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudioutilitiesdata.EndUseCategoryType_swiginit(self, _openstudioutilitiesdata.new_EndUseCategoryType(*args))

    def valueName(self) -> "std::string":
        return _openstudioutilitiesdata.EndUseCategoryType_valueName(self)

    def value(self) -> "int":
        return _openstudioutilitiesdata.EndUseCategoryType_value(self)

    def valueDescription(self) -> "std::string":
        return _openstudioutilitiesdata.EndUseCategoryType_valueDescription(self)

    def __eq__(self, other: "EndUseCategoryType") -> "bool":
        return _openstudioutilitiesdata.EndUseCategoryType___eq__(self, other)

    def __ne__(self, other: "EndUseCategoryType") -> "bool":
        return _openstudioutilitiesdata.EndUseCategoryType___ne__(self, other)

    def __gt__(self, other: "EndUseCategoryType") -> "bool":
        return _openstudioutilitiesdata.EndUseCategoryType___gt__(self, other)

    def __ge__(self, other: "EndUseCategoryType") -> "bool":
        return _openstudioutilitiesdata.EndUseCategoryType___ge__(self, other)

    def __lt__(self, other: "EndUseCategoryType") -> "bool":
        return _openstudioutilitiesdata.EndUseCategoryType___lt__(self, other)

    def __le__(self, other: "EndUseCategoryType") -> "bool":
        return _openstudioutilitiesdata.EndUseCategoryType___le__(self, other)

    @staticmethod
    def enumName() -> "std::string":
        return _openstudioutilitiesdata.EndUseCategoryType_enumName()

    @staticmethod
    def getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
        return _openstudioutilitiesdata.EndUseCategoryType_getValues()

    def __str__(self) -> "std::string":
        return _openstudioutilitiesdata.EndUseCategoryType___str__(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_EndUseCategoryType

# Register EndUseCategoryType in _openstudioutilitiesdata:
_openstudioutilitiesdata.EndUseCategoryType_swigregister(EndUseCategoryType)

def EndUseCategoryType_enumName() -> "std::string":
    return _openstudioutilitiesdata.EndUseCategoryType_enumName()

def EndUseCategoryType_getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
    return _openstudioutilitiesdata.EndUseCategoryType_getValues()

class EndUseType(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudioutilitiesdata.EndUseType_swiginit(self, _openstudioutilitiesdata.new_EndUseType(*args))

    def valueName(self) -> "std::string":
        return _openstudioutilitiesdata.EndUseType_valueName(self)

    def value(self) -> "int":
        return _openstudioutilitiesdata.EndUseType_value(self)

    def valueDescription(self) -> "std::string":
        return _openstudioutilitiesdata.EndUseType_valueDescription(self)

    def __eq__(self, other: "EndUseType") -> "bool":
        return _openstudioutilitiesdata.EndUseType___eq__(self, other)

    def __ne__(self, other: "EndUseType") -> "bool":
        return _openstudioutilitiesdata.EndUseType___ne__(self, other)

    def __gt__(self, other: "EndUseType") -> "bool":
        return _openstudioutilitiesdata.EndUseType___gt__(self, other)

    def __ge__(self, other: "EndUseType") -> "bool":
        return _openstudioutilitiesdata.EndUseType___ge__(self, other)

    def __lt__(self, other: "EndUseType") -> "bool":
        return _openstudioutilitiesdata.EndUseType___lt__(self, other)

    def __le__(self, other: "EndUseType") -> "bool":
        return _openstudioutilitiesdata.EndUseType___le__(self, other)

    @staticmethod
    def enumName() -> "std::string":
        return _openstudioutilitiesdata.EndUseType_enumName()

    @staticmethod
    def getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
        return _openstudioutilitiesdata.EndUseType_getValues()

    def __str__(self) -> "std::string":
        return _openstudioutilitiesdata.EndUseType___str__(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_EndUseType

# Register EndUseType in _openstudioutilitiesdata:
_openstudioutilitiesdata.EndUseType_swigregister(EndUseType)

def EndUseType_enumName() -> "std::string":
    return _openstudioutilitiesdata.EndUseType_enumName()

def EndUseType_getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
    return _openstudioutilitiesdata.EndUseType_getValues()

class BuildingSector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudioutilitiesdata.BuildingSector_swiginit(self, _openstudioutilitiesdata.new_BuildingSector(*args))

    def valueName(self) -> "std::string":
        return _openstudioutilitiesdata.BuildingSector_valueName(self)

    def value(self) -> "int":
        return _openstudioutilitiesdata.BuildingSector_value(self)

    def valueDescription(self) -> "std::string":
        return _openstudioutilitiesdata.BuildingSector_valueDescription(self)

    def __eq__(self, other: "BuildingSector") -> "bool":
        return _openstudioutilitiesdata.BuildingSector___eq__(self, other)

    def __ne__(self, other: "BuildingSector") -> "bool":
        return _openstudioutilitiesdata.BuildingSector___ne__(self, other)

    def __gt__(self, other: "BuildingSector") -> "bool":
        return _openstudioutilitiesdata.BuildingSector___gt__(self, other)

    def __ge__(self, other: "BuildingSector") -> "bool":
        return _openstudioutilitiesdata.BuildingSector___ge__(self, other)

    def __lt__(self, other: "BuildingSector") -> "bool":
        return _openstudioutilitiesdata.BuildingSector___lt__(self, other)

    def __le__(self, other: "BuildingSector") -> "bool":
        return _openstudioutilitiesdata.BuildingSector___le__(self, other)

    @staticmethod
    def enumName() -> "std::string":
        return _openstudioutilitiesdata.BuildingSector_enumName()

    @staticmethod
    def getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
        return _openstudioutilitiesdata.BuildingSector_getValues()

    def __str__(self) -> "std::string":
        return _openstudioutilitiesdata.BuildingSector___str__(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_BuildingSector

# Register BuildingSector in _openstudioutilitiesdata:
_openstudioutilitiesdata.BuildingSector_swigregister(BuildingSector)

def BuildingSector_enumName() -> "std::string":
    return _openstudioutilitiesdata.BuildingSector_enumName()

def BuildingSector_getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
    return _openstudioutilitiesdata.BuildingSector_getValues()

class OptionalAttribute(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudioutilitiesdata.OptionalAttribute_swiginit(self, _openstudioutilitiesdata.new_OptionalAttribute(*args))

    def reset(self) -> "void":
        return _openstudioutilitiesdata.OptionalAttribute_reset(self)

    def __ref__(self) -> "openstudio::Attribute":
        return _openstudioutilitiesdata.OptionalAttribute___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudioutilitiesdata.OptionalAttribute_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudioutilitiesdata.OptionalAttribute_isNull(self)

    def get(self) -> "openstudio::Attribute":
        return _openstudioutilitiesdata.OptionalAttribute_get(self)

    def set(self, t: "Attribute") -> "void":
        return _openstudioutilitiesdata.OptionalAttribute_set(self, t)
    __swig_destroy__ = _openstudioutilitiesdata.delete_OptionalAttribute

# Register OptionalAttribute in _openstudioutilitiesdata:
_openstudioutilitiesdata.OptionalAttribute_swigregister(OptionalAttribute)

class AttributeVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.AttributeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.AttributeVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.AttributeVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::Attribute >::size_type":
        return _openstudioutilitiesdata.AttributeVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::Attribute >::difference_type", j: "std::vector< openstudio::Attribute >::difference_type") -> "std::vector< openstudio::Attribute,std::allocator< openstudio::Attribute > > *":
        return _openstudioutilitiesdata.AttributeVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.AttributeVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::Attribute >::difference_type", j: "std::vector< openstudio::Attribute >::difference_type") -> "void":
        return _openstudioutilitiesdata.AttributeVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.AttributeVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::Attribute >::value_type const &":
        return _openstudioutilitiesdata.AttributeVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.AttributeVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::Attribute >::value_type":
        return _openstudioutilitiesdata.AttributeVector_pop(self)

    def append(self, x: "Attribute") -> "void":
        return _openstudioutilitiesdata.AttributeVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.AttributeVector_empty(self)

    def size(self) -> "std::vector< openstudio::Attribute >::size_type":
        return _openstudioutilitiesdata.AttributeVector_size(self)

    def swap(self, v: "AttributeVector") -> "void":
        return _openstudioutilitiesdata.AttributeVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::Attribute >::iterator":
        return _openstudioutilitiesdata.AttributeVector_begin(self)

    def end(self) -> "std::vector< openstudio::Attribute >::iterator":
        return _openstudioutilitiesdata.AttributeVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::Attribute >::reverse_iterator":
        return _openstudioutilitiesdata.AttributeVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::Attribute >::reverse_iterator":
        return _openstudioutilitiesdata.AttributeVector_rend(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.AttributeVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::Attribute >::allocator_type":
        return _openstudioutilitiesdata.AttributeVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.AttributeVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::Attribute >::iterator":
        return _openstudioutilitiesdata.AttributeVector_erase(self, *args)

    def __init__(self, *args):
        _openstudioutilitiesdata.AttributeVector_swiginit(self, _openstudioutilitiesdata.new_AttributeVector(*args))

    def push_back(self, x: "Attribute") -> "void":
        return _openstudioutilitiesdata.AttributeVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::Attribute >::value_type const &":
        return _openstudioutilitiesdata.AttributeVector_front(self)

    def back(self) -> "std::vector< openstudio::Attribute >::value_type const &":
        return _openstudioutilitiesdata.AttributeVector_back(self)

    def assign(self, n: "std::vector< openstudio::Attribute >::size_type", x: "Attribute") -> "void":
        return _openstudioutilitiesdata.AttributeVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::Attribute >::size_type", x: "Attribute") -> "void":
        return _openstudioutilitiesdata.AttributeVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.AttributeVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::Attribute >::size_type") -> "void":
        return _openstudioutilitiesdata.AttributeVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::Attribute >::size_type":
        return _openstudioutilitiesdata.AttributeVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_AttributeVector

# Register AttributeVector in _openstudioutilitiesdata:
_openstudioutilitiesdata.AttributeVector_swigregister(AttributeVector)

class AttributeValueType(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudioutilitiesdata.AttributeValueType_swiginit(self, _openstudioutilitiesdata.new_AttributeValueType(*args))

    def valueName(self) -> "std::string":
        return _openstudioutilitiesdata.AttributeValueType_valueName(self)

    def value(self) -> "int":
        return _openstudioutilitiesdata.AttributeValueType_value(self)

    def valueDescription(self) -> "std::string":
        return _openstudioutilitiesdata.AttributeValueType_valueDescription(self)

    def __eq__(self, other: "AttributeValueType") -> "bool":
        return _openstudioutilitiesdata.AttributeValueType___eq__(self, other)

    def __ne__(self, other: "AttributeValueType") -> "bool":
        return _openstudioutilitiesdata.AttributeValueType___ne__(self, other)

    def __gt__(self, other: "AttributeValueType") -> "bool":
        return _openstudioutilitiesdata.AttributeValueType___gt__(self, other)

    def __ge__(self, other: "AttributeValueType") -> "bool":
        return _openstudioutilitiesdata.AttributeValueType___ge__(self, other)

    def __lt__(self, other: "AttributeValueType") -> "bool":
        return _openstudioutilitiesdata.AttributeValueType___lt__(self, other)

    def __le__(self, other: "AttributeValueType") -> "bool":
        return _openstudioutilitiesdata.AttributeValueType___le__(self, other)

    @staticmethod
    def enumName() -> "std::string":
        return _openstudioutilitiesdata.AttributeValueType_enumName()

    @staticmethod
    def getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
        return _openstudioutilitiesdata.AttributeValueType_getValues()

    def __str__(self) -> "std::string":
        return _openstudioutilitiesdata.AttributeValueType___str__(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_AttributeValueType

# Register AttributeValueType in _openstudioutilitiesdata:
_openstudioutilitiesdata.AttributeValueType_swigregister(AttributeValueType)

def AttributeValueType_enumName() -> "std::string":
    return _openstudioutilitiesdata.AttributeValueType_enumName()

def AttributeValueType_getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
    return _openstudioutilitiesdata.AttributeValueType_getValues()

class AttributeDescription(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_openstudioutilitiesdata.AttributeDescription_name_get, _openstudioutilitiesdata.AttributeDescription_name_set)
    displayName = property(_openstudioutilitiesdata.AttributeDescription_displayName_get, _openstudioutilitiesdata.AttributeDescription_displayName_set)
    description = property(_openstudioutilitiesdata.AttributeDescription_description_get, _openstudioutilitiesdata.AttributeDescription_description_set)
    validValueTypes = property(_openstudioutilitiesdata.AttributeDescription_validValueTypes_get, _openstudioutilitiesdata.AttributeDescription_validValueTypes_set)
    required = property(_openstudioutilitiesdata.AttributeDescription_required_get, _openstudioutilitiesdata.AttributeDescription_required_set)
    defaultValue = property(_openstudioutilitiesdata.AttributeDescription_defaultValue_get, _openstudioutilitiesdata.AttributeDescription_defaultValue_set)

    def __init__(self, *args):
        _openstudioutilitiesdata.AttributeDescription_swiginit(self, _openstudioutilitiesdata.new_AttributeDescription(*args))
    __swig_destroy__ = _openstudioutilitiesdata.delete_AttributeDescription

# Register AttributeDescription in _openstudioutilitiesdata:
_openstudioutilitiesdata.AttributeDescription_swigregister(AttributeDescription)

class Attribute(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudioutilitiesdata.delete_Attribute

    def __init__(self, *args):
        _openstudioutilitiesdata.Attribute_swiginit(self, _openstudioutilitiesdata.new_Attribute(*args))

    def clone(self) -> "openstudio::Attribute":
        return _openstudioutilitiesdata.Attribute_clone(self)

    @staticmethod
    def loadFromXml(path: "path") -> "boost::optional< openstudio::Attribute >":
        return _openstudioutilitiesdata.Attribute_loadFromXml(path)

    def uuid(self) -> "openstudio::UUID":
        return _openstudioutilitiesdata.Attribute_uuid(self)

    def versionUUID(self) -> "openstudio::UUID":
        return _openstudioutilitiesdata.Attribute_versionUUID(self)

    def name(self) -> "std::string":
        return _openstudioutilitiesdata.Attribute_name(self)

    def displayName(self, returnName: "bool"=False) -> "boost::optional< std::string >":
        return _openstudioutilitiesdata.Attribute_displayName(self, returnName)

    def setDisplayName(self, displayName: "std::string const &") -> "bool":
        return _openstudioutilitiesdata.Attribute_setDisplayName(self, displayName)

    def clearDisplayName(self) -> "void":
        return _openstudioutilitiesdata.Attribute_clearDisplayName(self)

    def source(self) -> "std::string":
        return _openstudioutilitiesdata.Attribute_source(self)

    def setSource(self, source: "std::string const &") -> "void":
        return _openstudioutilitiesdata.Attribute_setSource(self, source)

    def clearSource(self) -> "void":
        return _openstudioutilitiesdata.Attribute_clearSource(self)

    def valueType(self) -> "openstudio::AttributeValueType":
        return _openstudioutilitiesdata.Attribute_valueType(self)

    def hasValue(self) -> "bool":
        return _openstudioutilitiesdata.Attribute_hasValue(self)

    def valueAsBoolean(self) -> "bool":
        return _openstudioutilitiesdata.Attribute_valueAsBoolean(self)

    def valueAsInteger(self) -> "int":
        return _openstudioutilitiesdata.Attribute_valueAsInteger(self)

    def valueAsUnsigned(self) -> "unsigned int":
        return _openstudioutilitiesdata.Attribute_valueAsUnsigned(self)

    def valueAsDouble(self) -> "double":
        return _openstudioutilitiesdata.Attribute_valueAsDouble(self)

    def valueAsString(self) -> "std::string":
        return _openstudioutilitiesdata.Attribute_valueAsString(self)

    def valueAsAttributeVector(self) -> "std::vector< openstudio::Attribute,std::allocator< openstudio::Attribute > >":
        return _openstudioutilitiesdata.Attribute_valueAsAttributeVector(self)

    def setValue(self, *args) -> "void":
        return _openstudioutilitiesdata.Attribute_setValue(self, *args)

    def findChildByName(self, name: "std::string const &") -> "boost::optional< openstudio::Attribute >":
        return _openstudioutilitiesdata.Attribute_findChildByName(self, name)

    def units(self) -> "boost::optional< std::string >":
        return _openstudioutilitiesdata.Attribute_units(self)

    def setUnits(self, units: "std::string const &") -> "bool":
        return _openstudioutilitiesdata.Attribute_setUnits(self, units)

    def toString(self) -> "std::string":
        return _openstudioutilitiesdata.Attribute_toString(self)

    def saveToXml(self, path: "path") -> "bool":
        return _openstudioutilitiesdata.Attribute_saveToXml(self, path)

    def __eq__(self, other: "Attribute") -> "bool":
        return _openstudioutilitiesdata.Attribute___eq__(self, other)

    def __str__(self) -> "std::string":
        return _openstudioutilitiesdata.Attribute___str__(self)

# Register Attribute in _openstudioutilitiesdata:
_openstudioutilitiesdata.Attribute_swigregister(Attribute)

def Attribute_loadFromXml(path: "path") -> "boost::optional< openstudio::Attribute >":
    return _openstudioutilitiesdata.Attribute_loadFromXml(path)


def createAttributeFromVector(*args) -> "openstudio::Attribute":
    return _openstudioutilitiesdata.createAttributeFromVector(*args)

def getIntVectorFromAttribute(attribute: "Attribute") -> "std::vector< int,std::allocator< int > >":
    return _openstudioutilitiesdata.getIntVectorFromAttribute(attribute)

def getDoubleVectorFromAttribute(attribute: "Attribute") -> "std::vector< double,std::allocator< double > >":
    return _openstudioutilitiesdata.getDoubleVectorFromAttribute(attribute)
class OptionalVariant(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudioutilitiesdata.OptionalVariant_swiginit(self, _openstudioutilitiesdata.new_OptionalVariant(*args))

    def reset(self) -> "void":
        return _openstudioutilitiesdata.OptionalVariant_reset(self)

    def __ref__(self) -> "openstudio::Variant":
        return _openstudioutilitiesdata.OptionalVariant___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudioutilitiesdata.OptionalVariant_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudioutilitiesdata.OptionalVariant_isNull(self)

    def get(self) -> "openstudio::Variant":
        return _openstudioutilitiesdata.OptionalVariant_get(self)

    def set(self, t: "Variant") -> "void":
        return _openstudioutilitiesdata.OptionalVariant_set(self, t)
    __swig_destroy__ = _openstudioutilitiesdata.delete_OptionalVariant

# Register OptionalVariant in _openstudioutilitiesdata:
_openstudioutilitiesdata.OptionalVariant_swigregister(OptionalVariant)

class VariantVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.VariantVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.VariantVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.VariantVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::Variant >::size_type":
        return _openstudioutilitiesdata.VariantVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::Variant >::difference_type", j: "std::vector< openstudio::Variant >::difference_type") -> "std::vector< openstudio::Variant,std::allocator< openstudio::Variant > > *":
        return _openstudioutilitiesdata.VariantVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.VariantVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::Variant >::difference_type", j: "std::vector< openstudio::Variant >::difference_type") -> "void":
        return _openstudioutilitiesdata.VariantVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.VariantVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::Variant >::value_type const &":
        return _openstudioutilitiesdata.VariantVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.VariantVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::Variant >::value_type":
        return _openstudioutilitiesdata.VariantVector_pop(self)

    def append(self, x: "Variant") -> "void":
        return _openstudioutilitiesdata.VariantVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.VariantVector_empty(self)

    def size(self) -> "std::vector< openstudio::Variant >::size_type":
        return _openstudioutilitiesdata.VariantVector_size(self)

    def swap(self, v: "VariantVector") -> "void":
        return _openstudioutilitiesdata.VariantVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::Variant >::iterator":
        return _openstudioutilitiesdata.VariantVector_begin(self)

    def end(self) -> "std::vector< openstudio::Variant >::iterator":
        return _openstudioutilitiesdata.VariantVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::Variant >::reverse_iterator":
        return _openstudioutilitiesdata.VariantVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::Variant >::reverse_iterator":
        return _openstudioutilitiesdata.VariantVector_rend(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.VariantVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::Variant >::allocator_type":
        return _openstudioutilitiesdata.VariantVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.VariantVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::Variant >::iterator":
        return _openstudioutilitiesdata.VariantVector_erase(self, *args)

    def __init__(self, *args):
        _openstudioutilitiesdata.VariantVector_swiginit(self, _openstudioutilitiesdata.new_VariantVector(*args))

    def push_back(self, x: "Variant") -> "void":
        return _openstudioutilitiesdata.VariantVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::Variant >::value_type const &":
        return _openstudioutilitiesdata.VariantVector_front(self)

    def back(self) -> "std::vector< openstudio::Variant >::value_type const &":
        return _openstudioutilitiesdata.VariantVector_back(self)

    def assign(self, n: "std::vector< openstudio::Variant >::size_type", x: "Variant") -> "void":
        return _openstudioutilitiesdata.VariantVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudioutilitiesdata.VariantVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.VariantVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::Variant >::size_type") -> "void":
        return _openstudioutilitiesdata.VariantVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::Variant >::size_type":
        return _openstudioutilitiesdata.VariantVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_VariantVector

# Register VariantVector in _openstudioutilitiesdata:
_openstudioutilitiesdata.VariantVector_swigregister(VariantVector)

class StringVariantMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.StringVariantMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.StringVariantMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.StringVariantMap___bool__(self)

    def __len__(self) -> "std::map< std::string,openstudio::Variant >::size_type":
        return _openstudioutilitiesdata.StringVariantMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::map< std::string,openstudio::Variant >::key_type const &") -> "std::map< std::string,openstudio::Variant >::mapped_type const &":
        return _openstudioutilitiesdata.StringVariantMap___getitem__(self, key)

    def __delitem__(self, key: "std::map< std::string,openstudio::Variant >::key_type const &") -> "void":
        return _openstudioutilitiesdata.StringVariantMap___delitem__(self, key)

    def has_key(self, key: "std::map< std::string,openstudio::Variant >::key_type const &") -> "bool":
        return _openstudioutilitiesdata.StringVariantMap_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _openstudioutilitiesdata.StringVariantMap_keys(self)

    def values(self) -> "PyObject *":
        return _openstudioutilitiesdata.StringVariantMap_values(self)

    def items(self) -> "PyObject *":
        return _openstudioutilitiesdata.StringVariantMap_items(self)

    def __contains__(self, key: "std::map< std::string,openstudio::Variant >::key_type const &") -> "bool":
        return _openstudioutilitiesdata.StringVariantMap___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.StringVariantMap_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.StringVariantMap_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.StringVariantMap___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _openstudioutilitiesdata.StringVariantMap_asdict(self)

    def __init__(self, *args):
        _openstudioutilitiesdata.StringVariantMap_swiginit(self, _openstudioutilitiesdata.new_StringVariantMap(*args))

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.StringVariantMap_empty(self)

    def size(self) -> "std::map< std::string,openstudio::Variant >::size_type":
        return _openstudioutilitiesdata.StringVariantMap_size(self)

    def swap(self, v: "StringVariantMap") -> "void":
        return _openstudioutilitiesdata.StringVariantMap_swap(self, v)

    def begin(self) -> "std::map< std::string,openstudio::Variant >::iterator":
        return _openstudioutilitiesdata.StringVariantMap_begin(self)

    def end(self) -> "std::map< std::string,openstudio::Variant >::iterator":
        return _openstudioutilitiesdata.StringVariantMap_end(self)

    def rbegin(self) -> "std::map< std::string,openstudio::Variant >::reverse_iterator":
        return _openstudioutilitiesdata.StringVariantMap_rbegin(self)

    def rend(self) -> "std::map< std::string,openstudio::Variant >::reverse_iterator":
        return _openstudioutilitiesdata.StringVariantMap_rend(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.StringVariantMap_clear(self)

    def get_allocator(self) -> "std::map< std::string,openstudio::Variant >::allocator_type":
        return _openstudioutilitiesdata.StringVariantMap_get_allocator(self)

    def count(self, x: "std::map< std::string,openstudio::Variant >::key_type const &") -> "std::map< std::string,openstudio::Variant >::size_type":
        return _openstudioutilitiesdata.StringVariantMap_count(self, x)

    def erase(self, *args) -> "void":
        return _openstudioutilitiesdata.StringVariantMap_erase(self, *args)

    def find(self, x: "std::map< std::string,openstudio::Variant >::key_type const &") -> "std::map< std::string,openstudio::Variant >::iterator":
        return _openstudioutilitiesdata.StringVariantMap_find(self, x)

    def lower_bound(self, x: "std::map< std::string,openstudio::Variant >::key_type const &") -> "std::map< std::string,openstudio::Variant >::iterator":
        return _openstudioutilitiesdata.StringVariantMap_lower_bound(self, x)

    def upper_bound(self, x: "std::map< std::string,openstudio::Variant >::key_type const &") -> "std::map< std::string,openstudio::Variant >::iterator":
        return _openstudioutilitiesdata.StringVariantMap_upper_bound(self, x)
    __swig_destroy__ = _openstudioutilitiesdata.delete_StringVariantMap

# Register StringVariantMap in _openstudioutilitiesdata:
_openstudioutilitiesdata.StringVariantMap_swigregister(StringVariantMap)

class VariantVectorVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.VariantVectorVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.VariantVectorVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.VariantVectorVector___bool__(self)

    def __len__(self) -> "std::vector< std::vector< openstudio::Variant > >::size_type":
        return _openstudioutilitiesdata.VariantVectorVector___len__(self)

    def __getslice__(self, i: "std::vector< std::vector< openstudio::Variant > >::difference_type", j: "std::vector< std::vector< openstudio::Variant > >::difference_type") -> "std::vector< std::vector< openstudio::Variant,std::allocator< openstudio::Variant > >,std::allocator< std::vector< openstudio::Variant,std::allocator< openstudio::Variant > > > > *":
        return _openstudioutilitiesdata.VariantVectorVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.VariantVectorVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::vector< openstudio::Variant > >::difference_type", j: "std::vector< std::vector< openstudio::Variant > >::difference_type") -> "void":
        return _openstudioutilitiesdata.VariantVectorVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.VariantVectorVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::vector< openstudio::Variant > >::value_type const &":
        return _openstudioutilitiesdata.VariantVectorVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.VariantVectorVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::vector< openstudio::Variant > >::value_type":
        return _openstudioutilitiesdata.VariantVectorVector_pop(self)

    def append(self, x: "VariantVector") -> "void":
        return _openstudioutilitiesdata.VariantVectorVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.VariantVectorVector_empty(self)

    def size(self) -> "std::vector< std::vector< openstudio::Variant > >::size_type":
        return _openstudioutilitiesdata.VariantVectorVector_size(self)

    def swap(self, v: "VariantVectorVector") -> "void":
        return _openstudioutilitiesdata.VariantVectorVector_swap(self, v)

    def begin(self) -> "std::vector< std::vector< openstudio::Variant > >::iterator":
        return _openstudioutilitiesdata.VariantVectorVector_begin(self)

    def end(self) -> "std::vector< std::vector< openstudio::Variant > >::iterator":
        return _openstudioutilitiesdata.VariantVectorVector_end(self)

    def rbegin(self) -> "std::vector< std::vector< openstudio::Variant > >::reverse_iterator":
        return _openstudioutilitiesdata.VariantVectorVector_rbegin(self)

    def rend(self) -> "std::vector< std::vector< openstudio::Variant > >::reverse_iterator":
        return _openstudioutilitiesdata.VariantVectorVector_rend(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.VariantVectorVector_clear(self)

    def get_allocator(self) -> "std::vector< std::vector< openstudio::Variant > >::allocator_type":
        return _openstudioutilitiesdata.VariantVectorVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.VariantVectorVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::vector< openstudio::Variant > >::iterator":
        return _openstudioutilitiesdata.VariantVectorVector_erase(self, *args)

    def __init__(self, *args):
        _openstudioutilitiesdata.VariantVectorVector_swiginit(self, _openstudioutilitiesdata.new_VariantVectorVector(*args))

    def push_back(self, x: "VariantVector") -> "void":
        return _openstudioutilitiesdata.VariantVectorVector_push_back(self, x)

    def front(self) -> "std::vector< std::vector< openstudio::Variant > >::value_type const &":
        return _openstudioutilitiesdata.VariantVectorVector_front(self)

    def back(self) -> "std::vector< std::vector< openstudio::Variant > >::value_type const &":
        return _openstudioutilitiesdata.VariantVectorVector_back(self)

    def assign(self, n: "std::vector< std::vector< openstudio::Variant > >::size_type", x: "VariantVector") -> "void":
        return _openstudioutilitiesdata.VariantVectorVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudioutilitiesdata.VariantVectorVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.VariantVectorVector_insert(self, *args)

    def reserve(self, n: "std::vector< std::vector< openstudio::Variant > >::size_type") -> "void":
        return _openstudioutilitiesdata.VariantVectorVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::vector< openstudio::Variant > >::size_type":
        return _openstudioutilitiesdata.VariantVectorVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_VariantVectorVector

# Register VariantVectorVector in _openstudioutilitiesdata:
_openstudioutilitiesdata.VariantVectorVector_swigregister(VariantVectorVector)

class VariantType(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudioutilitiesdata.VariantType_swiginit(self, _openstudioutilitiesdata.new_VariantType(*args))

    def valueName(self) -> "std::string":
        return _openstudioutilitiesdata.VariantType_valueName(self)

    def value(self) -> "int":
        return _openstudioutilitiesdata.VariantType_value(self)

    def valueDescription(self) -> "std::string":
        return _openstudioutilitiesdata.VariantType_valueDescription(self)

    def __eq__(self, other: "VariantType") -> "bool":
        return _openstudioutilitiesdata.VariantType___eq__(self, other)

    def __ne__(self, other: "VariantType") -> "bool":
        return _openstudioutilitiesdata.VariantType___ne__(self, other)

    def __gt__(self, other: "VariantType") -> "bool":
        return _openstudioutilitiesdata.VariantType___gt__(self, other)

    def __ge__(self, other: "VariantType") -> "bool":
        return _openstudioutilitiesdata.VariantType___ge__(self, other)

    def __lt__(self, other: "VariantType") -> "bool":
        return _openstudioutilitiesdata.VariantType___lt__(self, other)

    def __le__(self, other: "VariantType") -> "bool":
        return _openstudioutilitiesdata.VariantType___le__(self, other)

    @staticmethod
    def enumName() -> "std::string":
        return _openstudioutilitiesdata.VariantType_enumName()

    @staticmethod
    def getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
        return _openstudioutilitiesdata.VariantType_getValues()

    def __str__(self) -> "std::string":
        return _openstudioutilitiesdata.VariantType___str__(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_VariantType

# Register VariantType in _openstudioutilitiesdata:
_openstudioutilitiesdata.VariantType_swigregister(VariantType)

def VariantType_enumName() -> "std::string":
    return _openstudioutilitiesdata.VariantType_enumName()

def VariantType_getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
    return _openstudioutilitiesdata.VariantType_getValues()

class Variant(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudioutilitiesdata.Variant_swiginit(self, _openstudioutilitiesdata.new_Variant(*args))

    def variantType(self) -> "openstudio::VariantType":
        return _openstudioutilitiesdata.Variant_variantType(self)

    def valueAsBoolean(self) -> "bool":
        return _openstudioutilitiesdata.Variant_valueAsBoolean(self)

    def valueAsInteger(self) -> "int":
        return _openstudioutilitiesdata.Variant_valueAsInteger(self)

    def valueAsDouble(self) -> "double":
        return _openstudioutilitiesdata.Variant_valueAsDouble(self)

    def valueAsString(self) -> "std::string":
        return _openstudioutilitiesdata.Variant_valueAsString(self)

    def __str__(self) -> "std::string":
        return _openstudioutilitiesdata.Variant___str__(self)

    def __int__(self) -> "int":
        return _openstudioutilitiesdata.Variant___int__(self)

    def __float__(self) -> "float":
        return _openstudioutilitiesdata.Variant___float__(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_Variant

# Register Variant in _openstudioutilitiesdata:
_openstudioutilitiesdata.Variant_swigregister(Variant)


def __lshift__(*args) -> "std::ostream &":
    return _openstudioutilitiesdata.__lshift__(*args)
class OptionalCalibrationResult(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudioutilitiesdata.OptionalCalibrationResult_swiginit(self, _openstudioutilitiesdata.new_OptionalCalibrationResult(*args))

    def reset(self) -> "void":
        return _openstudioutilitiesdata.OptionalCalibrationResult_reset(self)

    def __ref__(self) -> "openstudio::CalibrationResult":
        return _openstudioutilitiesdata.OptionalCalibrationResult___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudioutilitiesdata.OptionalCalibrationResult_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudioutilitiesdata.OptionalCalibrationResult_isNull(self)

    def get(self) -> "openstudio::CalibrationResult":
        return _openstudioutilitiesdata.OptionalCalibrationResult_get(self)

    def set(self, t: "CalibrationResult") -> "void":
        return _openstudioutilitiesdata.OptionalCalibrationResult_set(self, t)
    __swig_destroy__ = _openstudioutilitiesdata.delete_OptionalCalibrationResult

# Register OptionalCalibrationResult in _openstudioutilitiesdata:
_openstudioutilitiesdata.OptionalCalibrationResult_swigregister(OptionalCalibrationResult)

class OptionalCalibrationBillingPeriod(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudioutilitiesdata.OptionalCalibrationBillingPeriod_swiginit(self, _openstudioutilitiesdata.new_OptionalCalibrationBillingPeriod(*args))

    def reset(self) -> "void":
        return _openstudioutilitiesdata.OptionalCalibrationBillingPeriod_reset(self)

    def __ref__(self) -> "openstudio::CalibrationBillingPeriod":
        return _openstudioutilitiesdata.OptionalCalibrationBillingPeriod___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudioutilitiesdata.OptionalCalibrationBillingPeriod_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudioutilitiesdata.OptionalCalibrationBillingPeriod_isNull(self)

    def get(self) -> "openstudio::CalibrationBillingPeriod":
        return _openstudioutilitiesdata.OptionalCalibrationBillingPeriod_get(self)

    def set(self, t: "CalibrationBillingPeriod") -> "void":
        return _openstudioutilitiesdata.OptionalCalibrationBillingPeriod_set(self, t)
    __swig_destroy__ = _openstudioutilitiesdata.delete_OptionalCalibrationBillingPeriod

# Register OptionalCalibrationBillingPeriod in _openstudioutilitiesdata:
_openstudioutilitiesdata.OptionalCalibrationBillingPeriod_swigregister(OptionalCalibrationBillingPeriod)

class OptionalCalibrationUtilityBill(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudioutilitiesdata.OptionalCalibrationUtilityBill_swiginit(self, _openstudioutilitiesdata.new_OptionalCalibrationUtilityBill(*args))

    def reset(self) -> "void":
        return _openstudioutilitiesdata.OptionalCalibrationUtilityBill_reset(self)

    def __ref__(self) -> "openstudio::CalibrationUtilityBill":
        return _openstudioutilitiesdata.OptionalCalibrationUtilityBill___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudioutilitiesdata.OptionalCalibrationUtilityBill_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudioutilitiesdata.OptionalCalibrationUtilityBill_isNull(self)

    def get(self) -> "openstudio::CalibrationUtilityBill":
        return _openstudioutilitiesdata.OptionalCalibrationUtilityBill_get(self)

    def set(self, t: "CalibrationUtilityBill") -> "void":
        return _openstudioutilitiesdata.OptionalCalibrationUtilityBill_set(self, t)
    __swig_destroy__ = _openstudioutilitiesdata.delete_OptionalCalibrationUtilityBill

# Register OptionalCalibrationUtilityBill in _openstudioutilitiesdata:
_openstudioutilitiesdata.OptionalCalibrationUtilityBill_swigregister(OptionalCalibrationUtilityBill)

class CalibrationResultVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.CalibrationResultVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.CalibrationResultVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.CalibrationResultVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::CalibrationResult >::size_type":
        return _openstudioutilitiesdata.CalibrationResultVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::CalibrationResult >::difference_type", j: "std::vector< openstudio::CalibrationResult >::difference_type") -> "std::vector< openstudio::CalibrationResult,std::allocator< openstudio::CalibrationResult > > *":
        return _openstudioutilitiesdata.CalibrationResultVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.CalibrationResultVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::CalibrationResult >::difference_type", j: "std::vector< openstudio::CalibrationResult >::difference_type") -> "void":
        return _openstudioutilitiesdata.CalibrationResultVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.CalibrationResultVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::CalibrationResult >::value_type const &":
        return _openstudioutilitiesdata.CalibrationResultVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.CalibrationResultVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::CalibrationResult >::value_type":
        return _openstudioutilitiesdata.CalibrationResultVector_pop(self)

    def append(self, x: "CalibrationResult") -> "void":
        return _openstudioutilitiesdata.CalibrationResultVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.CalibrationResultVector_empty(self)

    def size(self) -> "std::vector< openstudio::CalibrationResult >::size_type":
        return _openstudioutilitiesdata.CalibrationResultVector_size(self)

    def swap(self, v: "CalibrationResultVector") -> "void":
        return _openstudioutilitiesdata.CalibrationResultVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::CalibrationResult >::iterator":
        return _openstudioutilitiesdata.CalibrationResultVector_begin(self)

    def end(self) -> "std::vector< openstudio::CalibrationResult >::iterator":
        return _openstudioutilitiesdata.CalibrationResultVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::CalibrationResult >::reverse_iterator":
        return _openstudioutilitiesdata.CalibrationResultVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::CalibrationResult >::reverse_iterator":
        return _openstudioutilitiesdata.CalibrationResultVector_rend(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.CalibrationResultVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::CalibrationResult >::allocator_type":
        return _openstudioutilitiesdata.CalibrationResultVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.CalibrationResultVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::CalibrationResult >::iterator":
        return _openstudioutilitiesdata.CalibrationResultVector_erase(self, *args)

    def __init__(self, *args):
        _openstudioutilitiesdata.CalibrationResultVector_swiginit(self, _openstudioutilitiesdata.new_CalibrationResultVector(*args))

    def push_back(self, x: "CalibrationResult") -> "void":
        return _openstudioutilitiesdata.CalibrationResultVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::CalibrationResult >::value_type const &":
        return _openstudioutilitiesdata.CalibrationResultVector_front(self)

    def back(self) -> "std::vector< openstudio::CalibrationResult >::value_type const &":
        return _openstudioutilitiesdata.CalibrationResultVector_back(self)

    def assign(self, n: "std::vector< openstudio::CalibrationResult >::size_type", x: "CalibrationResult") -> "void":
        return _openstudioutilitiesdata.CalibrationResultVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudioutilitiesdata.CalibrationResultVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.CalibrationResultVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::CalibrationResult >::size_type") -> "void":
        return _openstudioutilitiesdata.CalibrationResultVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::CalibrationResult >::size_type":
        return _openstudioutilitiesdata.CalibrationResultVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_CalibrationResultVector

# Register CalibrationResultVector in _openstudioutilitiesdata:
_openstudioutilitiesdata.CalibrationResultVector_swigregister(CalibrationResultVector)

class CalibrationBillingPeriod(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def attributeName() -> "std::string":
        return _openstudioutilitiesdata.CalibrationBillingPeriod_attributeName()

    @staticmethod
    def fromAttribute(attribute: "Attribute") -> "boost::optional< openstudio::CalibrationBillingPeriod >":
        return _openstudioutilitiesdata.CalibrationBillingPeriod_fromAttribute(attribute)

    def __init__(self, startDate: "Date", numberOfDays: "unsigned int", consumptionUnit: "std::string const &", peakDemandUnit: "OptionalString", consumption: "OptionalDouble", peakDemand: "OptionalDouble", totalCost: "OptionalDouble", modelConsumption: "OptionalDouble", modelPeakDemand: "OptionalDouble", modelTotalCost: "OptionalDouble"):
        _openstudioutilitiesdata.CalibrationBillingPeriod_swiginit(self, _openstudioutilitiesdata.new_CalibrationBillingPeriod(startDate, numberOfDays, consumptionUnit, peakDemandUnit, consumption, peakDemand, totalCost, modelConsumption, modelPeakDemand, modelTotalCost))

    def attribute(self) -> "openstudio::Attribute":
        return _openstudioutilitiesdata.CalibrationBillingPeriod_attribute(self)

    def startDate(self) -> "openstudio::Date":
        return _openstudioutilitiesdata.CalibrationBillingPeriod_startDate(self)

    def endDate(self) -> "openstudio::Date":
        return _openstudioutilitiesdata.CalibrationBillingPeriod_endDate(self)

    def numberOfDays(self) -> "unsigned int":
        return _openstudioutilitiesdata.CalibrationBillingPeriod_numberOfDays(self)

    def consumptionUnit(self) -> "std::string":
        return _openstudioutilitiesdata.CalibrationBillingPeriod_consumptionUnit(self)

    def peakDemandUnit(self) -> "boost::optional< std::string >":
        return _openstudioutilitiesdata.CalibrationBillingPeriod_peakDemandUnit(self)

    def consumption(self) -> "boost::optional< double >":
        return _openstudioutilitiesdata.CalibrationBillingPeriod_consumption(self)

    def peakDemand(self) -> "boost::optional< double >":
        return _openstudioutilitiesdata.CalibrationBillingPeriod_peakDemand(self)

    def totalCost(self) -> "boost::optional< double >":
        return _openstudioutilitiesdata.CalibrationBillingPeriod_totalCost(self)

    def modelConsumption(self) -> "boost::optional< double >":
        return _openstudioutilitiesdata.CalibrationBillingPeriod_modelConsumption(self)

    def modelPeakDemand(self) -> "boost::optional< double >":
        return _openstudioutilitiesdata.CalibrationBillingPeriod_modelPeakDemand(self)

    def modelTotalCost(self) -> "boost::optional< double >":
        return _openstudioutilitiesdata.CalibrationBillingPeriod_modelTotalCost(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_CalibrationBillingPeriod

# Register CalibrationBillingPeriod in _openstudioutilitiesdata:
_openstudioutilitiesdata.CalibrationBillingPeriod_swigregister(CalibrationBillingPeriod)

def CalibrationBillingPeriod_attributeName() -> "std::string":
    return _openstudioutilitiesdata.CalibrationBillingPeriod_attributeName()

def CalibrationBillingPeriod_fromAttribute(attribute: "Attribute") -> "boost::optional< openstudio::CalibrationBillingPeriod >":
    return _openstudioutilitiesdata.CalibrationBillingPeriod_fromAttribute(attribute)

class CalibrationUtilityBill(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def attributeName() -> "std::string":
        return _openstudioutilitiesdata.CalibrationUtilityBill_attributeName()

    @staticmethod
    def fromAttribute(attribute: "Attribute") -> "boost::optional< openstudio::CalibrationUtilityBill >":
        return _openstudioutilitiesdata.CalibrationUtilityBill_fromAttribute(attribute)

    def __init__(self, name: "std::string const &", fuelType: "FuelType", meterInstallLocation: "InstallLocationType", meterSpecificInstallLocation: "OptionalString", meterEndUseCategory: "OptionalEndUseCategoryType", meterSpecificEndUse: "OptionalString", consumptionUnit: "std::string", consumptionUnitConversionFactor: "double", peakDemandUnit: "OptionalString", peakDemandUnitConversionFactor: "OptionalDouble", timestepsInPeakDemandWindow: "OptionalUnsigned", minutesInPeakDemandWindow: "OptionalDouble", numberBillingPeriodsInCalculations: "OptionalUnsigned", CVRMSE: "OptionalDouble", NMBE: "OptionalDouble"):
        _openstudioutilitiesdata.CalibrationUtilityBill_swiginit(self, _openstudioutilitiesdata.new_CalibrationUtilityBill(name, fuelType, meterInstallLocation, meterSpecificInstallLocation, meterEndUseCategory, meterSpecificEndUse, consumptionUnit, consumptionUnitConversionFactor, peakDemandUnit, peakDemandUnitConversionFactor, timestepsInPeakDemandWindow, minutesInPeakDemandWindow, numberBillingPeriodsInCalculations, CVRMSE, NMBE))

    def attribute(self) -> "openstudio::Attribute":
        return _openstudioutilitiesdata.CalibrationUtilityBill_attribute(self)

    def name(self) -> "std::string":
        return _openstudioutilitiesdata.CalibrationUtilityBill_name(self)

    def fuelType(self) -> "openstudio::FuelType":
        return _openstudioutilitiesdata.CalibrationUtilityBill_fuelType(self)

    def meterInstallLocation(self) -> "openstudio::InstallLocationType":
        return _openstudioutilitiesdata.CalibrationUtilityBill_meterInstallLocation(self)

    def meterSpecificInstallLocation(self) -> "boost::optional< std::string >":
        return _openstudioutilitiesdata.CalibrationUtilityBill_meterSpecificInstallLocation(self)

    def meterEndUseCategory(self) -> "boost::optional< openstudio::EndUseCategoryType >":
        return _openstudioutilitiesdata.CalibrationUtilityBill_meterEndUseCategory(self)

    def meterSpecificEndUse(self) -> "boost::optional< std::string >":
        return _openstudioutilitiesdata.CalibrationUtilityBill_meterSpecificEndUse(self)

    def consumptionUnit(self) -> "std::string":
        return _openstudioutilitiesdata.CalibrationUtilityBill_consumptionUnit(self)

    def consumptionUnitConversionFactor(self) -> "double":
        return _openstudioutilitiesdata.CalibrationUtilityBill_consumptionUnitConversionFactor(self)

    def peakDemandUnit(self) -> "boost::optional< std::string >":
        return _openstudioutilitiesdata.CalibrationUtilityBill_peakDemandUnit(self)

    def peakDemandUnitConversionFactor(self) -> "boost::optional< double >":
        return _openstudioutilitiesdata.CalibrationUtilityBill_peakDemandUnitConversionFactor(self)

    def timestepsInPeakDemandWindow(self) -> "boost::optional< unsigned int >":
        return _openstudioutilitiesdata.CalibrationUtilityBill_timestepsInPeakDemandWindow(self)

    def minutesInPeakDemandWindow(self) -> "boost::optional< double >":
        return _openstudioutilitiesdata.CalibrationUtilityBill_minutesInPeakDemandWindow(self)

    def numberBillingPeriodsInCalculations(self) -> "boost::optional< unsigned int >":
        return _openstudioutilitiesdata.CalibrationUtilityBill_numberBillingPeriodsInCalculations(self)

    def CVRMSE(self) -> "boost::optional< double >":
        return _openstudioutilitiesdata.CalibrationUtilityBill_CVRMSE(self)

    def NMBE(self) -> "boost::optional< double >":
        return _openstudioutilitiesdata.CalibrationUtilityBill_NMBE(self)

    def billingPeriods(self) -> "std::vector< openstudio::CalibrationBillingPeriod,std::allocator< openstudio::CalibrationBillingPeriod > >":
        return _openstudioutilitiesdata.CalibrationUtilityBill_billingPeriods(self)

    def addBillingPeriod(self, billingPeriod: "CalibrationBillingPeriod") -> "bool":
        return _openstudioutilitiesdata.CalibrationUtilityBill_addBillingPeriod(self, billingPeriod)
    __swig_destroy__ = _openstudioutilitiesdata.delete_CalibrationUtilityBill

# Register CalibrationUtilityBill in _openstudioutilitiesdata:
_openstudioutilitiesdata.CalibrationUtilityBill_swigregister(CalibrationUtilityBill)

def CalibrationUtilityBill_attributeName() -> "std::string":
    return _openstudioutilitiesdata.CalibrationUtilityBill_attributeName()

def CalibrationUtilityBill_fromAttribute(attribute: "Attribute") -> "boost::optional< openstudio::CalibrationUtilityBill >":
    return _openstudioutilitiesdata.CalibrationUtilityBill_fromAttribute(attribute)

class CalibrationResult(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def attributeName() -> "std::string":
        return _openstudioutilitiesdata.CalibrationResult_attributeName()

    @staticmethod
    def fromAttribute(attribute: "Attribute") -> "boost::optional< openstudio::CalibrationResult >":
        return _openstudioutilitiesdata.CalibrationResult_fromAttribute(attribute)

    def __init__(self):
        _openstudioutilitiesdata.CalibrationResult_swiginit(self, _openstudioutilitiesdata.new_CalibrationResult())

    def attribute(self) -> "openstudio::Attribute":
        return _openstudioutilitiesdata.CalibrationResult_attribute(self)

    def utilityBills(self) -> "std::vector< openstudio::CalibrationUtilityBill,std::allocator< openstudio::CalibrationUtilityBill > >":
        return _openstudioutilitiesdata.CalibrationResult_utilityBills(self)

    def addUtilityBill(self, utilityBill: "CalibrationUtilityBill") -> "bool":
        return _openstudioutilitiesdata.CalibrationResult_addUtilityBill(self, utilityBill)
    __swig_destroy__ = _openstudioutilitiesdata.delete_CalibrationResult

# Register CalibrationResult in _openstudioutilitiesdata:
_openstudioutilitiesdata.CalibrationResult_swigregister(CalibrationResult)

def CalibrationResult_attributeName() -> "std::string":
    return _openstudioutilitiesdata.CalibrationResult_attributeName()

def CalibrationResult_fromAttribute(attribute: "Attribute") -> "boost::optional< openstudio::CalibrationResult >":
    return _openstudioutilitiesdata.CalibrationResult_fromAttribute(attribute)

class OptionalEndUses(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudioutilitiesdata.OptionalEndUses_swiginit(self, _openstudioutilitiesdata.new_OptionalEndUses(*args))

    def reset(self) -> "void":
        return _openstudioutilitiesdata.OptionalEndUses_reset(self)

    def __ref__(self) -> "openstudio::EndUses":
        return _openstudioutilitiesdata.OptionalEndUses___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudioutilitiesdata.OptionalEndUses_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudioutilitiesdata.OptionalEndUses_isNull(self)

    def get(self) -> "openstudio::EndUses":
        return _openstudioutilitiesdata.OptionalEndUses_get(self)

    def set(self, t: "EndUses") -> "void":
        return _openstudioutilitiesdata.OptionalEndUses_set(self, t)
    __swig_destroy__ = _openstudioutilitiesdata.delete_OptionalEndUses

# Register OptionalEndUses in _openstudioutilitiesdata:
_openstudioutilitiesdata.OptionalEndUses_swigregister(OptionalEndUses)

class EndUsesVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.EndUsesVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.EndUsesVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.EndUsesVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::EndUses >::size_type":
        return _openstudioutilitiesdata.EndUsesVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::EndUses >::difference_type", j: "std::vector< openstudio::EndUses >::difference_type") -> "std::vector< openstudio::EndUses,std::allocator< openstudio::EndUses > > *":
        return _openstudioutilitiesdata.EndUsesVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUsesVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::EndUses >::difference_type", j: "std::vector< openstudio::EndUses >::difference_type") -> "void":
        return _openstudioutilitiesdata.EndUsesVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUsesVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::EndUses >::value_type const &":
        return _openstudioutilitiesdata.EndUsesVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUsesVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::EndUses >::value_type":
        return _openstudioutilitiesdata.EndUsesVector_pop(self)

    def append(self, x: "EndUses") -> "void":
        return _openstudioutilitiesdata.EndUsesVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.EndUsesVector_empty(self)

    def size(self) -> "std::vector< openstudio::EndUses >::size_type":
        return _openstudioutilitiesdata.EndUsesVector_size(self)

    def swap(self, v: "EndUsesVector") -> "void":
        return _openstudioutilitiesdata.EndUsesVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::EndUses >::iterator":
        return _openstudioutilitiesdata.EndUsesVector_begin(self)

    def end(self) -> "std::vector< openstudio::EndUses >::iterator":
        return _openstudioutilitiesdata.EndUsesVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::EndUses >::reverse_iterator":
        return _openstudioutilitiesdata.EndUsesVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::EndUses >::reverse_iterator":
        return _openstudioutilitiesdata.EndUsesVector_rend(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.EndUsesVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::EndUses >::allocator_type":
        return _openstudioutilitiesdata.EndUsesVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.EndUsesVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::EndUses >::iterator":
        return _openstudioutilitiesdata.EndUsesVector_erase(self, *args)

    def __init__(self, *args):
        _openstudioutilitiesdata.EndUsesVector_swiginit(self, _openstudioutilitiesdata.new_EndUsesVector(*args))

    def push_back(self, x: "EndUses") -> "void":
        return _openstudioutilitiesdata.EndUsesVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::EndUses >::value_type const &":
        return _openstudioutilitiesdata.EndUsesVector_front(self)

    def back(self) -> "std::vector< openstudio::EndUses >::value_type const &":
        return _openstudioutilitiesdata.EndUsesVector_back(self)

    def assign(self, n: "std::vector< openstudio::EndUses >::size_type", x: "EndUses") -> "void":
        return _openstudioutilitiesdata.EndUsesVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUsesVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUsesVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::EndUses >::size_type") -> "void":
        return _openstudioutilitiesdata.EndUsesVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::EndUses >::size_type":
        return _openstudioutilitiesdata.EndUsesVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_EndUsesVector

# Register EndUsesVector in _openstudioutilitiesdata:
_openstudioutilitiesdata.EndUsesVector_swigregister(EndUsesVector)

class EndUses(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def attributeName() -> "std::string":
        return _openstudioutilitiesdata.EndUses_attributeName()

    @staticmethod
    def getUnitsForFuelType(fuelType: "EndUseFuelType") -> "std::string":
        return _openstudioutilitiesdata.EndUses_getUnitsForFuelType(fuelType)

    @staticmethod
    def fuelTypes() -> "std::vector< openstudio::EndUseFuelType,std::allocator< openstudio::EndUseFuelType > >":
        return _openstudioutilitiesdata.EndUses_fuelTypes()

    @staticmethod
    def categories() -> "std::vector< openstudio::EndUseCategoryType,std::allocator< openstudio::EndUseCategoryType > >":
        return _openstudioutilitiesdata.EndUses_categories()

    @staticmethod
    def fromAttribute(attribute: "Attribute") -> "boost::optional< openstudio::EndUses >":
        return _openstudioutilitiesdata.EndUses_fromAttribute(attribute)

    def __init__(self):
        _openstudioutilitiesdata.EndUses_swiginit(self, _openstudioutilitiesdata.new_EndUses())

    def attribute(self) -> "openstudio::Attribute":
        return _openstudioutilitiesdata.EndUses_attribute(self)

    def addEndUse(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUses_addEndUse(self, *args)

    def getEndUse(self, *args) -> "double":
        return _openstudioutilitiesdata.EndUses_getEndUse(self, *args)

    def getEndUseByCategory(self, *args) -> "double":
        return _openstudioutilitiesdata.EndUses_getEndUseByCategory(self, *args)

    def getEndUseByFuelType(self, fuelType: "EndUseFuelType") -> "double":
        return _openstudioutilitiesdata.EndUses_getEndUseByFuelType(self, fuelType)

    def subCategories(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudioutilitiesdata.EndUses_subCategories(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_EndUses

# Register EndUses in _openstudioutilitiesdata:
_openstudioutilitiesdata.EndUses_swigregister(EndUses)

def EndUses_attributeName() -> "std::string":
    return _openstudioutilitiesdata.EndUses_attributeName()

def EndUses_getUnitsForFuelType(fuelType: "EndUseFuelType") -> "std::string":
    return _openstudioutilitiesdata.EndUses_getUnitsForFuelType(fuelType)

def EndUses_fuelTypes() -> "std::vector< openstudio::EndUseFuelType,std::allocator< openstudio::EndUseFuelType > >":
    return _openstudioutilitiesdata.EndUses_fuelTypes()

def EndUses_categories() -> "std::vector< openstudio::EndUseCategoryType,std::allocator< openstudio::EndUseCategoryType > >":
    return _openstudioutilitiesdata.EndUses_categories()

def EndUses_fromAttribute(attribute: "Attribute") -> "boost::optional< openstudio::EndUses >":
    return _openstudioutilitiesdata.EndUses_fromAttribute(attribute)

class DoubleFromVectorFunctor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _openstudioutilitiesdata.DoubleFromVectorFunctor_swiginit(self, _openstudioutilitiesdata.new_DoubleFromVectorFunctor())
    __swig_destroy__ = _openstudioutilitiesdata.delete_DoubleFromVectorFunctor

# Register DoubleFromVectorFunctor in _openstudioutilitiesdata:
_openstudioutilitiesdata.DoubleFromVectorFunctor_swigregister(DoubleFromVectorFunctor)

class VectorVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.VectorVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.VectorVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.VectorVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::Vector >::size_type":
        return _openstudioutilitiesdata.VectorVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::Vector >::difference_type", j: "std::vector< openstudio::Vector >::difference_type") -> "std::vector< openstudio::Vector,std::allocator< openstudio::Vector > > *":
        return _openstudioutilitiesdata.VectorVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.VectorVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::Vector >::difference_type", j: "std::vector< openstudio::Vector >::difference_type") -> "void":
        return _openstudioutilitiesdata.VectorVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.VectorVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::Vector >::value_type const &":
        return _openstudioutilitiesdata.VectorVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.VectorVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::Vector >::value_type":
        return _openstudioutilitiesdata.VectorVector_pop(self)

    def append(self, x: "Vector") -> "void":
        return _openstudioutilitiesdata.VectorVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.VectorVector_empty(self)

    def size(self) -> "std::vector< openstudio::Vector >::size_type":
        return _openstudioutilitiesdata.VectorVector_size(self)

    def swap(self, v: "VectorVector") -> "void":
        return _openstudioutilitiesdata.VectorVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::Vector >::iterator":
        return _openstudioutilitiesdata.VectorVector_begin(self)

    def end(self) -> "std::vector< openstudio::Vector >::iterator":
        return _openstudioutilitiesdata.VectorVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::Vector >::reverse_iterator":
        return _openstudioutilitiesdata.VectorVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::Vector >::reverse_iterator":
        return _openstudioutilitiesdata.VectorVector_rend(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.VectorVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::Vector >::allocator_type":
        return _openstudioutilitiesdata.VectorVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.VectorVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::Vector >::iterator":
        return _openstudioutilitiesdata.VectorVector_erase(self, *args)

    def __init__(self, *args):
        _openstudioutilitiesdata.VectorVector_swiginit(self, _openstudioutilitiesdata.new_VectorVector(*args))

    def push_back(self, x: "Vector") -> "void":
        return _openstudioutilitiesdata.VectorVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::Vector >::value_type const &":
        return _openstudioutilitiesdata.VectorVector_front(self)

    def back(self) -> "std::vector< openstudio::Vector >::value_type const &":
        return _openstudioutilitiesdata.VectorVector_back(self)

    def assign(self, n: "std::vector< openstudio::Vector >::size_type", x: "Vector") -> "void":
        return _openstudioutilitiesdata.VectorVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudioutilitiesdata.VectorVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.VectorVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::Vector >::size_type") -> "void":
        return _openstudioutilitiesdata.VectorVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::Vector >::size_type":
        return _openstudioutilitiesdata.VectorVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_VectorVector

# Register VectorVector in _openstudioutilitiesdata:
_openstudioutilitiesdata.VectorVector_swigregister(VectorVector)

class Vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudioutilitiesdata.Vector_swiginit(self, _openstudioutilitiesdata.new_Vector(*args))

    def size(self) -> "unsigned int":
        return _openstudioutilitiesdata.Vector_size(self)

    def resize(self, N: "unsigned int", preserve: "bool"=True) -> "void":
        return _openstudioutilitiesdata.Vector_resize(self, N, preserve)

    def __len__(self) -> "unsigned int":
        return _openstudioutilitiesdata.Vector___len__(self)

    def __getitem__(self, i: "unsigned int") -> "double":
        return _openstudioutilitiesdata.Vector___getitem__(self, i)

    def __setitem__(self, i: "unsigned int", x: "double") -> "void":
        return _openstudioutilitiesdata.Vector___setitem__(self, i, x)

    def __eq__(self, other: "Vector") -> "bool":
        return _openstudioutilitiesdata.Vector___eq__(self, other)

    def __add__(self, *args) -> "openstudio::Vector":
        return _openstudioutilitiesdata.Vector___add__(self, *args)

    def __sub__(self, *args) -> "openstudio::Vector":
        return _openstudioutilitiesdata.Vector___sub__(self, *args)

    def __mul__(self, d: "double") -> "openstudio::Vector":
        return _openstudioutilitiesdata.Vector___mul__(self, d)

    def __div__(self, d: "double") -> "openstudio::Vector":
        return _openstudioutilitiesdata.Vector___div__(self, d)

    def __str__(self) -> "std::string":
        return _openstudioutilitiesdata.Vector___str__(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_Vector

# Register Vector in _openstudioutilitiesdata:
_openstudioutilitiesdata.Vector_swigregister(Vector)


def createVector(values: "DoubleVector") -> "openstudio::Vector":
    return _openstudioutilitiesdata.createVector(values)

def __eq__(*args) -> "bool":
    return _openstudioutilitiesdata.__eq__(*args)

def __ne__(*args) -> "bool":
    return _openstudioutilitiesdata.__ne__(*args)
LinearInterp = _openstudioutilitiesdata.LinearInterp
NearestInterp = _openstudioutilitiesdata.NearestInterp
HoldLastInterp = _openstudioutilitiesdata.HoldLastInterp
HoldNextInterp = _openstudioutilitiesdata.HoldNextInterp
NoneExtrap = _openstudioutilitiesdata.NoneExtrap
NearestExtrap = _openstudioutilitiesdata.NearestExtrap
class InterpInfo(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    extrapolated = property(_openstudioutilitiesdata.InterpInfo_extrapolated_get, _openstudioutilitiesdata.InterpInfo_extrapolated_set)
    ia = property(_openstudioutilitiesdata.InterpInfo_ia_get, _openstudioutilitiesdata.InterpInfo_ia_set)
    ib = property(_openstudioutilitiesdata.InterpInfo_ib_get, _openstudioutilitiesdata.InterpInfo_ib_set)
    wa = property(_openstudioutilitiesdata.InterpInfo_wa_get, _openstudioutilitiesdata.InterpInfo_wa_set)
    wb = property(_openstudioutilitiesdata.InterpInfo_wb_get, _openstudioutilitiesdata.InterpInfo_wb_set)

    def __init__(self):
        _openstudioutilitiesdata.InterpInfo_swiginit(self, _openstudioutilitiesdata.new_InterpInfo())
    __swig_destroy__ = _openstudioutilitiesdata.delete_InterpInfo

# Register InterpInfo in _openstudioutilitiesdata:
_openstudioutilitiesdata.InterpInfo_swigregister(InterpInfo)


def interpInfo(x: "Vector", xi: "double") -> "openstudio::InterpInfo":
    return _openstudioutilitiesdata.interpInfo(x, xi)

def randVector(a: "double", b: "double", N: "unsigned int") -> "openstudio::Vector":
    return _openstudioutilitiesdata.randVector(a, b, N)

def linspace(a: "double", b: "double", N: "unsigned int") -> "openstudio::Vector":
    return _openstudioutilitiesdata.linspace(a, b, N)

def deltaSpace(a: "double", b: "double", delta: "double") -> "openstudio::Vector":
    return _openstudioutilitiesdata.deltaSpace(a, b, delta)

def logspace(a: "double", b: "double", N: "unsigned int", base: "double"=10.0) -> "openstudio::Vector":
    return _openstudioutilitiesdata.logspace(a, b, N, base)

def cumsum(x: "Vector", runningSum: "double"=0.0) -> "openstudio::Vector":
    return _openstudioutilitiesdata.cumsum(x, runningSum)

def dot(*args) -> "double":
    return _openstudioutilitiesdata.dot(*args)

def variance(vector: "Vector") -> "double":
    return _openstudioutilitiesdata.variance(vector)

def stdDev(vector: "Vector") -> "double":
    return _openstudioutilitiesdata.stdDev(vector)

def sumVectorFunctor() -> "boost::function1< double,openstudio::Vector const & >":
    return _openstudioutilitiesdata.sumVectorFunctor()

def maximumVectorFunctor() -> "boost::function1< double,openstudio::Vector const & >":
    return _openstudioutilitiesdata.maximumVectorFunctor()

def minimumVectorFunctor() -> "boost::function1< double,openstudio::Vector const & >":
    return _openstudioutilitiesdata.minimumVectorFunctor()

def meanVectorFunctor() -> "boost::function1< double,openstudio::Vector const & >":
    return _openstudioutilitiesdata.meanVectorFunctor()

def varianceVectorFunctor() -> "boost::function1< double,openstudio::Vector const & >":
    return _openstudioutilitiesdata.varianceVectorFunctor()

def stdDevVectorFunctor() -> "boost::function1< double,openstudio::Vector const & >":
    return _openstudioutilitiesdata.stdDevVectorFunctor()

def evaluateDoubleFromVectorFunctor(functor: "DoubleFromVectorFunctor", vector: "Vector") -> "double":
    return _openstudioutilitiesdata.evaluateDoubleFromVectorFunctor(functor, vector)
class MatrixVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.MatrixVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.MatrixVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.MatrixVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::Matrix >::size_type":
        return _openstudioutilitiesdata.MatrixVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::Matrix >::difference_type", j: "std::vector< openstudio::Matrix >::difference_type") -> "std::vector< openstudio::Matrix,std::allocator< openstudio::Matrix > > *":
        return _openstudioutilitiesdata.MatrixVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.MatrixVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::Matrix >::difference_type", j: "std::vector< openstudio::Matrix >::difference_type") -> "void":
        return _openstudioutilitiesdata.MatrixVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.MatrixVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::Matrix >::value_type const &":
        return _openstudioutilitiesdata.MatrixVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.MatrixVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::Matrix >::value_type":
        return _openstudioutilitiesdata.MatrixVector_pop(self)

    def append(self, x: "Matrix") -> "void":
        return _openstudioutilitiesdata.MatrixVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.MatrixVector_empty(self)

    def size(self) -> "std::vector< openstudio::Matrix >::size_type":
        return _openstudioutilitiesdata.MatrixVector_size(self)

    def swap(self, v: "MatrixVector") -> "void":
        return _openstudioutilitiesdata.MatrixVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::Matrix >::iterator":
        return _openstudioutilitiesdata.MatrixVector_begin(self)

    def end(self) -> "std::vector< openstudio::Matrix >::iterator":
        return _openstudioutilitiesdata.MatrixVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::Matrix >::reverse_iterator":
        return _openstudioutilitiesdata.MatrixVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::Matrix >::reverse_iterator":
        return _openstudioutilitiesdata.MatrixVector_rend(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.MatrixVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::Matrix >::allocator_type":
        return _openstudioutilitiesdata.MatrixVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.MatrixVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::Matrix >::iterator":
        return _openstudioutilitiesdata.MatrixVector_erase(self, *args)

    def __init__(self, *args):
        _openstudioutilitiesdata.MatrixVector_swiginit(self, _openstudioutilitiesdata.new_MatrixVector(*args))

    def push_back(self, x: "Matrix") -> "void":
        return _openstudioutilitiesdata.MatrixVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::Matrix >::value_type const &":
        return _openstudioutilitiesdata.MatrixVector_front(self)

    def back(self) -> "std::vector< openstudio::Matrix >::value_type const &":
        return _openstudioutilitiesdata.MatrixVector_back(self)

    def assign(self, n: "std::vector< openstudio::Matrix >::size_type", x: "Matrix") -> "void":
        return _openstudioutilitiesdata.MatrixVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudioutilitiesdata.MatrixVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.MatrixVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::Matrix >::size_type") -> "void":
        return _openstudioutilitiesdata.MatrixVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::Matrix >::size_type":
        return _openstudioutilitiesdata.MatrixVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_MatrixVector

# Register MatrixVector in _openstudioutilitiesdata:
_openstudioutilitiesdata.MatrixVector_swigregister(MatrixVector)

class Matrix(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudioutilitiesdata.Matrix_swiginit(self, _openstudioutilitiesdata.new_Matrix(*args))

    def size1(self) -> "unsigned int":
        return _openstudioutilitiesdata.Matrix_size1(self)

    def size2(self) -> "unsigned int":
        return _openstudioutilitiesdata.Matrix_size2(self)

    def resize(self, M: "unsigned int", N: "unsigned int", preserve: "bool") -> "void":
        return _openstudioutilitiesdata.Matrix_resize(self, M, N, preserve)

    def __getitem__(self, i: "unsigned int") -> "double":
        return _openstudioutilitiesdata.Matrix___getitem__(self, i)

    def __setitem__(self, i: "unsigned int", x: "double") -> "void":
        return _openstudioutilitiesdata.Matrix___setitem__(self, i, x)

    def __eq__(self, other: "Matrix") -> "bool":
        return _openstudioutilitiesdata.Matrix___eq__(self, other)

    def __add__(self, *args) -> "openstudio::Matrix":
        return _openstudioutilitiesdata.Matrix___add__(self, *args)

    def __sub__(self, *args) -> "openstudio::Matrix":
        return _openstudioutilitiesdata.Matrix___sub__(self, *args)

    def __mul__(self, *args) -> "openstudio::Matrix":
        return _openstudioutilitiesdata.Matrix___mul__(self, *args)

    def __div__(self, d: "double") -> "openstudio::Matrix":
        return _openstudioutilitiesdata.Matrix___div__(self, d)

    def __str__(self) -> "std::string":
        return _openstudioutilitiesdata.Matrix___str__(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_Matrix

# Register Matrix in _openstudioutilitiesdata:
_openstudioutilitiesdata.Matrix_swigregister(Matrix)


def interp(*args) -> "openstudio::Matrix":
    return _openstudioutilitiesdata.interp(*args)

def outerProd(lhs: "Vector", rhs: "Vector") -> "openstudio::Matrix":
    return _openstudioutilitiesdata.outerProd(lhs, rhs)

def log(*args) -> "openstudio::Matrix":
    return _openstudioutilitiesdata.log(*args)

def randMatrix(a: "double", b: "double", M: "unsigned int", N: "unsigned int") -> "openstudio::Matrix":
    return _openstudioutilitiesdata.randMatrix(a, b, M, N)

def maximum(*args) -> "double":
    return _openstudioutilitiesdata.maximum(*args)

def minimum(*args) -> "double":
    return _openstudioutilitiesdata.minimum(*args)

def mean(*args) -> "double":
    return _openstudioutilitiesdata.mean(*args)
class TimeSeriesPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _openstudioutilitiesdata.TimeSeriesPtr_swiginit(self, _openstudioutilitiesdata.new_TimeSeriesPtr())
    __swig_destroy__ = _openstudioutilitiesdata.delete_TimeSeriesPtr

# Register TimeSeriesPtr in _openstudioutilitiesdata:
_openstudioutilitiesdata.TimeSeriesPtr_swigregister(TimeSeriesPtr)

class OptionalTimeSeries(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudioutilitiesdata.OptionalTimeSeries_swiginit(self, _openstudioutilitiesdata.new_OptionalTimeSeries(*args))

    def reset(self) -> "void":
        return _openstudioutilitiesdata.OptionalTimeSeries_reset(self)

    def __ref__(self) -> "openstudio::TimeSeries":
        return _openstudioutilitiesdata.OptionalTimeSeries___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudioutilitiesdata.OptionalTimeSeries_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudioutilitiesdata.OptionalTimeSeries_isNull(self)

    def get(self) -> "openstudio::TimeSeries":
        return _openstudioutilitiesdata.OptionalTimeSeries_get(self)

    def set(self, t: "TimeSeries") -> "void":
        return _openstudioutilitiesdata.OptionalTimeSeries_set(self, t)
    __swig_destroy__ = _openstudioutilitiesdata.delete_OptionalTimeSeries

# Register OptionalTimeSeries in _openstudioutilitiesdata:
_openstudioutilitiesdata.OptionalTimeSeries_swigregister(OptionalTimeSeries)

class TimeSeriesPtrVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.TimeSeriesPtrVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.TimeSeriesPtrVector___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< openstudio::TimeSeries > >::size_type":
        return _openstudioutilitiesdata.TimeSeriesPtrVector___len__(self)

    def __getslice__(self, i: "std::vector< std::shared_ptr< openstudio::TimeSeries > >::difference_type", j: "std::vector< std::shared_ptr< openstudio::TimeSeries > >::difference_type") -> "std::vector< std::shared_ptr< openstudio::TimeSeries >,std::allocator< std::shared_ptr< openstudio::TimeSeries > > > *":
        return _openstudioutilitiesdata.TimeSeriesPtrVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.TimeSeriesPtrVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::shared_ptr< openstudio::TimeSeries > >::difference_type", j: "std::vector< std::shared_ptr< openstudio::TimeSeries > >::difference_type") -> "void":
        return _openstudioutilitiesdata.TimeSeriesPtrVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.TimeSeriesPtrVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< openstudio::TimeSeries > >::value_type const &":
        return _openstudioutilitiesdata.TimeSeriesPtrVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.TimeSeriesPtrVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< openstudio::TimeSeries > >::value_type":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_pop(self)

    def append(self, x: "TimeSeriesPtr") -> "void":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< openstudio::TimeSeries > >::size_type":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_size(self)

    def swap(self, v: "TimeSeriesPtrVector") -> "void":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< openstudio::TimeSeries > >::iterator":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< openstudio::TimeSeries > >::iterator":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< openstudio::TimeSeries > >::reverse_iterator":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< openstudio::TimeSeries > >::reverse_iterator":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_rend(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< openstudio::TimeSeries > >::allocator_type":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< openstudio::TimeSeries > >::iterator":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_erase(self, *args)

    def __init__(self, *args):
        _openstudioutilitiesdata.TimeSeriesPtrVector_swiginit(self, _openstudioutilitiesdata.new_TimeSeriesPtrVector(*args))

    def push_back(self, x: "TimeSeriesPtr") -> "void":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< openstudio::TimeSeries > >::value_type const &":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_front(self)

    def back(self) -> "std::vector< std::shared_ptr< openstudio::TimeSeries > >::value_type const &":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_back(self)

    def assign(self, n: "std::vector< std::shared_ptr< openstudio::TimeSeries > >::size_type", x: "TimeSeriesPtr") -> "void":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_insert(self, *args)

    def reserve(self, n: "std::vector< std::shared_ptr< openstudio::TimeSeries > >::size_type") -> "void":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< openstudio::TimeSeries > >::size_type":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_TimeSeriesPtrVector

# Register TimeSeriesPtrVector in _openstudioutilitiesdata:
_openstudioutilitiesdata.TimeSeriesPtrVector_swigregister(TimeSeriesPtrVector)

class TimeSeriesVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.TimeSeriesVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.TimeSeriesVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.TimeSeriesVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::TimeSeries >::size_type":
        return _openstudioutilitiesdata.TimeSeriesVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::TimeSeries >::difference_type", j: "std::vector< openstudio::TimeSeries >::difference_type") -> "std::vector< openstudio::TimeSeries,std::allocator< openstudio::TimeSeries > > *":
        return _openstudioutilitiesdata.TimeSeriesVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.TimeSeriesVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::TimeSeries >::difference_type", j: "std::vector< openstudio::TimeSeries >::difference_type") -> "void":
        return _openstudioutilitiesdata.TimeSeriesVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.TimeSeriesVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::TimeSeries >::value_type const &":
        return _openstudioutilitiesdata.TimeSeriesVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.TimeSeriesVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::TimeSeries >::value_type":
        return _openstudioutilitiesdata.TimeSeriesVector_pop(self)

    def append(self, x: "TimeSeries") -> "void":
        return _openstudioutilitiesdata.TimeSeriesVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.TimeSeriesVector_empty(self)

    def size(self) -> "std::vector< openstudio::TimeSeries >::size_type":
        return _openstudioutilitiesdata.TimeSeriesVector_size(self)

    def swap(self, v: "TimeSeriesVector") -> "void":
        return _openstudioutilitiesdata.TimeSeriesVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::TimeSeries >::iterator":
        return _openstudioutilitiesdata.TimeSeriesVector_begin(self)

    def end(self) -> "std::vector< openstudio::TimeSeries >::iterator":
        return _openstudioutilitiesdata.TimeSeriesVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::TimeSeries >::reverse_iterator":
        return _openstudioutilitiesdata.TimeSeriesVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::TimeSeries >::reverse_iterator":
        return _openstudioutilitiesdata.TimeSeriesVector_rend(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.TimeSeriesVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::TimeSeries >::allocator_type":
        return _openstudioutilitiesdata.TimeSeriesVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.TimeSeriesVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::TimeSeries >::iterator":
        return _openstudioutilitiesdata.TimeSeriesVector_erase(self, *args)

    def __init__(self, *args):
        _openstudioutilitiesdata.TimeSeriesVector_swiginit(self, _openstudioutilitiesdata.new_TimeSeriesVector(*args))

    def push_back(self, x: "TimeSeries") -> "void":
        return _openstudioutilitiesdata.TimeSeriesVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::TimeSeries >::value_type const &":
        return _openstudioutilitiesdata.TimeSeriesVector_front(self)

    def back(self) -> "std::vector< openstudio::TimeSeries >::value_type const &":
        return _openstudioutilitiesdata.TimeSeriesVector_back(self)

    def assign(self, n: "std::vector< openstudio::TimeSeries >::size_type", x: "TimeSeries") -> "void":
        return _openstudioutilitiesdata.TimeSeriesVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudioutilitiesdata.TimeSeriesVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.TimeSeriesVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::TimeSeries >::size_type") -> "void":
        return _openstudioutilitiesdata.TimeSeriesVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::TimeSeries >::size_type":
        return _openstudioutilitiesdata.TimeSeriesVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_TimeSeriesVector

# Register TimeSeriesVector in _openstudioutilitiesdata:
_openstudioutilitiesdata.TimeSeriesVector_swigregister(TimeSeriesVector)

class TimeSeriesFromTimeSeriesVectorFunctor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _openstudioutilitiesdata.TimeSeriesFromTimeSeriesVectorFunctor_swiginit(self, _openstudioutilitiesdata.new_TimeSeriesFromTimeSeriesVectorFunctor())
    __swig_destroy__ = _openstudioutilitiesdata.delete_TimeSeriesFromTimeSeriesVectorFunctor

# Register TimeSeriesFromTimeSeriesVectorFunctor in _openstudioutilitiesdata:
_openstudioutilitiesdata.TimeSeriesFromTimeSeriesVectorFunctor_swigregister(TimeSeriesFromTimeSeriesVectorFunctor)

class TimeSeries(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudioutilitiesdata.TimeSeries_swiginit(self, _openstudioutilitiesdata.new_TimeSeries(*args))
    __swig_destroy__ = _openstudioutilitiesdata.delete_TimeSeries

    def intervalLength(self) -> "openstudio::OptionalTime":
        return _openstudioutilitiesdata.TimeSeries_intervalLength(self)

    def dateTimes(self) -> "openstudio::DateTimeVector":
        return _openstudioutilitiesdata.TimeSeries_dateTimes(self)

    def firstReportDateTime(self) -> "openstudio::DateTime":
        return _openstudioutilitiesdata.TimeSeries_firstReportDateTime(self)

    def daysFromFirstReport(self, *args) -> "double":
        return _openstudioutilitiesdata.TimeSeries_daysFromFirstReport(self, *args)

    def secondsFromFirstReport(self, *args) -> "long":
        return _openstudioutilitiesdata.TimeSeries_secondsFromFirstReport(self, *args)

    def units(self) -> "std::string const":
        return _openstudioutilitiesdata.TimeSeries_units(self)

    def value(self, *args) -> "double":
        return _openstudioutilitiesdata.TimeSeries_value(self, *args)

    def values(self, *args) -> "openstudio::Vector":
        return _openstudioutilitiesdata.TimeSeries_values(self, *args)

    def outOfRangeValue(self) -> "double":
        return _openstudioutilitiesdata.TimeSeries_outOfRangeValue(self)

    def setOutOfRangeValue(self, value: "double") -> "void":
        return _openstudioutilitiesdata.TimeSeries_setOutOfRangeValue(self, value)

    def __add__(self, other: "TimeSeries") -> "openstudio::TimeSeries":
        return _openstudioutilitiesdata.TimeSeries___add__(self, other)

    def __sub__(self, other: "TimeSeries") -> "openstudio::TimeSeries":
        return _openstudioutilitiesdata.TimeSeries___sub__(self, other)

    def __mul__(self, d: "double") -> "openstudio::TimeSeries":
        return _openstudioutilitiesdata.TimeSeries___mul__(self, d)

    def __truediv__(self, *args):
        return _openstudioutilitiesdata.TimeSeries___truediv__(self, *args)
    __div__ = __truediv__



    def integrate(self) -> "double":
        return _openstudioutilitiesdata.TimeSeries_integrate(self)

    def averageValue(self) -> "double":
        return _openstudioutilitiesdata.TimeSeries_averageValue(self)

# Register TimeSeries in _openstudioutilitiesdata:
_openstudioutilitiesdata.TimeSeries_swigregister(TimeSeries)


def __mul__(*args) -> "openstudio::TimeSeries":
    return _openstudioutilitiesdata.__mul__(*args)

def sum(*args) -> "openstudio::TimeSeries":
    return _openstudioutilitiesdata.sum(*args)

def sumTimeSeriesFunctor() -> "boost::function1< openstudio::TimeSeries,std::vector< openstudio::TimeSeries,std::allocator< openstudio::TimeSeries > > const & >":
    return _openstudioutilitiesdata.sumTimeSeriesFunctor()

def evaluateTimeSeriesFromTimeSeriesVectorFunctor(functor: "TimeSeriesFromTimeSeriesVectorFunctor", timeSeriesVector: "TimeSeriesVector") -> "openstudio::TimeSeries":
    return _openstudioutilitiesdata.evaluateTimeSeriesFromTimeSeriesVectorFunctor(functor, timeSeriesVector)


