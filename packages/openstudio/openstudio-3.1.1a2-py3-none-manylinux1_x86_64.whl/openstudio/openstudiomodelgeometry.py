# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _openstudiomodelgeometry
else:
    import _openstudiomodelgeometry

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomodelgeometry.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _openstudiomodelgeometry.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _openstudiomodelgeometry.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _openstudiomodelgeometry.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _openstudiomodelgeometry.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _openstudiomodelgeometry.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _openstudiomodelgeometry.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _openstudiomodelgeometry.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _openstudiomodelgeometry.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _openstudiomodelgeometry.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _openstudiomodelgeometry.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _openstudiomodelgeometry.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _openstudiomodelgeometry:
_openstudiomodelgeometry.SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _openstudiomodelgeometry.SHARED_PTR_DISOWN
from .import openstudioutilities
from .import openstudioutilitiescore
from .import openstudioutilitiestime
from .import openstudioutilitiesdata
from .import openstudioutilitiesunits
from .import openstudioutilitiesplot
from .import openstudioutilitiesgeometry
from .import openstudioutilitiessql
from .import openstudioutilitiesbcl
from .import openstudioutilitiesidd
from .import openstudioutilitiesidf
from .import openstudioutilitiesfiletypes
from .import openstudiomodelcore
from .import openstudiomodelsimulation
from .import openstudiomodelresources

Model = openstudiomodelcore.Model

class OptionalSite(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalSite_swiginit(self, _openstudiomodelgeometry.new_OptionalSite(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSite_reset(self)

    def __ref__(self) -> "openstudio::model::Site":
        return _openstudiomodelgeometry.OptionalSite___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSite_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSite_isNull(self)

    def get(self) -> "openstudio::model::Site":
        return _openstudiomodelgeometry.OptionalSite_get(self)

    def set(self, t: "Site") -> "void":
        return _openstudiomodelgeometry.OptionalSite_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSite

# Register OptionalSite in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalSite_swigregister(OptionalSite)

class OptionalFacility(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalFacility_swiginit(self, _openstudiomodelgeometry.new_OptionalFacility(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalFacility_reset(self)

    def __ref__(self) -> "openstudio::model::Facility":
        return _openstudiomodelgeometry.OptionalFacility___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalFacility_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalFacility_isNull(self)

    def get(self) -> "openstudio::model::Facility":
        return _openstudiomodelgeometry.OptionalFacility_get(self)

    def set(self, t: "Facility") -> "void":
        return _openstudiomodelgeometry.OptionalFacility_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalFacility

# Register OptionalFacility in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalFacility_swigregister(OptionalFacility)

class OptionalBuilding(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalBuilding_swiginit(self, _openstudiomodelgeometry.new_OptionalBuilding(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalBuilding_reset(self)

    def __ref__(self) -> "openstudio::model::Building":
        return _openstudiomodelgeometry.OptionalBuilding___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalBuilding_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalBuilding_isNull(self)

    def get(self) -> "openstudio::model::Building":
        return _openstudiomodelgeometry.OptionalBuilding_get(self)

    def set(self, t: "Building") -> "void":
        return _openstudiomodelgeometry.OptionalBuilding_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalBuilding

# Register OptionalBuilding in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalBuilding_swigregister(OptionalBuilding)

class BuildingStoryVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.BuildingStoryVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.BuildingStoryVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.BuildingStoryVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::BuildingStory >::size_type":
        return _openstudiomodelgeometry.BuildingStoryVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::BuildingStory >::difference_type", j: "std::vector< openstudio::model::BuildingStory >::difference_type") -> "std::vector< openstudio::model::BuildingStory,std::allocator< openstudio::model::BuildingStory > > *":
        return _openstudiomodelgeometry.BuildingStoryVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.BuildingStoryVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::BuildingStory >::difference_type", j: "std::vector< openstudio::model::BuildingStory >::difference_type") -> "void":
        return _openstudiomodelgeometry.BuildingStoryVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.BuildingStoryVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::BuildingStory >::value_type const &":
        return _openstudiomodelgeometry.BuildingStoryVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.BuildingStoryVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::BuildingStory >::value_type":
        return _openstudiomodelgeometry.BuildingStoryVector_pop(self)

    def append(self, x: "BuildingStory") -> "void":
        return _openstudiomodelgeometry.BuildingStoryVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.BuildingStoryVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::BuildingStory >::size_type":
        return _openstudiomodelgeometry.BuildingStoryVector_size(self)

    def swap(self, v: "BuildingStoryVector") -> "void":
        return _openstudiomodelgeometry.BuildingStoryVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::BuildingStory >::iterator":
        return _openstudiomodelgeometry.BuildingStoryVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::BuildingStory >::iterator":
        return _openstudiomodelgeometry.BuildingStoryVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::BuildingStory >::reverse_iterator":
        return _openstudiomodelgeometry.BuildingStoryVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::BuildingStory >::reverse_iterator":
        return _openstudiomodelgeometry.BuildingStoryVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.BuildingStoryVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::BuildingStory >::allocator_type":
        return _openstudiomodelgeometry.BuildingStoryVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.BuildingStoryVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::BuildingStory >::iterator":
        return _openstudiomodelgeometry.BuildingStoryVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.BuildingStoryVector_swiginit(self, _openstudiomodelgeometry.new_BuildingStoryVector(*args))

    def push_back(self, x: "BuildingStory") -> "void":
        return _openstudiomodelgeometry.BuildingStoryVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::BuildingStory >::value_type const &":
        return _openstudiomodelgeometry.BuildingStoryVector_front(self)

    def back(self) -> "std::vector< openstudio::model::BuildingStory >::value_type const &":
        return _openstudiomodelgeometry.BuildingStoryVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::BuildingStory >::size_type", x: "BuildingStory") -> "void":
        return _openstudiomodelgeometry.BuildingStoryVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::BuildingStory >::size_type", x: "BuildingStory") -> "void":
        return _openstudiomodelgeometry.BuildingStoryVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.BuildingStoryVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::BuildingStory >::size_type") -> "void":
        return _openstudiomodelgeometry.BuildingStoryVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::BuildingStory >::size_type":
        return _openstudiomodelgeometry.BuildingStoryVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_BuildingStoryVector

# Register BuildingStoryVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.BuildingStoryVector_swigregister(BuildingStoryVector)

class OptionalBuildingStory(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalBuildingStory_swiginit(self, _openstudiomodelgeometry.new_OptionalBuildingStory(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalBuildingStory_reset(self)

    def __ref__(self) -> "openstudio::model::BuildingStory":
        return _openstudiomodelgeometry.OptionalBuildingStory___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalBuildingStory_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalBuildingStory_isNull(self)

    def get(self) -> "openstudio::model::BuildingStory":
        return _openstudiomodelgeometry.OptionalBuildingStory_get(self)

    def set(self, t: "BuildingStory") -> "void":
        return _openstudiomodelgeometry.OptionalBuildingStory_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalBuildingStory

# Register OptionalBuildingStory in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalBuildingStory_swigregister(OptionalBuildingStory)

class BuildingUnitVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.BuildingUnitVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.BuildingUnitVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.BuildingUnitVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::BuildingUnit >::size_type":
        return _openstudiomodelgeometry.BuildingUnitVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::BuildingUnit >::difference_type", j: "std::vector< openstudio::model::BuildingUnit >::difference_type") -> "std::vector< openstudio::model::BuildingUnit,std::allocator< openstudio::model::BuildingUnit > > *":
        return _openstudiomodelgeometry.BuildingUnitVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.BuildingUnitVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::BuildingUnit >::difference_type", j: "std::vector< openstudio::model::BuildingUnit >::difference_type") -> "void":
        return _openstudiomodelgeometry.BuildingUnitVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.BuildingUnitVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::BuildingUnit >::value_type const &":
        return _openstudiomodelgeometry.BuildingUnitVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.BuildingUnitVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::BuildingUnit >::value_type":
        return _openstudiomodelgeometry.BuildingUnitVector_pop(self)

    def append(self, x: "BuildingUnit") -> "void":
        return _openstudiomodelgeometry.BuildingUnitVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.BuildingUnitVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::BuildingUnit >::size_type":
        return _openstudiomodelgeometry.BuildingUnitVector_size(self)

    def swap(self, v: "BuildingUnitVector") -> "void":
        return _openstudiomodelgeometry.BuildingUnitVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::BuildingUnit >::iterator":
        return _openstudiomodelgeometry.BuildingUnitVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::BuildingUnit >::iterator":
        return _openstudiomodelgeometry.BuildingUnitVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::BuildingUnit >::reverse_iterator":
        return _openstudiomodelgeometry.BuildingUnitVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::BuildingUnit >::reverse_iterator":
        return _openstudiomodelgeometry.BuildingUnitVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.BuildingUnitVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::BuildingUnit >::allocator_type":
        return _openstudiomodelgeometry.BuildingUnitVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.BuildingUnitVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::BuildingUnit >::iterator":
        return _openstudiomodelgeometry.BuildingUnitVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.BuildingUnitVector_swiginit(self, _openstudiomodelgeometry.new_BuildingUnitVector(*args))

    def push_back(self, x: "BuildingUnit") -> "void":
        return _openstudiomodelgeometry.BuildingUnitVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::BuildingUnit >::value_type const &":
        return _openstudiomodelgeometry.BuildingUnitVector_front(self)

    def back(self) -> "std::vector< openstudio::model::BuildingUnit >::value_type const &":
        return _openstudiomodelgeometry.BuildingUnitVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::BuildingUnit >::size_type", x: "BuildingUnit") -> "void":
        return _openstudiomodelgeometry.BuildingUnitVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::BuildingUnit >::size_type", x: "BuildingUnit") -> "void":
        return _openstudiomodelgeometry.BuildingUnitVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.BuildingUnitVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::BuildingUnit >::size_type") -> "void":
        return _openstudiomodelgeometry.BuildingUnitVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::BuildingUnit >::size_type":
        return _openstudiomodelgeometry.BuildingUnitVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_BuildingUnitVector

# Register BuildingUnitVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.BuildingUnitVector_swigregister(BuildingUnitVector)

class OptionalBuildingUnit(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalBuildingUnit_swiginit(self, _openstudiomodelgeometry.new_OptionalBuildingUnit(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalBuildingUnit_reset(self)

    def __ref__(self) -> "openstudio::model::BuildingUnit":
        return _openstudiomodelgeometry.OptionalBuildingUnit___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalBuildingUnit_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalBuildingUnit_isNull(self)

    def get(self) -> "openstudio::model::BuildingUnit":
        return _openstudiomodelgeometry.OptionalBuildingUnit_get(self)

    def set(self, t: "BuildingUnit") -> "void":
        return _openstudiomodelgeometry.OptionalBuildingUnit_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalBuildingUnit

# Register OptionalBuildingUnit in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalBuildingUnit_swigregister(OptionalBuildingUnit)

class PlanarSurfaceGroupVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::PlanarSurfaceGroup >::size_type":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::PlanarSurfaceGroup >::difference_type", j: "std::vector< openstudio::model::PlanarSurfaceGroup >::difference_type") -> "std::vector< openstudio::model::PlanarSurfaceGroup,std::allocator< openstudio::model::PlanarSurfaceGroup > > *":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::PlanarSurfaceGroup >::difference_type", j: "std::vector< openstudio::model::PlanarSurfaceGroup >::difference_type") -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::PlanarSurfaceGroup >::value_type const &":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::PlanarSurfaceGroup >::value_type":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_pop(self)

    def append(self, x: "PlanarSurfaceGroup") -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::PlanarSurfaceGroup >::size_type":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_size(self)

    def swap(self, v: "PlanarSurfaceGroupVector") -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::PlanarSurfaceGroup >::iterator":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::PlanarSurfaceGroup >::iterator":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::PlanarSurfaceGroup >::reverse_iterator":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::PlanarSurfaceGroup >::reverse_iterator":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::PlanarSurfaceGroup >::allocator_type":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::PlanarSurfaceGroup >::iterator":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.PlanarSurfaceGroupVector_swiginit(self, _openstudiomodelgeometry.new_PlanarSurfaceGroupVector(*args))

    def push_back(self, x: "PlanarSurfaceGroup") -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::PlanarSurfaceGroup >::value_type const &":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_front(self)

    def back(self) -> "std::vector< openstudio::model::PlanarSurfaceGroup >::value_type const &":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::PlanarSurfaceGroup >::size_type", x: "PlanarSurfaceGroup") -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::PlanarSurfaceGroup >::size_type", x: "PlanarSurfaceGroup") -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::PlanarSurfaceGroup >::size_type") -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::PlanarSurfaceGroup >::size_type":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_PlanarSurfaceGroupVector

# Register PlanarSurfaceGroupVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.PlanarSurfaceGroupVector_swigregister(PlanarSurfaceGroupVector)

class OptionalPlanarSurfaceGroup(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalPlanarSurfaceGroup_swiginit(self, _openstudiomodelgeometry.new_OptionalPlanarSurfaceGroup(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalPlanarSurfaceGroup_reset(self)

    def __ref__(self) -> "openstudio::model::PlanarSurfaceGroup":
        return _openstudiomodelgeometry.OptionalPlanarSurfaceGroup___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalPlanarSurfaceGroup_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalPlanarSurfaceGroup_isNull(self)

    def get(self) -> "openstudio::model::PlanarSurfaceGroup":
        return _openstudiomodelgeometry.OptionalPlanarSurfaceGroup_get(self)

    def set(self, t: "PlanarSurfaceGroup") -> "void":
        return _openstudiomodelgeometry.OptionalPlanarSurfaceGroup_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalPlanarSurfaceGroup

# Register OptionalPlanarSurfaceGroup in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalPlanarSurfaceGroup_swigregister(OptionalPlanarSurfaceGroup)

class SpaceVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SpaceVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SpaceVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SpaceVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::Space >::size_type":
        return _openstudiomodelgeometry.SpaceVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::Space >::difference_type", j: "std::vector< openstudio::model::Space >::difference_type") -> "std::vector< openstudio::model::Space,std::allocator< openstudio::model::Space > > *":
        return _openstudiomodelgeometry.SpaceVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::Space >::difference_type", j: "std::vector< openstudio::model::Space >::difference_type") -> "void":
        return _openstudiomodelgeometry.SpaceVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::Space >::value_type const &":
        return _openstudiomodelgeometry.SpaceVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::Space >::value_type":
        return _openstudiomodelgeometry.SpaceVector_pop(self)

    def append(self, x: "Space") -> "void":
        return _openstudiomodelgeometry.SpaceVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SpaceVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::Space >::size_type":
        return _openstudiomodelgeometry.SpaceVector_size(self)

    def swap(self, v: "SpaceVector") -> "void":
        return _openstudiomodelgeometry.SpaceVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::Space >::iterator":
        return _openstudiomodelgeometry.SpaceVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::Space >::iterator":
        return _openstudiomodelgeometry.SpaceVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::Space >::reverse_iterator":
        return _openstudiomodelgeometry.SpaceVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::Space >::reverse_iterator":
        return _openstudiomodelgeometry.SpaceVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SpaceVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::Space >::allocator_type":
        return _openstudiomodelgeometry.SpaceVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SpaceVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::Space >::iterator":
        return _openstudiomodelgeometry.SpaceVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.SpaceVector_swiginit(self, _openstudiomodelgeometry.new_SpaceVector(*args))

    def push_back(self, x: "Space") -> "void":
        return _openstudiomodelgeometry.SpaceVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::Space >::value_type const &":
        return _openstudiomodelgeometry.SpaceVector_front(self)

    def back(self) -> "std::vector< openstudio::model::Space >::value_type const &":
        return _openstudiomodelgeometry.SpaceVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::Space >::size_type", x: "Space") -> "void":
        return _openstudiomodelgeometry.SpaceVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::Space >::size_type", x: "Space") -> "void":
        return _openstudiomodelgeometry.SpaceVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::Space >::size_type") -> "void":
        return _openstudiomodelgeometry.SpaceVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::Space >::size_type":
        return _openstudiomodelgeometry.SpaceVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SpaceVector

# Register SpaceVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.SpaceVector_swigregister(SpaceVector)

class OptionalSpace(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalSpace_swiginit(self, _openstudiomodelgeometry.new_OptionalSpace(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSpace_reset(self)

    def __ref__(self) -> "openstudio::model::Space":
        return _openstudiomodelgeometry.OptionalSpace___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSpace_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSpace_isNull(self)

    def get(self) -> "openstudio::model::Space":
        return _openstudiomodelgeometry.OptionalSpace_get(self)

    def set(self, t: "Space") -> "void":
        return _openstudiomodelgeometry.OptionalSpace_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSpace

# Register OptionalSpace in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalSpace_swigregister(OptionalSpace)

class SpaceItemVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SpaceItemVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SpaceItemVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SpaceItemVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::SpaceItem >::size_type":
        return _openstudiomodelgeometry.SpaceItemVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::SpaceItem >::difference_type", j: "std::vector< openstudio::model::SpaceItem >::difference_type") -> "std::vector< openstudio::model::SpaceItem,std::allocator< openstudio::model::SpaceItem > > *":
        return _openstudiomodelgeometry.SpaceItemVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceItemVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::SpaceItem >::difference_type", j: "std::vector< openstudio::model::SpaceItem >::difference_type") -> "void":
        return _openstudiomodelgeometry.SpaceItemVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceItemVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::SpaceItem >::value_type const &":
        return _openstudiomodelgeometry.SpaceItemVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceItemVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::SpaceItem >::value_type":
        return _openstudiomodelgeometry.SpaceItemVector_pop(self)

    def append(self, x: "SpaceItem") -> "void":
        return _openstudiomodelgeometry.SpaceItemVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SpaceItemVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::SpaceItem >::size_type":
        return _openstudiomodelgeometry.SpaceItemVector_size(self)

    def swap(self, v: "SpaceItemVector") -> "void":
        return _openstudiomodelgeometry.SpaceItemVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::SpaceItem >::iterator":
        return _openstudiomodelgeometry.SpaceItemVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::SpaceItem >::iterator":
        return _openstudiomodelgeometry.SpaceItemVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::SpaceItem >::reverse_iterator":
        return _openstudiomodelgeometry.SpaceItemVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::SpaceItem >::reverse_iterator":
        return _openstudiomodelgeometry.SpaceItemVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SpaceItemVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::SpaceItem >::allocator_type":
        return _openstudiomodelgeometry.SpaceItemVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SpaceItemVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::SpaceItem >::iterator":
        return _openstudiomodelgeometry.SpaceItemVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.SpaceItemVector_swiginit(self, _openstudiomodelgeometry.new_SpaceItemVector(*args))

    def push_back(self, x: "SpaceItem") -> "void":
        return _openstudiomodelgeometry.SpaceItemVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::SpaceItem >::value_type const &":
        return _openstudiomodelgeometry.SpaceItemVector_front(self)

    def back(self) -> "std::vector< openstudio::model::SpaceItem >::value_type const &":
        return _openstudiomodelgeometry.SpaceItemVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::SpaceItem >::size_type", x: "SpaceItem") -> "void":
        return _openstudiomodelgeometry.SpaceItemVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::SpaceItem >::size_type", x: "SpaceItem") -> "void":
        return _openstudiomodelgeometry.SpaceItemVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceItemVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::SpaceItem >::size_type") -> "void":
        return _openstudiomodelgeometry.SpaceItemVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::SpaceItem >::size_type":
        return _openstudiomodelgeometry.SpaceItemVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SpaceItemVector

# Register SpaceItemVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.SpaceItemVector_swigregister(SpaceItemVector)

class OptionalSpaceItem(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalSpaceItem_swiginit(self, _openstudiomodelgeometry.new_OptionalSpaceItem(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSpaceItem_reset(self)

    def __ref__(self) -> "openstudio::model::SpaceItem":
        return _openstudiomodelgeometry.OptionalSpaceItem___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSpaceItem_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSpaceItem_isNull(self)

    def get(self) -> "openstudio::model::SpaceItem":
        return _openstudiomodelgeometry.OptionalSpaceItem_get(self)

    def set(self, t: "SpaceItem") -> "void":
        return _openstudiomodelgeometry.OptionalSpaceItem_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSpaceItem

# Register OptionalSpaceItem in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalSpaceItem_swigregister(OptionalSpaceItem)

class SpaceLoadVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SpaceLoadVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SpaceLoadVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SpaceLoadVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::SpaceLoad >::size_type":
        return _openstudiomodelgeometry.SpaceLoadVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::SpaceLoad >::difference_type", j: "std::vector< openstudio::model::SpaceLoad >::difference_type") -> "std::vector< openstudio::model::SpaceLoad,std::allocator< openstudio::model::SpaceLoad > > *":
        return _openstudiomodelgeometry.SpaceLoadVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceLoadVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::SpaceLoad >::difference_type", j: "std::vector< openstudio::model::SpaceLoad >::difference_type") -> "void":
        return _openstudiomodelgeometry.SpaceLoadVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceLoadVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::SpaceLoad >::value_type const &":
        return _openstudiomodelgeometry.SpaceLoadVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceLoadVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::SpaceLoad >::value_type":
        return _openstudiomodelgeometry.SpaceLoadVector_pop(self)

    def append(self, x: "SpaceLoad") -> "void":
        return _openstudiomodelgeometry.SpaceLoadVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SpaceLoadVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::SpaceLoad >::size_type":
        return _openstudiomodelgeometry.SpaceLoadVector_size(self)

    def swap(self, v: "SpaceLoadVector") -> "void":
        return _openstudiomodelgeometry.SpaceLoadVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::SpaceLoad >::iterator":
        return _openstudiomodelgeometry.SpaceLoadVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::SpaceLoad >::iterator":
        return _openstudiomodelgeometry.SpaceLoadVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::SpaceLoad >::reverse_iterator":
        return _openstudiomodelgeometry.SpaceLoadVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::SpaceLoad >::reverse_iterator":
        return _openstudiomodelgeometry.SpaceLoadVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SpaceLoadVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::SpaceLoad >::allocator_type":
        return _openstudiomodelgeometry.SpaceLoadVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SpaceLoadVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::SpaceLoad >::iterator":
        return _openstudiomodelgeometry.SpaceLoadVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.SpaceLoadVector_swiginit(self, _openstudiomodelgeometry.new_SpaceLoadVector(*args))

    def push_back(self, x: "SpaceLoad") -> "void":
        return _openstudiomodelgeometry.SpaceLoadVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::SpaceLoad >::value_type const &":
        return _openstudiomodelgeometry.SpaceLoadVector_front(self)

    def back(self) -> "std::vector< openstudio::model::SpaceLoad >::value_type const &":
        return _openstudiomodelgeometry.SpaceLoadVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::SpaceLoad >::size_type", x: "SpaceLoad") -> "void":
        return _openstudiomodelgeometry.SpaceLoadVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::SpaceLoad >::size_type", x: "SpaceLoad") -> "void":
        return _openstudiomodelgeometry.SpaceLoadVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceLoadVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::SpaceLoad >::size_type") -> "void":
        return _openstudiomodelgeometry.SpaceLoadVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::SpaceLoad >::size_type":
        return _openstudiomodelgeometry.SpaceLoadVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SpaceLoadVector

# Register SpaceLoadVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.SpaceLoadVector_swigregister(SpaceLoadVector)

class OptionalSpaceLoad(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalSpaceLoad_swiginit(self, _openstudiomodelgeometry.new_OptionalSpaceLoad(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSpaceLoad_reset(self)

    def __ref__(self) -> "openstudio::model::SpaceLoad":
        return _openstudiomodelgeometry.OptionalSpaceLoad___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSpaceLoad_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSpaceLoad_isNull(self)

    def get(self) -> "openstudio::model::SpaceLoad":
        return _openstudiomodelgeometry.OptionalSpaceLoad_get(self)

    def set(self, t: "SpaceLoad") -> "void":
        return _openstudiomodelgeometry.OptionalSpaceLoad_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSpaceLoad

# Register OptionalSpaceLoad in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalSpaceLoad_swigregister(OptionalSpaceLoad)

class SpaceLoadInstanceVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::SpaceLoadInstance >::size_type":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::SpaceLoadInstance >::difference_type", j: "std::vector< openstudio::model::SpaceLoadInstance >::difference_type") -> "std::vector< openstudio::model::SpaceLoadInstance,std::allocator< openstudio::model::SpaceLoadInstance > > *":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::SpaceLoadInstance >::difference_type", j: "std::vector< openstudio::model::SpaceLoadInstance >::difference_type") -> "void":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::SpaceLoadInstance >::value_type const &":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::SpaceLoadInstance >::value_type":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_pop(self)

    def append(self, x: "SpaceLoadInstance") -> "void":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::SpaceLoadInstance >::size_type":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_size(self)

    def swap(self, v: "SpaceLoadInstanceVector") -> "void":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::SpaceLoadInstance >::iterator":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::SpaceLoadInstance >::iterator":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::SpaceLoadInstance >::reverse_iterator":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::SpaceLoadInstance >::reverse_iterator":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::SpaceLoadInstance >::allocator_type":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::SpaceLoadInstance >::iterator":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.SpaceLoadInstanceVector_swiginit(self, _openstudiomodelgeometry.new_SpaceLoadInstanceVector(*args))

    def push_back(self, x: "SpaceLoadInstance") -> "void":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::SpaceLoadInstance >::value_type const &":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_front(self)

    def back(self) -> "std::vector< openstudio::model::SpaceLoadInstance >::value_type const &":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::SpaceLoadInstance >::size_type", x: "SpaceLoadInstance") -> "void":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::SpaceLoadInstance >::size_type", x: "SpaceLoadInstance") -> "void":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::SpaceLoadInstance >::size_type") -> "void":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::SpaceLoadInstance >::size_type":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SpaceLoadInstanceVector

# Register SpaceLoadInstanceVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.SpaceLoadInstanceVector_swigregister(SpaceLoadInstanceVector)

class OptionalSpaceLoadInstance(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalSpaceLoadInstance_swiginit(self, _openstudiomodelgeometry.new_OptionalSpaceLoadInstance(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSpaceLoadInstance_reset(self)

    def __ref__(self) -> "openstudio::model::SpaceLoadInstance":
        return _openstudiomodelgeometry.OptionalSpaceLoadInstance___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSpaceLoadInstance_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSpaceLoadInstance_isNull(self)

    def get(self) -> "openstudio::model::SpaceLoadInstance":
        return _openstudiomodelgeometry.OptionalSpaceLoadInstance_get(self)

    def set(self, t: "SpaceLoadInstance") -> "void":
        return _openstudiomodelgeometry.OptionalSpaceLoadInstance_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSpaceLoadInstance

# Register OptionalSpaceLoadInstance in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalSpaceLoadInstance_swigregister(OptionalSpaceLoadInstance)

class LightsVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.LightsVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.LightsVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.LightsVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::Lights >::size_type":
        return _openstudiomodelgeometry.LightsVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::Lights >::difference_type", j: "std::vector< openstudio::model::Lights >::difference_type") -> "std::vector< openstudio::model::Lights,std::allocator< openstudio::model::Lights > > *":
        return _openstudiomodelgeometry.LightsVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.LightsVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::Lights >::difference_type", j: "std::vector< openstudio::model::Lights >::difference_type") -> "void":
        return _openstudiomodelgeometry.LightsVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.LightsVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::Lights >::value_type const &":
        return _openstudiomodelgeometry.LightsVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.LightsVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::Lights >::value_type":
        return _openstudiomodelgeometry.LightsVector_pop(self)

    def append(self, x: "Lights") -> "void":
        return _openstudiomodelgeometry.LightsVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.LightsVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::Lights >::size_type":
        return _openstudiomodelgeometry.LightsVector_size(self)

    def swap(self, v: "LightsVector") -> "void":
        return _openstudiomodelgeometry.LightsVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::Lights >::iterator":
        return _openstudiomodelgeometry.LightsVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::Lights >::iterator":
        return _openstudiomodelgeometry.LightsVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::Lights >::reverse_iterator":
        return _openstudiomodelgeometry.LightsVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::Lights >::reverse_iterator":
        return _openstudiomodelgeometry.LightsVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.LightsVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::Lights >::allocator_type":
        return _openstudiomodelgeometry.LightsVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.LightsVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::Lights >::iterator":
        return _openstudiomodelgeometry.LightsVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.LightsVector_swiginit(self, _openstudiomodelgeometry.new_LightsVector(*args))

    def push_back(self, x: "Lights") -> "void":
        return _openstudiomodelgeometry.LightsVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::Lights >::value_type const &":
        return _openstudiomodelgeometry.LightsVector_front(self)

    def back(self) -> "std::vector< openstudio::model::Lights >::value_type const &":
        return _openstudiomodelgeometry.LightsVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::Lights >::size_type", x: "Lights") -> "void":
        return _openstudiomodelgeometry.LightsVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::Lights >::size_type", x: "Lights") -> "void":
        return _openstudiomodelgeometry.LightsVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.LightsVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::Lights >::size_type") -> "void":
        return _openstudiomodelgeometry.LightsVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::Lights >::size_type":
        return _openstudiomodelgeometry.LightsVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_LightsVector

# Register LightsVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.LightsVector_swigregister(LightsVector)

class OptionalLights(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalLights_swiginit(self, _openstudiomodelgeometry.new_OptionalLights(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalLights_reset(self)

    def __ref__(self) -> "openstudio::model::Lights":
        return _openstudiomodelgeometry.OptionalLights___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalLights_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalLights_isNull(self)

    def get(self) -> "openstudio::model::Lights":
        return _openstudiomodelgeometry.OptionalLights_get(self)

    def set(self, t: "Lights") -> "void":
        return _openstudiomodelgeometry.OptionalLights_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalLights

# Register OptionalLights in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalLights_swigregister(OptionalLights)

class PlanarSurfaceVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.PlanarSurfaceVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::PlanarSurface >::size_type":
        return _openstudiomodelgeometry.PlanarSurfaceVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::PlanarSurface >::difference_type", j: "std::vector< openstudio::model::PlanarSurface >::difference_type") -> "std::vector< openstudio::model::PlanarSurface,std::allocator< openstudio::model::PlanarSurface > > *":
        return _openstudiomodelgeometry.PlanarSurfaceVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::PlanarSurface >::difference_type", j: "std::vector< openstudio::model::PlanarSurface >::difference_type") -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::PlanarSurface >::value_type const &":
        return _openstudiomodelgeometry.PlanarSurfaceVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::PlanarSurface >::value_type":
        return _openstudiomodelgeometry.PlanarSurfaceVector_pop(self)

    def append(self, x: "PlanarSurface") -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::PlanarSurface >::size_type":
        return _openstudiomodelgeometry.PlanarSurfaceVector_size(self)

    def swap(self, v: "PlanarSurfaceVector") -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::PlanarSurface >::iterator":
        return _openstudiomodelgeometry.PlanarSurfaceVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::PlanarSurface >::iterator":
        return _openstudiomodelgeometry.PlanarSurfaceVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::PlanarSurface >::reverse_iterator":
        return _openstudiomodelgeometry.PlanarSurfaceVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::PlanarSurface >::reverse_iterator":
        return _openstudiomodelgeometry.PlanarSurfaceVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::PlanarSurface >::allocator_type":
        return _openstudiomodelgeometry.PlanarSurfaceVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::PlanarSurface >::iterator":
        return _openstudiomodelgeometry.PlanarSurfaceVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.PlanarSurfaceVector_swiginit(self, _openstudiomodelgeometry.new_PlanarSurfaceVector(*args))

    def push_back(self, x: "PlanarSurface") -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::PlanarSurface >::value_type const &":
        return _openstudiomodelgeometry.PlanarSurfaceVector_front(self)

    def back(self) -> "std::vector< openstudio::model::PlanarSurface >::value_type const &":
        return _openstudiomodelgeometry.PlanarSurfaceVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::PlanarSurface >::size_type", x: "PlanarSurface") -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::PlanarSurface >::size_type", x: "PlanarSurface") -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::PlanarSurface >::size_type") -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::PlanarSurface >::size_type":
        return _openstudiomodelgeometry.PlanarSurfaceVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_PlanarSurfaceVector

# Register PlanarSurfaceVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.PlanarSurfaceVector_swigregister(PlanarSurfaceVector)

class OptionalPlanarSurface(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalPlanarSurface_swiginit(self, _openstudiomodelgeometry.new_OptionalPlanarSurface(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalPlanarSurface_reset(self)

    def __ref__(self) -> "openstudio::model::PlanarSurface":
        return _openstudiomodelgeometry.OptionalPlanarSurface___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalPlanarSurface_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalPlanarSurface_isNull(self)

    def get(self) -> "openstudio::model::PlanarSurface":
        return _openstudiomodelgeometry.OptionalPlanarSurface_get(self)

    def set(self, t: "PlanarSurface") -> "void":
        return _openstudiomodelgeometry.OptionalPlanarSurface_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalPlanarSurface

# Register OptionalPlanarSurface in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalPlanarSurface_swigregister(OptionalPlanarSurface)

class DefaultConstructionSetVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.DefaultConstructionSetVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.DefaultConstructionSetVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::DefaultConstructionSet >::size_type":
        return _openstudiomodelgeometry.DefaultConstructionSetVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::DefaultConstructionSet >::difference_type", j: "std::vector< openstudio::model::DefaultConstructionSet >::difference_type") -> "std::vector< openstudio::model::DefaultConstructionSet,std::allocator< openstudio::model::DefaultConstructionSet > > *":
        return _openstudiomodelgeometry.DefaultConstructionSetVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSetVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::DefaultConstructionSet >::difference_type", j: "std::vector< openstudio::model::DefaultConstructionSet >::difference_type") -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSetVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSetVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::DefaultConstructionSet >::value_type const &":
        return _openstudiomodelgeometry.DefaultConstructionSetVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSetVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::DefaultConstructionSet >::value_type":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_pop(self)

    def append(self, x: "DefaultConstructionSet") -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::DefaultConstructionSet >::size_type":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_size(self)

    def swap(self, v: "DefaultConstructionSetVector") -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::DefaultConstructionSet >::iterator":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::DefaultConstructionSet >::iterator":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::DefaultConstructionSet >::reverse_iterator":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::DefaultConstructionSet >::reverse_iterator":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::DefaultConstructionSet >::allocator_type":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::DefaultConstructionSet >::iterator":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.DefaultConstructionSetVector_swiginit(self, _openstudiomodelgeometry.new_DefaultConstructionSetVector(*args))

    def push_back(self, x: "DefaultConstructionSet") -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::DefaultConstructionSet >::value_type const &":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_front(self)

    def back(self) -> "std::vector< openstudio::model::DefaultConstructionSet >::value_type const &":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::DefaultConstructionSet >::size_type", x: "DefaultConstructionSet") -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::DefaultConstructionSet >::size_type", x: "DefaultConstructionSet") -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::DefaultConstructionSet >::size_type") -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::DefaultConstructionSet >::size_type":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_DefaultConstructionSetVector

# Register DefaultConstructionSetVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.DefaultConstructionSetVector_swigregister(DefaultConstructionSetVector)

class OptionalDefaultConstructionSet(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalDefaultConstructionSet_swiginit(self, _openstudiomodelgeometry.new_OptionalDefaultConstructionSet(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalDefaultConstructionSet_reset(self)

    def __ref__(self) -> "openstudio::model::DefaultConstructionSet":
        return _openstudiomodelgeometry.OptionalDefaultConstructionSet___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalDefaultConstructionSet_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalDefaultConstructionSet_isNull(self)

    def get(self) -> "openstudio::model::DefaultConstructionSet":
        return _openstudiomodelgeometry.OptionalDefaultConstructionSet_get(self)

    def set(self, t: "DefaultConstructionSet") -> "void":
        return _openstudiomodelgeometry.OptionalDefaultConstructionSet_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalDefaultConstructionSet

# Register OptionalDefaultConstructionSet in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalDefaultConstructionSet_swigregister(OptionalDefaultConstructionSet)

class SurfaceVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SurfaceVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SurfaceVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SurfaceVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::Surface >::size_type":
        return _openstudiomodelgeometry.SurfaceVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::Surface >::difference_type", j: "std::vector< openstudio::model::Surface >::difference_type") -> "std::vector< openstudio::model::Surface,std::allocator< openstudio::model::Surface > > *":
        return _openstudiomodelgeometry.SurfaceVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfaceVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::Surface >::difference_type", j: "std::vector< openstudio::model::Surface >::difference_type") -> "void":
        return _openstudiomodelgeometry.SurfaceVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfaceVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::Surface >::value_type const &":
        return _openstudiomodelgeometry.SurfaceVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfaceVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::Surface >::value_type":
        return _openstudiomodelgeometry.SurfaceVector_pop(self)

    def append(self, x: "Surface") -> "void":
        return _openstudiomodelgeometry.SurfaceVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SurfaceVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::Surface >::size_type":
        return _openstudiomodelgeometry.SurfaceVector_size(self)

    def swap(self, v: "SurfaceVector") -> "void":
        return _openstudiomodelgeometry.SurfaceVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::Surface >::iterator":
        return _openstudiomodelgeometry.SurfaceVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::Surface >::iterator":
        return _openstudiomodelgeometry.SurfaceVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::Surface >::reverse_iterator":
        return _openstudiomodelgeometry.SurfaceVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::Surface >::reverse_iterator":
        return _openstudiomodelgeometry.SurfaceVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SurfaceVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::Surface >::allocator_type":
        return _openstudiomodelgeometry.SurfaceVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SurfaceVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::Surface >::iterator":
        return _openstudiomodelgeometry.SurfaceVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.SurfaceVector_swiginit(self, _openstudiomodelgeometry.new_SurfaceVector(*args))

    def push_back(self, x: "Surface") -> "void":
        return _openstudiomodelgeometry.SurfaceVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::Surface >::value_type const &":
        return _openstudiomodelgeometry.SurfaceVector_front(self)

    def back(self) -> "std::vector< openstudio::model::Surface >::value_type const &":
        return _openstudiomodelgeometry.SurfaceVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::Surface >::size_type", x: "Surface") -> "void":
        return _openstudiomodelgeometry.SurfaceVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::Surface >::size_type", x: "Surface") -> "void":
        return _openstudiomodelgeometry.SurfaceVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfaceVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::Surface >::size_type") -> "void":
        return _openstudiomodelgeometry.SurfaceVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::Surface >::size_type":
        return _openstudiomodelgeometry.SurfaceVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SurfaceVector

# Register SurfaceVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.SurfaceVector_swigregister(SurfaceVector)

class OptionalSurface(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalSurface_swiginit(self, _openstudiomodelgeometry.new_OptionalSurface(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSurface_reset(self)

    def __ref__(self) -> "openstudio::model::Surface":
        return _openstudiomodelgeometry.OptionalSurface___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSurface_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSurface_isNull(self)

    def get(self) -> "openstudio::model::Surface":
        return _openstudiomodelgeometry.OptionalSurface_get(self)

    def set(self, t: "Surface") -> "void":
        return _openstudiomodelgeometry.OptionalSurface_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSurface

# Register OptionalSurface in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalSurface_swigregister(OptionalSurface)

class SurfaceIntersectionVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SurfaceIntersectionVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SurfaceIntersectionVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SurfaceIntersectionVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::SurfaceIntersection >::size_type":
        return _openstudiomodelgeometry.SurfaceIntersectionVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::SurfaceIntersection >::difference_type", j: "std::vector< openstudio::model::SurfaceIntersection >::difference_type") -> "std::vector< openstudio::model::SurfaceIntersection,std::allocator< openstudio::model::SurfaceIntersection > > *":
        return _openstudiomodelgeometry.SurfaceIntersectionVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfaceIntersectionVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::SurfaceIntersection >::difference_type", j: "std::vector< openstudio::model::SurfaceIntersection >::difference_type") -> "void":
        return _openstudiomodelgeometry.SurfaceIntersectionVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfaceIntersectionVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::SurfaceIntersection >::value_type const &":
        return _openstudiomodelgeometry.SurfaceIntersectionVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfaceIntersectionVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::SurfaceIntersection >::value_type":
        return _openstudiomodelgeometry.SurfaceIntersectionVector_pop(self)

    def append(self, x: "SurfaceIntersection") -> "void":
        return _openstudiomodelgeometry.SurfaceIntersectionVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SurfaceIntersectionVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::SurfaceIntersection >::size_type":
        return _openstudiomodelgeometry.SurfaceIntersectionVector_size(self)

    def swap(self, v: "SurfaceIntersectionVector") -> "void":
        return _openstudiomodelgeometry.SurfaceIntersectionVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::SurfaceIntersection >::iterator":
        return _openstudiomodelgeometry.SurfaceIntersectionVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::SurfaceIntersection >::iterator":
        return _openstudiomodelgeometry.SurfaceIntersectionVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::SurfaceIntersection >::reverse_iterator":
        return _openstudiomodelgeometry.SurfaceIntersectionVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::SurfaceIntersection >::reverse_iterator":
        return _openstudiomodelgeometry.SurfaceIntersectionVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SurfaceIntersectionVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::SurfaceIntersection >::allocator_type":
        return _openstudiomodelgeometry.SurfaceIntersectionVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SurfaceIntersectionVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::SurfaceIntersection >::iterator":
        return _openstudiomodelgeometry.SurfaceIntersectionVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.SurfaceIntersectionVector_swiginit(self, _openstudiomodelgeometry.new_SurfaceIntersectionVector(*args))

    def push_back(self, x: "SurfaceIntersection") -> "void":
        return _openstudiomodelgeometry.SurfaceIntersectionVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::SurfaceIntersection >::value_type const &":
        return _openstudiomodelgeometry.SurfaceIntersectionVector_front(self)

    def back(self) -> "std::vector< openstudio::model::SurfaceIntersection >::value_type const &":
        return _openstudiomodelgeometry.SurfaceIntersectionVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::SurfaceIntersection >::size_type", x: "SurfaceIntersection") -> "void":
        return _openstudiomodelgeometry.SurfaceIntersectionVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::SurfaceIntersection >::size_type", x: "SurfaceIntersection") -> "void":
        return _openstudiomodelgeometry.SurfaceIntersectionVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfaceIntersectionVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::SurfaceIntersection >::size_type") -> "void":
        return _openstudiomodelgeometry.SurfaceIntersectionVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::SurfaceIntersection >::size_type":
        return _openstudiomodelgeometry.SurfaceIntersectionVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SurfaceIntersectionVector

# Register SurfaceIntersectionVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.SurfaceIntersectionVector_swigregister(SurfaceIntersectionVector)

class OptionalSurfaceIntersection(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalSurfaceIntersection_swiginit(self, _openstudiomodelgeometry.new_OptionalSurfaceIntersection(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSurfaceIntersection_reset(self)

    def __ref__(self) -> "openstudio::model::SurfaceIntersection":
        return _openstudiomodelgeometry.OptionalSurfaceIntersection___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSurfaceIntersection_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSurfaceIntersection_isNull(self)

    def get(self) -> "openstudio::model::SurfaceIntersection":
        return _openstudiomodelgeometry.OptionalSurfaceIntersection_get(self)

    def set(self, t: "SurfaceIntersection") -> "void":
        return _openstudiomodelgeometry.OptionalSurfaceIntersection_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSurfaceIntersection

# Register OptionalSurfaceIntersection in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalSurfaceIntersection_swigregister(OptionalSurfaceIntersection)

class SubSurfaceVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SubSurfaceVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SubSurfaceVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SubSurfaceVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::SubSurface >::size_type":
        return _openstudiomodelgeometry.SubSurfaceVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::SubSurface >::difference_type", j: "std::vector< openstudio::model::SubSurface >::difference_type") -> "std::vector< openstudio::model::SubSurface,std::allocator< openstudio::model::SubSurface > > *":
        return _openstudiomodelgeometry.SubSurfaceVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SubSurfaceVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::SubSurface >::difference_type", j: "std::vector< openstudio::model::SubSurface >::difference_type") -> "void":
        return _openstudiomodelgeometry.SubSurfaceVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SubSurfaceVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::SubSurface >::value_type const &":
        return _openstudiomodelgeometry.SubSurfaceVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SubSurfaceVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::SubSurface >::value_type":
        return _openstudiomodelgeometry.SubSurfaceVector_pop(self)

    def append(self, x: "SubSurface") -> "void":
        return _openstudiomodelgeometry.SubSurfaceVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SubSurfaceVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::SubSurface >::size_type":
        return _openstudiomodelgeometry.SubSurfaceVector_size(self)

    def swap(self, v: "SubSurfaceVector") -> "void":
        return _openstudiomodelgeometry.SubSurfaceVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::SubSurface >::iterator":
        return _openstudiomodelgeometry.SubSurfaceVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::SubSurface >::iterator":
        return _openstudiomodelgeometry.SubSurfaceVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::SubSurface >::reverse_iterator":
        return _openstudiomodelgeometry.SubSurfaceVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::SubSurface >::reverse_iterator":
        return _openstudiomodelgeometry.SubSurfaceVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SubSurfaceVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::SubSurface >::allocator_type":
        return _openstudiomodelgeometry.SubSurfaceVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SubSurfaceVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::SubSurface >::iterator":
        return _openstudiomodelgeometry.SubSurfaceVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.SubSurfaceVector_swiginit(self, _openstudiomodelgeometry.new_SubSurfaceVector(*args))

    def push_back(self, x: "SubSurface") -> "void":
        return _openstudiomodelgeometry.SubSurfaceVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::SubSurface >::value_type const &":
        return _openstudiomodelgeometry.SubSurfaceVector_front(self)

    def back(self) -> "std::vector< openstudio::model::SubSurface >::value_type const &":
        return _openstudiomodelgeometry.SubSurfaceVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::SubSurface >::size_type", x: "SubSurface") -> "void":
        return _openstudiomodelgeometry.SubSurfaceVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::SubSurface >::size_type", x: "SubSurface") -> "void":
        return _openstudiomodelgeometry.SubSurfaceVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SubSurfaceVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::SubSurface >::size_type") -> "void":
        return _openstudiomodelgeometry.SubSurfaceVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::SubSurface >::size_type":
        return _openstudiomodelgeometry.SubSurfaceVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SubSurfaceVector

# Register SubSurfaceVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.SubSurfaceVector_swigregister(SubSurfaceVector)

class OptionalSubSurface(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalSubSurface_swiginit(self, _openstudiomodelgeometry.new_OptionalSubSurface(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSubSurface_reset(self)

    def __ref__(self) -> "openstudio::model::SubSurface":
        return _openstudiomodelgeometry.OptionalSubSurface___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSubSurface_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSubSurface_isNull(self)

    def get(self) -> "openstudio::model::SubSurface":
        return _openstudiomodelgeometry.OptionalSubSurface_get(self)

    def set(self, t: "SubSurface") -> "void":
        return _openstudiomodelgeometry.OptionalSubSurface_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSubSurface

# Register OptionalSubSurface in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalSubSurface_swigregister(OptionalSubSurface)

class ShadingSurfaceGroupVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup >::size_type":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::ShadingSurfaceGroup >::difference_type", j: "std::vector< openstudio::model::ShadingSurfaceGroup >::difference_type") -> "std::vector< openstudio::model::ShadingSurfaceGroup,std::allocator< openstudio::model::ShadingSurfaceGroup > > *":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::ShadingSurfaceGroup >::difference_type", j: "std::vector< openstudio::model::ShadingSurfaceGroup >::difference_type") -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::ShadingSurfaceGroup >::value_type const &":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup >::value_type":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_pop(self)

    def append(self, x: "ShadingSurfaceGroup") -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup >::size_type":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_size(self)

    def swap(self, v: "ShadingSurfaceGroupVector") -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup >::iterator":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup >::iterator":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup >::reverse_iterator":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup >::reverse_iterator":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup >::allocator_type":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::ShadingSurfaceGroup >::iterator":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.ShadingSurfaceGroupVector_swiginit(self, _openstudiomodelgeometry.new_ShadingSurfaceGroupVector(*args))

    def push_back(self, x: "ShadingSurfaceGroup") -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup >::value_type const &":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_front(self)

    def back(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup >::value_type const &":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::ShadingSurfaceGroup >::size_type", x: "ShadingSurfaceGroup") -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::ShadingSurfaceGroup >::size_type", x: "ShadingSurfaceGroup") -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::ShadingSurfaceGroup >::size_type") -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup >::size_type":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_ShadingSurfaceGroupVector

# Register ShadingSurfaceGroupVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.ShadingSurfaceGroupVector_swigregister(ShadingSurfaceGroupVector)

class OptionalShadingSurfaceGroup(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalShadingSurfaceGroup_swiginit(self, _openstudiomodelgeometry.new_OptionalShadingSurfaceGroup(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalShadingSurfaceGroup_reset(self)

    def __ref__(self) -> "openstudio::model::ShadingSurfaceGroup":
        return _openstudiomodelgeometry.OptionalShadingSurfaceGroup___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalShadingSurfaceGroup_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalShadingSurfaceGroup_isNull(self)

    def get(self) -> "openstudio::model::ShadingSurfaceGroup":
        return _openstudiomodelgeometry.OptionalShadingSurfaceGroup_get(self)

    def set(self, t: "ShadingSurfaceGroup") -> "void":
        return _openstudiomodelgeometry.OptionalShadingSurfaceGroup_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalShadingSurfaceGroup

# Register OptionalShadingSurfaceGroup in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalShadingSurfaceGroup_swigregister(OptionalShadingSurfaceGroup)

class ShadingSurfaceVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.ShadingSurfaceVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.ShadingSurfaceVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.ShadingSurfaceVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::ShadingSurface >::size_type":
        return _openstudiomodelgeometry.ShadingSurfaceVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::ShadingSurface >::difference_type", j: "std::vector< openstudio::model::ShadingSurface >::difference_type") -> "std::vector< openstudio::model::ShadingSurface,std::allocator< openstudio::model::ShadingSurface > > *":
        return _openstudiomodelgeometry.ShadingSurfaceVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::ShadingSurface >::difference_type", j: "std::vector< openstudio::model::ShadingSurface >::difference_type") -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::ShadingSurface >::value_type const &":
        return _openstudiomodelgeometry.ShadingSurfaceVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::ShadingSurface >::value_type":
        return _openstudiomodelgeometry.ShadingSurfaceVector_pop(self)

    def append(self, x: "ShadingSurface") -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.ShadingSurfaceVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::ShadingSurface >::size_type":
        return _openstudiomodelgeometry.ShadingSurfaceVector_size(self)

    def swap(self, v: "ShadingSurfaceVector") -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::ShadingSurface >::iterator":
        return _openstudiomodelgeometry.ShadingSurfaceVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::ShadingSurface >::iterator":
        return _openstudiomodelgeometry.ShadingSurfaceVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::ShadingSurface >::reverse_iterator":
        return _openstudiomodelgeometry.ShadingSurfaceVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::ShadingSurface >::reverse_iterator":
        return _openstudiomodelgeometry.ShadingSurfaceVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::ShadingSurface >::allocator_type":
        return _openstudiomodelgeometry.ShadingSurfaceVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::ShadingSurface >::iterator":
        return _openstudiomodelgeometry.ShadingSurfaceVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.ShadingSurfaceVector_swiginit(self, _openstudiomodelgeometry.new_ShadingSurfaceVector(*args))

    def push_back(self, x: "ShadingSurface") -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::ShadingSurface >::value_type const &":
        return _openstudiomodelgeometry.ShadingSurfaceVector_front(self)

    def back(self) -> "std::vector< openstudio::model::ShadingSurface >::value_type const &":
        return _openstudiomodelgeometry.ShadingSurfaceVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::ShadingSurface >::size_type", x: "ShadingSurface") -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::ShadingSurface >::size_type", x: "ShadingSurface") -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::ShadingSurface >::size_type") -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::ShadingSurface >::size_type":
        return _openstudiomodelgeometry.ShadingSurfaceVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_ShadingSurfaceVector

# Register ShadingSurfaceVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.ShadingSurfaceVector_swigregister(ShadingSurfaceVector)

class OptionalShadingSurface(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalShadingSurface_swiginit(self, _openstudiomodelgeometry.new_OptionalShadingSurface(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalShadingSurface_reset(self)

    def __ref__(self) -> "openstudio::model::ShadingSurface":
        return _openstudiomodelgeometry.OptionalShadingSurface___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalShadingSurface_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalShadingSurface_isNull(self)

    def get(self) -> "openstudio::model::ShadingSurface":
        return _openstudiomodelgeometry.OptionalShadingSurface_get(self)

    def set(self, t: "ShadingSurface") -> "void":
        return _openstudiomodelgeometry.OptionalShadingSurface_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalShadingSurface

# Register OptionalShadingSurface in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalShadingSurface_swigregister(OptionalShadingSurface)

class InteriorPartitionSurfaceGroupVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::size_type":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::difference_type", j: "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::difference_type") -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup,std::allocator< openstudio::model::InteriorPartitionSurfaceGroup > > *":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::difference_type", j: "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::difference_type") -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::value_type const &":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::value_type":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_pop(self)

    def append(self, x: "InteriorPartitionSurfaceGroup") -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::size_type":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_size(self)

    def swap(self, v: "InteriorPartitionSurfaceGroupVector") -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::iterator":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::iterator":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::reverse_iterator":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::reverse_iterator":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::allocator_type":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::iterator":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_swiginit(self, _openstudiomodelgeometry.new_InteriorPartitionSurfaceGroupVector(*args))

    def push_back(self, x: "InteriorPartitionSurfaceGroup") -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::value_type const &":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_front(self)

    def back(self) -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::value_type const &":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::size_type", x: "InteriorPartitionSurfaceGroup") -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::size_type", x: "InteriorPartitionSurfaceGroup") -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::size_type") -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::size_type":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_InteriorPartitionSurfaceGroupVector

# Register InteriorPartitionSurfaceGroupVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_swigregister(InteriorPartitionSurfaceGroupVector)

class OptionalInteriorPartitionSurfaceGroup(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalInteriorPartitionSurfaceGroup_swiginit(self, _openstudiomodelgeometry.new_OptionalInteriorPartitionSurfaceGroup(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalInteriorPartitionSurfaceGroup_reset(self)

    def __ref__(self) -> "openstudio::model::InteriorPartitionSurfaceGroup":
        return _openstudiomodelgeometry.OptionalInteriorPartitionSurfaceGroup___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalInteriorPartitionSurfaceGroup_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalInteriorPartitionSurfaceGroup_isNull(self)

    def get(self) -> "openstudio::model::InteriorPartitionSurfaceGroup":
        return _openstudiomodelgeometry.OptionalInteriorPartitionSurfaceGroup_get(self)

    def set(self, t: "InteriorPartitionSurfaceGroup") -> "void":
        return _openstudiomodelgeometry.OptionalInteriorPartitionSurfaceGroup_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalInteriorPartitionSurfaceGroup

# Register OptionalInteriorPartitionSurfaceGroup in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalInteriorPartitionSurfaceGroup_swigregister(OptionalInteriorPartitionSurfaceGroup)

class InteriorPartitionSurfaceVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::InteriorPartitionSurface >::size_type":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::InteriorPartitionSurface >::difference_type", j: "std::vector< openstudio::model::InteriorPartitionSurface >::difference_type") -> "std::vector< openstudio::model::InteriorPartitionSurface,std::allocator< openstudio::model::InteriorPartitionSurface > > *":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::InteriorPartitionSurface >::difference_type", j: "std::vector< openstudio::model::InteriorPartitionSurface >::difference_type") -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::InteriorPartitionSurface >::value_type const &":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::InteriorPartitionSurface >::value_type":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_pop(self)

    def append(self, x: "InteriorPartitionSurface") -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::InteriorPartitionSurface >::size_type":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_size(self)

    def swap(self, v: "InteriorPartitionSurfaceVector") -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::InteriorPartitionSurface >::iterator":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::InteriorPartitionSurface >::iterator":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::InteriorPartitionSurface >::reverse_iterator":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::InteriorPartitionSurface >::reverse_iterator":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::InteriorPartitionSurface >::allocator_type":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::InteriorPartitionSurface >::iterator":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.InteriorPartitionSurfaceVector_swiginit(self, _openstudiomodelgeometry.new_InteriorPartitionSurfaceVector(*args))

    def push_back(self, x: "InteriorPartitionSurface") -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::InteriorPartitionSurface >::value_type const &":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_front(self)

    def back(self) -> "std::vector< openstudio::model::InteriorPartitionSurface >::value_type const &":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::InteriorPartitionSurface >::size_type", x: "InteriorPartitionSurface") -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::InteriorPartitionSurface >::size_type", x: "InteriorPartitionSurface") -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::InteriorPartitionSurface >::size_type") -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::InteriorPartitionSurface >::size_type":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_InteriorPartitionSurfaceVector

# Register InteriorPartitionSurfaceVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.InteriorPartitionSurfaceVector_swigregister(InteriorPartitionSurfaceVector)

class OptionalInteriorPartitionSurface(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalInteriorPartitionSurface_swiginit(self, _openstudiomodelgeometry.new_OptionalInteriorPartitionSurface(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalInteriorPartitionSurface_reset(self)

    def __ref__(self) -> "openstudio::model::InteriorPartitionSurface":
        return _openstudiomodelgeometry.OptionalInteriorPartitionSurface___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalInteriorPartitionSurface_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalInteriorPartitionSurface_isNull(self)

    def get(self) -> "openstudio::model::InteriorPartitionSurface":
        return _openstudiomodelgeometry.OptionalInteriorPartitionSurface_get(self)

    def set(self, t: "InteriorPartitionSurface") -> "void":
        return _openstudiomodelgeometry.OptionalInteriorPartitionSurface_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalInteriorPartitionSurface

# Register OptionalInteriorPartitionSurface in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalInteriorPartitionSurface_swigregister(OptionalInteriorPartitionSurface)

class SurfaceControlMovableInsulationVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::SurfaceControlMovableInsulation >::size_type":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::SurfaceControlMovableInsulation >::difference_type", j: "std::vector< openstudio::model::SurfaceControlMovableInsulation >::difference_type") -> "std::vector< openstudio::model::SurfaceControlMovableInsulation,std::allocator< openstudio::model::SurfaceControlMovableInsulation > > *":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::SurfaceControlMovableInsulation >::difference_type", j: "std::vector< openstudio::model::SurfaceControlMovableInsulation >::difference_type") -> "void":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::SurfaceControlMovableInsulation >::value_type const &":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::SurfaceControlMovableInsulation >::value_type":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector_pop(self)

    def append(self, x: "SurfaceControlMovableInsulation") -> "void":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::SurfaceControlMovableInsulation >::size_type":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector_size(self)

    def swap(self, v: "SurfaceControlMovableInsulationVector") -> "void":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::SurfaceControlMovableInsulation >::iterator":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::SurfaceControlMovableInsulation >::iterator":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::SurfaceControlMovableInsulation >::reverse_iterator":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::SurfaceControlMovableInsulation >::reverse_iterator":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::SurfaceControlMovableInsulation >::allocator_type":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::SurfaceControlMovableInsulation >::iterator":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.SurfaceControlMovableInsulationVector_swiginit(self, _openstudiomodelgeometry.new_SurfaceControlMovableInsulationVector(*args))

    def push_back(self, x: "SurfaceControlMovableInsulation") -> "void":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::SurfaceControlMovableInsulation >::value_type const &":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector_front(self)

    def back(self) -> "std::vector< openstudio::model::SurfaceControlMovableInsulation >::value_type const &":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::SurfaceControlMovableInsulation >::size_type", x: "SurfaceControlMovableInsulation") -> "void":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::SurfaceControlMovableInsulation >::size_type", x: "SurfaceControlMovableInsulation") -> "void":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::SurfaceControlMovableInsulation >::size_type") -> "void":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::SurfaceControlMovableInsulation >::size_type":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulationVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SurfaceControlMovableInsulationVector

# Register SurfaceControlMovableInsulationVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.SurfaceControlMovableInsulationVector_swigregister(SurfaceControlMovableInsulationVector)

class OptionalSurfaceControlMovableInsulation(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalSurfaceControlMovableInsulation_swiginit(self, _openstudiomodelgeometry.new_OptionalSurfaceControlMovableInsulation(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSurfaceControlMovableInsulation_reset(self)

    def __ref__(self) -> "openstudio::model::SurfaceControlMovableInsulation":
        return _openstudiomodelgeometry.OptionalSurfaceControlMovableInsulation___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSurfaceControlMovableInsulation_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSurfaceControlMovableInsulation_isNull(self)

    def get(self) -> "openstudio::model::SurfaceControlMovableInsulation":
        return _openstudiomodelgeometry.OptionalSurfaceControlMovableInsulation_get(self)

    def set(self, t: "SurfaceControlMovableInsulation") -> "void":
        return _openstudiomodelgeometry.OptionalSurfaceControlMovableInsulation_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSurfaceControlMovableInsulation

# Register OptionalSurfaceControlMovableInsulation in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalSurfaceControlMovableInsulation_swigregister(OptionalSurfaceControlMovableInsulation)

class SurfacePropertyOtherSideCoefficientsVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::size_type":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::difference_type", j: "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::difference_type") -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients,std::allocator< openstudio::model::SurfacePropertyOtherSideCoefficients > > *":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::difference_type", j: "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::difference_type") -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::value_type const &":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::value_type":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_pop(self)

    def append(self, x: "SurfacePropertyOtherSideCoefficients") -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::size_type":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_size(self)

    def swap(self, v: "SurfacePropertyOtherSideCoefficientsVector") -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::iterator":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::iterator":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::reverse_iterator":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::reverse_iterator":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::allocator_type":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::iterator":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_swiginit(self, _openstudiomodelgeometry.new_SurfacePropertyOtherSideCoefficientsVector(*args))

    def push_back(self, x: "SurfacePropertyOtherSideCoefficients") -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::value_type const &":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_front(self)

    def back(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::value_type const &":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::size_type", x: "SurfacePropertyOtherSideCoefficients") -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::size_type", x: "SurfacePropertyOtherSideCoefficients") -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::size_type") -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::size_type":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SurfacePropertyOtherSideCoefficientsVector

# Register SurfacePropertyOtherSideCoefficientsVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_swigregister(SurfacePropertyOtherSideCoefficientsVector)

class OptionalSurfacePropertyOtherSideCoefficients(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalSurfacePropertyOtherSideCoefficients_swiginit(self, _openstudiomodelgeometry.new_OptionalSurfacePropertyOtherSideCoefficients(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSurfacePropertyOtherSideCoefficients_reset(self)

    def __ref__(self) -> "openstudio::model::SurfacePropertyOtherSideCoefficients":
        return _openstudiomodelgeometry.OptionalSurfacePropertyOtherSideCoefficients___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSurfacePropertyOtherSideCoefficients_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSurfacePropertyOtherSideCoefficients_isNull(self)

    def get(self) -> "openstudio::model::SurfacePropertyOtherSideCoefficients":
        return _openstudiomodelgeometry.OptionalSurfacePropertyOtherSideCoefficients_get(self)

    def set(self, t: "SurfacePropertyOtherSideCoefficients") -> "void":
        return _openstudiomodelgeometry.OptionalSurfacePropertyOtherSideCoefficients_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSurfacePropertyOtherSideCoefficients

# Register OptionalSurfacePropertyOtherSideCoefficients in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalSurfacePropertyOtherSideCoefficients_swigregister(OptionalSurfacePropertyOtherSideCoefficients)

class SurfacePropertyOtherSideConditionsModelVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::size_type":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::difference_type", j: "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::difference_type") -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel,std::allocator< openstudio::model::SurfacePropertyOtherSideConditionsModel > > *":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::difference_type", j: "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::difference_type") -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::value_type const &":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::value_type":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_pop(self)

    def append(self, x: "SurfacePropertyOtherSideConditionsModel") -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::size_type":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_size(self)

    def swap(self, v: "SurfacePropertyOtherSideConditionsModelVector") -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::iterator":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::iterator":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::reverse_iterator":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::reverse_iterator":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::allocator_type":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::iterator":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_swiginit(self, _openstudiomodelgeometry.new_SurfacePropertyOtherSideConditionsModelVector(*args))

    def push_back(self, x: "SurfacePropertyOtherSideConditionsModel") -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::value_type const &":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_front(self)

    def back(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::value_type const &":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::size_type", x: "SurfacePropertyOtherSideConditionsModel") -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::size_type", x: "SurfacePropertyOtherSideConditionsModel") -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::size_type") -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::size_type":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SurfacePropertyOtherSideConditionsModelVector

# Register SurfacePropertyOtherSideConditionsModelVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_swigregister(SurfacePropertyOtherSideConditionsModelVector)

class OptionalSurfacePropertyOtherSideConditionsModel(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalSurfacePropertyOtherSideConditionsModel_swiginit(self, _openstudiomodelgeometry.new_OptionalSurfacePropertyOtherSideConditionsModel(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSurfacePropertyOtherSideConditionsModel_reset(self)

    def __ref__(self) -> "openstudio::model::SurfacePropertyOtherSideConditionsModel":
        return _openstudiomodelgeometry.OptionalSurfacePropertyOtherSideConditionsModel___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSurfacePropertyOtherSideConditionsModel_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSurfacePropertyOtherSideConditionsModel_isNull(self)

    def get(self) -> "openstudio::model::SurfacePropertyOtherSideConditionsModel":
        return _openstudiomodelgeometry.OptionalSurfacePropertyOtherSideConditionsModel_get(self)

    def set(self, t: "SurfacePropertyOtherSideConditionsModel") -> "void":
        return _openstudiomodelgeometry.OptionalSurfacePropertyOtherSideConditionsModel_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSurfacePropertyOtherSideConditionsModel

# Register OptionalSurfacePropertyOtherSideConditionsModel in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalSurfacePropertyOtherSideConditionsModel_swigregister(OptionalSurfacePropertyOtherSideConditionsModel)

class SurfacePropertyConvectionCoefficientsVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::size_type":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::difference_type", j: "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::difference_type") -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients,std::allocator< openstudio::model::SurfacePropertyConvectionCoefficients > > *":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::difference_type", j: "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::difference_type") -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::value_type const &":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::value_type":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_pop(self)

    def append(self, x: "SurfacePropertyConvectionCoefficients") -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::size_type":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_size(self)

    def swap(self, v: "SurfacePropertyConvectionCoefficientsVector") -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::iterator":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::iterator":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::reverse_iterator":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::reverse_iterator":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::allocator_type":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::iterator":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_swiginit(self, _openstudiomodelgeometry.new_SurfacePropertyConvectionCoefficientsVector(*args))

    def push_back(self, x: "SurfacePropertyConvectionCoefficients") -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::value_type const &":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_front(self)

    def back(self) -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::value_type const &":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::size_type", x: "SurfacePropertyConvectionCoefficients") -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::size_type", x: "SurfacePropertyConvectionCoefficients") -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::size_type") -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::size_type":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SurfacePropertyConvectionCoefficientsVector

# Register SurfacePropertyConvectionCoefficientsVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_swigregister(SurfacePropertyConvectionCoefficientsVector)

class OptionalSurfacePropertyConvectionCoefficients(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalSurfacePropertyConvectionCoefficients_swiginit(self, _openstudiomodelgeometry.new_OptionalSurfacePropertyConvectionCoefficients(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSurfacePropertyConvectionCoefficients_reset(self)

    def __ref__(self) -> "openstudio::model::SurfacePropertyConvectionCoefficients":
        return _openstudiomodelgeometry.OptionalSurfacePropertyConvectionCoefficients___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSurfacePropertyConvectionCoefficients_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSurfacePropertyConvectionCoefficients_isNull(self)

    def get(self) -> "openstudio::model::SurfacePropertyConvectionCoefficients":
        return _openstudiomodelgeometry.OptionalSurfacePropertyConvectionCoefficients_get(self)

    def set(self, t: "SurfacePropertyConvectionCoefficients") -> "void":
        return _openstudiomodelgeometry.OptionalSurfacePropertyConvectionCoefficients_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSurfacePropertyConvectionCoefficients

# Register OptionalSurfacePropertyConvectionCoefficients in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalSurfacePropertyConvectionCoefficients_swigregister(OptionalSurfacePropertyConvectionCoefficients)

class PeopleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.PeopleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.PeopleVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.PeopleVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::People >::size_type":
        return _openstudiomodelgeometry.PeopleVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::People >::difference_type", j: "std::vector< openstudio::model::People >::difference_type") -> "std::vector< openstudio::model::People,std::allocator< openstudio::model::People > > *":
        return _openstudiomodelgeometry.PeopleVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.PeopleVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::People >::difference_type", j: "std::vector< openstudio::model::People >::difference_type") -> "void":
        return _openstudiomodelgeometry.PeopleVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.PeopleVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::People >::value_type const &":
        return _openstudiomodelgeometry.PeopleVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.PeopleVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::People >::value_type":
        return _openstudiomodelgeometry.PeopleVector_pop(self)

    def append(self, x: "People") -> "void":
        return _openstudiomodelgeometry.PeopleVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.PeopleVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::People >::size_type":
        return _openstudiomodelgeometry.PeopleVector_size(self)

    def swap(self, v: "PeopleVector") -> "void":
        return _openstudiomodelgeometry.PeopleVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::People >::iterator":
        return _openstudiomodelgeometry.PeopleVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::People >::iterator":
        return _openstudiomodelgeometry.PeopleVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::People >::reverse_iterator":
        return _openstudiomodelgeometry.PeopleVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::People >::reverse_iterator":
        return _openstudiomodelgeometry.PeopleVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.PeopleVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::People >::allocator_type":
        return _openstudiomodelgeometry.PeopleVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.PeopleVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::People >::iterator":
        return _openstudiomodelgeometry.PeopleVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.PeopleVector_swiginit(self, _openstudiomodelgeometry.new_PeopleVector(*args))

    def push_back(self, x: "People") -> "void":
        return _openstudiomodelgeometry.PeopleVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::People >::value_type const &":
        return _openstudiomodelgeometry.PeopleVector_front(self)

    def back(self) -> "std::vector< openstudio::model::People >::value_type const &":
        return _openstudiomodelgeometry.PeopleVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::People >::size_type", x: "People") -> "void":
        return _openstudiomodelgeometry.PeopleVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::People >::size_type", x: "People") -> "void":
        return _openstudiomodelgeometry.PeopleVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.PeopleVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::People >::size_type") -> "void":
        return _openstudiomodelgeometry.PeopleVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::People >::size_type":
        return _openstudiomodelgeometry.PeopleVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_PeopleVector

# Register PeopleVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.PeopleVector_swigregister(PeopleVector)

class OptionalPeople(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalPeople_swiginit(self, _openstudiomodelgeometry.new_OptionalPeople(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalPeople_reset(self)

    def __ref__(self) -> "openstudio::model::People":
        return _openstudiomodelgeometry.OptionalPeople___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalPeople_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalPeople_isNull(self)

    def get(self) -> "openstudio::model::People":
        return _openstudiomodelgeometry.OptionalPeople_get(self)

    def set(self, t: "People") -> "void":
        return _openstudiomodelgeometry.OptionalPeople_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalPeople

# Register OptionalPeople in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalPeople_swigregister(OptionalPeople)

class LuminaireVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.LuminaireVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.LuminaireVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.LuminaireVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::Luminaire >::size_type":
        return _openstudiomodelgeometry.LuminaireVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::Luminaire >::difference_type", j: "std::vector< openstudio::model::Luminaire >::difference_type") -> "std::vector< openstudio::model::Luminaire,std::allocator< openstudio::model::Luminaire > > *":
        return _openstudiomodelgeometry.LuminaireVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.LuminaireVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::Luminaire >::difference_type", j: "std::vector< openstudio::model::Luminaire >::difference_type") -> "void":
        return _openstudiomodelgeometry.LuminaireVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.LuminaireVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::Luminaire >::value_type const &":
        return _openstudiomodelgeometry.LuminaireVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.LuminaireVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::Luminaire >::value_type":
        return _openstudiomodelgeometry.LuminaireVector_pop(self)

    def append(self, x: "Luminaire") -> "void":
        return _openstudiomodelgeometry.LuminaireVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.LuminaireVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::Luminaire >::size_type":
        return _openstudiomodelgeometry.LuminaireVector_size(self)

    def swap(self, v: "LuminaireVector") -> "void":
        return _openstudiomodelgeometry.LuminaireVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::Luminaire >::iterator":
        return _openstudiomodelgeometry.LuminaireVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::Luminaire >::iterator":
        return _openstudiomodelgeometry.LuminaireVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::Luminaire >::reverse_iterator":
        return _openstudiomodelgeometry.LuminaireVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::Luminaire >::reverse_iterator":
        return _openstudiomodelgeometry.LuminaireVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.LuminaireVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::Luminaire >::allocator_type":
        return _openstudiomodelgeometry.LuminaireVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.LuminaireVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::Luminaire >::iterator":
        return _openstudiomodelgeometry.LuminaireVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.LuminaireVector_swiginit(self, _openstudiomodelgeometry.new_LuminaireVector(*args))

    def push_back(self, x: "Luminaire") -> "void":
        return _openstudiomodelgeometry.LuminaireVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::Luminaire >::value_type const &":
        return _openstudiomodelgeometry.LuminaireVector_front(self)

    def back(self) -> "std::vector< openstudio::model::Luminaire >::value_type const &":
        return _openstudiomodelgeometry.LuminaireVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::Luminaire >::size_type", x: "Luminaire") -> "void":
        return _openstudiomodelgeometry.LuminaireVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::Luminaire >::size_type", x: "Luminaire") -> "void":
        return _openstudiomodelgeometry.LuminaireVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.LuminaireVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::Luminaire >::size_type") -> "void":
        return _openstudiomodelgeometry.LuminaireVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::Luminaire >::size_type":
        return _openstudiomodelgeometry.LuminaireVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_LuminaireVector

# Register LuminaireVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.LuminaireVector_swigregister(LuminaireVector)

class OptionalLuminaire(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalLuminaire_swiginit(self, _openstudiomodelgeometry.new_OptionalLuminaire(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalLuminaire_reset(self)

    def __ref__(self) -> "openstudio::model::Luminaire":
        return _openstudiomodelgeometry.OptionalLuminaire___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalLuminaire_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalLuminaire_isNull(self)

    def get(self) -> "openstudio::model::Luminaire":
        return _openstudiomodelgeometry.OptionalLuminaire_get(self)

    def set(self, t: "Luminaire") -> "void":
        return _openstudiomodelgeometry.OptionalLuminaire_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalLuminaire

# Register OptionalLuminaire in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalLuminaire_swigregister(OptionalLuminaire)

class ElectricEquipmentVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.ElectricEquipmentVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.ElectricEquipmentVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.ElectricEquipmentVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::ElectricEquipment >::size_type":
        return _openstudiomodelgeometry.ElectricEquipmentVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::ElectricEquipment >::difference_type", j: "std::vector< openstudio::model::ElectricEquipment >::difference_type") -> "std::vector< openstudio::model::ElectricEquipment,std::allocator< openstudio::model::ElectricEquipment > > *":
        return _openstudiomodelgeometry.ElectricEquipmentVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::ElectricEquipment >::difference_type", j: "std::vector< openstudio::model::ElectricEquipment >::difference_type") -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::ElectricEquipment >::value_type const &":
        return _openstudiomodelgeometry.ElectricEquipmentVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::ElectricEquipment >::value_type":
        return _openstudiomodelgeometry.ElectricEquipmentVector_pop(self)

    def append(self, x: "ElectricEquipment") -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.ElectricEquipmentVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::ElectricEquipment >::size_type":
        return _openstudiomodelgeometry.ElectricEquipmentVector_size(self)

    def swap(self, v: "ElectricEquipmentVector") -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::ElectricEquipment >::iterator":
        return _openstudiomodelgeometry.ElectricEquipmentVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::ElectricEquipment >::iterator":
        return _openstudiomodelgeometry.ElectricEquipmentVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::ElectricEquipment >::reverse_iterator":
        return _openstudiomodelgeometry.ElectricEquipmentVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::ElectricEquipment >::reverse_iterator":
        return _openstudiomodelgeometry.ElectricEquipmentVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::ElectricEquipment >::allocator_type":
        return _openstudiomodelgeometry.ElectricEquipmentVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::ElectricEquipment >::iterator":
        return _openstudiomodelgeometry.ElectricEquipmentVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.ElectricEquipmentVector_swiginit(self, _openstudiomodelgeometry.new_ElectricEquipmentVector(*args))

    def push_back(self, x: "ElectricEquipment") -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::ElectricEquipment >::value_type const &":
        return _openstudiomodelgeometry.ElectricEquipmentVector_front(self)

    def back(self) -> "std::vector< openstudio::model::ElectricEquipment >::value_type const &":
        return _openstudiomodelgeometry.ElectricEquipmentVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::ElectricEquipment >::size_type", x: "ElectricEquipment") -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::ElectricEquipment >::size_type", x: "ElectricEquipment") -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::ElectricEquipment >::size_type") -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::ElectricEquipment >::size_type":
        return _openstudiomodelgeometry.ElectricEquipmentVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_ElectricEquipmentVector

# Register ElectricEquipmentVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.ElectricEquipmentVector_swigregister(ElectricEquipmentVector)

class OptionalElectricEquipment(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalElectricEquipment_swiginit(self, _openstudiomodelgeometry.new_OptionalElectricEquipment(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalElectricEquipment_reset(self)

    def __ref__(self) -> "openstudio::model::ElectricEquipment":
        return _openstudiomodelgeometry.OptionalElectricEquipment___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalElectricEquipment_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalElectricEquipment_isNull(self)

    def get(self) -> "openstudio::model::ElectricEquipment":
        return _openstudiomodelgeometry.OptionalElectricEquipment_get(self)

    def set(self, t: "ElectricEquipment") -> "void":
        return _openstudiomodelgeometry.OptionalElectricEquipment_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalElectricEquipment

# Register OptionalElectricEquipment in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalElectricEquipment_swigregister(OptionalElectricEquipment)

class ElectricEquipmentITEAirCooledVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::ElectricEquipmentITEAirCooled >::size_type":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::ElectricEquipmentITEAirCooled >::difference_type", j: "std::vector< openstudio::model::ElectricEquipmentITEAirCooled >::difference_type") -> "std::vector< openstudio::model::ElectricEquipmentITEAirCooled,std::allocator< openstudio::model::ElectricEquipmentITEAirCooled > > *":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::ElectricEquipmentITEAirCooled >::difference_type", j: "std::vector< openstudio::model::ElectricEquipmentITEAirCooled >::difference_type") -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::ElectricEquipmentITEAirCooled >::value_type const &":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::ElectricEquipmentITEAirCooled >::value_type":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector_pop(self)

    def append(self, x: "ElectricEquipmentITEAirCooled") -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::ElectricEquipmentITEAirCooled >::size_type":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector_size(self)

    def swap(self, v: "ElectricEquipmentITEAirCooledVector") -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::ElectricEquipmentITEAirCooled >::iterator":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::ElectricEquipmentITEAirCooled >::iterator":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::ElectricEquipmentITEAirCooled >::reverse_iterator":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::ElectricEquipmentITEAirCooled >::reverse_iterator":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::ElectricEquipmentITEAirCooled >::allocator_type":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::ElectricEquipmentITEAirCooled >::iterator":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector_swiginit(self, _openstudiomodelgeometry.new_ElectricEquipmentITEAirCooledVector(*args))

    def push_back(self, x: "ElectricEquipmentITEAirCooled") -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::ElectricEquipmentITEAirCooled >::value_type const &":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector_front(self)

    def back(self) -> "std::vector< openstudio::model::ElectricEquipmentITEAirCooled >::value_type const &":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::ElectricEquipmentITEAirCooled >::size_type", x: "ElectricEquipmentITEAirCooled") -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::ElectricEquipmentITEAirCooled >::size_type", x: "ElectricEquipmentITEAirCooled") -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::ElectricEquipmentITEAirCooled >::size_type") -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::ElectricEquipmentITEAirCooled >::size_type":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_ElectricEquipmentITEAirCooledVector

# Register ElectricEquipmentITEAirCooledVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.ElectricEquipmentITEAirCooledVector_swigregister(ElectricEquipmentITEAirCooledVector)

class OptionalElectricEquipmentITEAirCooled(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalElectricEquipmentITEAirCooled_swiginit(self, _openstudiomodelgeometry.new_OptionalElectricEquipmentITEAirCooled(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalElectricEquipmentITEAirCooled_reset(self)

    def __ref__(self) -> "openstudio::model::ElectricEquipmentITEAirCooled":
        return _openstudiomodelgeometry.OptionalElectricEquipmentITEAirCooled___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalElectricEquipmentITEAirCooled_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalElectricEquipmentITEAirCooled_isNull(self)

    def get(self) -> "openstudio::model::ElectricEquipmentITEAirCooled":
        return _openstudiomodelgeometry.OptionalElectricEquipmentITEAirCooled_get(self)

    def set(self, t: "ElectricEquipmentITEAirCooled") -> "void":
        return _openstudiomodelgeometry.OptionalElectricEquipmentITEAirCooled_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalElectricEquipmentITEAirCooled

# Register OptionalElectricEquipmentITEAirCooled in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalElectricEquipmentITEAirCooled_swigregister(OptionalElectricEquipmentITEAirCooled)

class GasEquipmentVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.GasEquipmentVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.GasEquipmentVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.GasEquipmentVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::GasEquipment >::size_type":
        return _openstudiomodelgeometry.GasEquipmentVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::GasEquipment >::difference_type", j: "std::vector< openstudio::model::GasEquipment >::difference_type") -> "std::vector< openstudio::model::GasEquipment,std::allocator< openstudio::model::GasEquipment > > *":
        return _openstudiomodelgeometry.GasEquipmentVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.GasEquipmentVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::GasEquipment >::difference_type", j: "std::vector< openstudio::model::GasEquipment >::difference_type") -> "void":
        return _openstudiomodelgeometry.GasEquipmentVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.GasEquipmentVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::GasEquipment >::value_type const &":
        return _openstudiomodelgeometry.GasEquipmentVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.GasEquipmentVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::GasEquipment >::value_type":
        return _openstudiomodelgeometry.GasEquipmentVector_pop(self)

    def append(self, x: "GasEquipment") -> "void":
        return _openstudiomodelgeometry.GasEquipmentVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.GasEquipmentVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::GasEquipment >::size_type":
        return _openstudiomodelgeometry.GasEquipmentVector_size(self)

    def swap(self, v: "GasEquipmentVector") -> "void":
        return _openstudiomodelgeometry.GasEquipmentVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::GasEquipment >::iterator":
        return _openstudiomodelgeometry.GasEquipmentVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::GasEquipment >::iterator":
        return _openstudiomodelgeometry.GasEquipmentVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::GasEquipment >::reverse_iterator":
        return _openstudiomodelgeometry.GasEquipmentVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::GasEquipment >::reverse_iterator":
        return _openstudiomodelgeometry.GasEquipmentVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.GasEquipmentVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::GasEquipment >::allocator_type":
        return _openstudiomodelgeometry.GasEquipmentVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.GasEquipmentVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::GasEquipment >::iterator":
        return _openstudiomodelgeometry.GasEquipmentVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.GasEquipmentVector_swiginit(self, _openstudiomodelgeometry.new_GasEquipmentVector(*args))

    def push_back(self, x: "GasEquipment") -> "void":
        return _openstudiomodelgeometry.GasEquipmentVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::GasEquipment >::value_type const &":
        return _openstudiomodelgeometry.GasEquipmentVector_front(self)

    def back(self) -> "std::vector< openstudio::model::GasEquipment >::value_type const &":
        return _openstudiomodelgeometry.GasEquipmentVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::GasEquipment >::size_type", x: "GasEquipment") -> "void":
        return _openstudiomodelgeometry.GasEquipmentVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::GasEquipment >::size_type", x: "GasEquipment") -> "void":
        return _openstudiomodelgeometry.GasEquipmentVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.GasEquipmentVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::GasEquipment >::size_type") -> "void":
        return _openstudiomodelgeometry.GasEquipmentVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::GasEquipment >::size_type":
        return _openstudiomodelgeometry.GasEquipmentVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_GasEquipmentVector

# Register GasEquipmentVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.GasEquipmentVector_swigregister(GasEquipmentVector)

class OptionalGasEquipment(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalGasEquipment_swiginit(self, _openstudiomodelgeometry.new_OptionalGasEquipment(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalGasEquipment_reset(self)

    def __ref__(self) -> "openstudio::model::GasEquipment":
        return _openstudiomodelgeometry.OptionalGasEquipment___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalGasEquipment_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalGasEquipment_isNull(self)

    def get(self) -> "openstudio::model::GasEquipment":
        return _openstudiomodelgeometry.OptionalGasEquipment_get(self)

    def set(self, t: "GasEquipment") -> "void":
        return _openstudiomodelgeometry.OptionalGasEquipment_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalGasEquipment

# Register OptionalGasEquipment in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalGasEquipment_swigregister(OptionalGasEquipment)

class HotWaterEquipmentVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.HotWaterEquipmentVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.HotWaterEquipmentVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::HotWaterEquipment >::size_type":
        return _openstudiomodelgeometry.HotWaterEquipmentVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::HotWaterEquipment >::difference_type", j: "std::vector< openstudio::model::HotWaterEquipment >::difference_type") -> "std::vector< openstudio::model::HotWaterEquipment,std::allocator< openstudio::model::HotWaterEquipment > > *":
        return _openstudiomodelgeometry.HotWaterEquipmentVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.HotWaterEquipmentVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::HotWaterEquipment >::difference_type", j: "std::vector< openstudio::model::HotWaterEquipment >::difference_type") -> "void":
        return _openstudiomodelgeometry.HotWaterEquipmentVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.HotWaterEquipmentVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::HotWaterEquipment >::value_type const &":
        return _openstudiomodelgeometry.HotWaterEquipmentVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.HotWaterEquipmentVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::HotWaterEquipment >::value_type":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_pop(self)

    def append(self, x: "HotWaterEquipment") -> "void":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::HotWaterEquipment >::size_type":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_size(self)

    def swap(self, v: "HotWaterEquipmentVector") -> "void":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::HotWaterEquipment >::iterator":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::HotWaterEquipment >::iterator":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::HotWaterEquipment >::reverse_iterator":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::HotWaterEquipment >::reverse_iterator":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::HotWaterEquipment >::allocator_type":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::HotWaterEquipment >::iterator":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.HotWaterEquipmentVector_swiginit(self, _openstudiomodelgeometry.new_HotWaterEquipmentVector(*args))

    def push_back(self, x: "HotWaterEquipment") -> "void":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::HotWaterEquipment >::value_type const &":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_front(self)

    def back(self) -> "std::vector< openstudio::model::HotWaterEquipment >::value_type const &":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::HotWaterEquipment >::size_type", x: "HotWaterEquipment") -> "void":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::HotWaterEquipment >::size_type", x: "HotWaterEquipment") -> "void":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::HotWaterEquipment >::size_type") -> "void":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::HotWaterEquipment >::size_type":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_HotWaterEquipmentVector

# Register HotWaterEquipmentVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.HotWaterEquipmentVector_swigregister(HotWaterEquipmentVector)

class OptionalHotWaterEquipment(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalHotWaterEquipment_swiginit(self, _openstudiomodelgeometry.new_OptionalHotWaterEquipment(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalHotWaterEquipment_reset(self)

    def __ref__(self) -> "openstudio::model::HotWaterEquipment":
        return _openstudiomodelgeometry.OptionalHotWaterEquipment___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalHotWaterEquipment_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalHotWaterEquipment_isNull(self)

    def get(self) -> "openstudio::model::HotWaterEquipment":
        return _openstudiomodelgeometry.OptionalHotWaterEquipment_get(self)

    def set(self, t: "HotWaterEquipment") -> "void":
        return _openstudiomodelgeometry.OptionalHotWaterEquipment_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalHotWaterEquipment

# Register OptionalHotWaterEquipment in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalHotWaterEquipment_swigregister(OptionalHotWaterEquipment)

class SteamEquipmentVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SteamEquipmentVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SteamEquipmentVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SteamEquipmentVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::SteamEquipment >::size_type":
        return _openstudiomodelgeometry.SteamEquipmentVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::SteamEquipment >::difference_type", j: "std::vector< openstudio::model::SteamEquipment >::difference_type") -> "std::vector< openstudio::model::SteamEquipment,std::allocator< openstudio::model::SteamEquipment > > *":
        return _openstudiomodelgeometry.SteamEquipmentVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SteamEquipmentVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::SteamEquipment >::difference_type", j: "std::vector< openstudio::model::SteamEquipment >::difference_type") -> "void":
        return _openstudiomodelgeometry.SteamEquipmentVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SteamEquipmentVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::SteamEquipment >::value_type const &":
        return _openstudiomodelgeometry.SteamEquipmentVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SteamEquipmentVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::SteamEquipment >::value_type":
        return _openstudiomodelgeometry.SteamEquipmentVector_pop(self)

    def append(self, x: "SteamEquipment") -> "void":
        return _openstudiomodelgeometry.SteamEquipmentVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SteamEquipmentVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::SteamEquipment >::size_type":
        return _openstudiomodelgeometry.SteamEquipmentVector_size(self)

    def swap(self, v: "SteamEquipmentVector") -> "void":
        return _openstudiomodelgeometry.SteamEquipmentVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::SteamEquipment >::iterator":
        return _openstudiomodelgeometry.SteamEquipmentVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::SteamEquipment >::iterator":
        return _openstudiomodelgeometry.SteamEquipmentVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::SteamEquipment >::reverse_iterator":
        return _openstudiomodelgeometry.SteamEquipmentVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::SteamEquipment >::reverse_iterator":
        return _openstudiomodelgeometry.SteamEquipmentVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SteamEquipmentVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::SteamEquipment >::allocator_type":
        return _openstudiomodelgeometry.SteamEquipmentVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SteamEquipmentVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::SteamEquipment >::iterator":
        return _openstudiomodelgeometry.SteamEquipmentVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.SteamEquipmentVector_swiginit(self, _openstudiomodelgeometry.new_SteamEquipmentVector(*args))

    def push_back(self, x: "SteamEquipment") -> "void":
        return _openstudiomodelgeometry.SteamEquipmentVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::SteamEquipment >::value_type const &":
        return _openstudiomodelgeometry.SteamEquipmentVector_front(self)

    def back(self) -> "std::vector< openstudio::model::SteamEquipment >::value_type const &":
        return _openstudiomodelgeometry.SteamEquipmentVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::SteamEquipment >::size_type", x: "SteamEquipment") -> "void":
        return _openstudiomodelgeometry.SteamEquipmentVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::SteamEquipment >::size_type", x: "SteamEquipment") -> "void":
        return _openstudiomodelgeometry.SteamEquipmentVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SteamEquipmentVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::SteamEquipment >::size_type") -> "void":
        return _openstudiomodelgeometry.SteamEquipmentVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::SteamEquipment >::size_type":
        return _openstudiomodelgeometry.SteamEquipmentVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SteamEquipmentVector

# Register SteamEquipmentVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.SteamEquipmentVector_swigregister(SteamEquipmentVector)

class OptionalSteamEquipment(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalSteamEquipment_swiginit(self, _openstudiomodelgeometry.new_OptionalSteamEquipment(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSteamEquipment_reset(self)

    def __ref__(self) -> "openstudio::model::SteamEquipment":
        return _openstudiomodelgeometry.OptionalSteamEquipment___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSteamEquipment_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSteamEquipment_isNull(self)

    def get(self) -> "openstudio::model::SteamEquipment":
        return _openstudiomodelgeometry.OptionalSteamEquipment_get(self)

    def set(self, t: "SteamEquipment") -> "void":
        return _openstudiomodelgeometry.OptionalSteamEquipment_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSteamEquipment

# Register OptionalSteamEquipment in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalSteamEquipment_swigregister(OptionalSteamEquipment)

class OtherEquipmentVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.OtherEquipmentVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.OtherEquipmentVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.OtherEquipmentVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::OtherEquipment >::size_type":
        return _openstudiomodelgeometry.OtherEquipmentVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::OtherEquipment >::difference_type", j: "std::vector< openstudio::model::OtherEquipment >::difference_type") -> "std::vector< openstudio::model::OtherEquipment,std::allocator< openstudio::model::OtherEquipment > > *":
        return _openstudiomodelgeometry.OtherEquipmentVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.OtherEquipmentVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::OtherEquipment >::difference_type", j: "std::vector< openstudio::model::OtherEquipment >::difference_type") -> "void":
        return _openstudiomodelgeometry.OtherEquipmentVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.OtherEquipmentVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::OtherEquipment >::value_type const &":
        return _openstudiomodelgeometry.OtherEquipmentVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.OtherEquipmentVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::OtherEquipment >::value_type":
        return _openstudiomodelgeometry.OtherEquipmentVector_pop(self)

    def append(self, x: "OtherEquipment") -> "void":
        return _openstudiomodelgeometry.OtherEquipmentVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.OtherEquipmentVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::OtherEquipment >::size_type":
        return _openstudiomodelgeometry.OtherEquipmentVector_size(self)

    def swap(self, v: "OtherEquipmentVector") -> "void":
        return _openstudiomodelgeometry.OtherEquipmentVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::OtherEquipment >::iterator":
        return _openstudiomodelgeometry.OtherEquipmentVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::OtherEquipment >::iterator":
        return _openstudiomodelgeometry.OtherEquipmentVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::OtherEquipment >::reverse_iterator":
        return _openstudiomodelgeometry.OtherEquipmentVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::OtherEquipment >::reverse_iterator":
        return _openstudiomodelgeometry.OtherEquipmentVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.OtherEquipmentVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::OtherEquipment >::allocator_type":
        return _openstudiomodelgeometry.OtherEquipmentVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.OtherEquipmentVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::OtherEquipment >::iterator":
        return _openstudiomodelgeometry.OtherEquipmentVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.OtherEquipmentVector_swiginit(self, _openstudiomodelgeometry.new_OtherEquipmentVector(*args))

    def push_back(self, x: "OtherEquipment") -> "void":
        return _openstudiomodelgeometry.OtherEquipmentVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::OtherEquipment >::value_type const &":
        return _openstudiomodelgeometry.OtherEquipmentVector_front(self)

    def back(self) -> "std::vector< openstudio::model::OtherEquipment >::value_type const &":
        return _openstudiomodelgeometry.OtherEquipmentVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::OtherEquipment >::size_type", x: "OtherEquipment") -> "void":
        return _openstudiomodelgeometry.OtherEquipmentVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::OtherEquipment >::size_type", x: "OtherEquipment") -> "void":
        return _openstudiomodelgeometry.OtherEquipmentVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.OtherEquipmentVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::OtherEquipment >::size_type") -> "void":
        return _openstudiomodelgeometry.OtherEquipmentVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::OtherEquipment >::size_type":
        return _openstudiomodelgeometry.OtherEquipmentVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OtherEquipmentVector

# Register OtherEquipmentVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.OtherEquipmentVector_swigregister(OtherEquipmentVector)

class OptionalOtherEquipment(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalOtherEquipment_swiginit(self, _openstudiomodelgeometry.new_OptionalOtherEquipment(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalOtherEquipment_reset(self)

    def __ref__(self) -> "openstudio::model::OtherEquipment":
        return _openstudiomodelgeometry.OptionalOtherEquipment___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalOtherEquipment_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalOtherEquipment_isNull(self)

    def get(self) -> "openstudio::model::OtherEquipment":
        return _openstudiomodelgeometry.OptionalOtherEquipment_get(self)

    def set(self, t: "OtherEquipment") -> "void":
        return _openstudiomodelgeometry.OptionalOtherEquipment_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalOtherEquipment

# Register OptionalOtherEquipment in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalOtherEquipment_swigregister(OptionalOtherEquipment)

class InternalMassVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.InternalMassVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.InternalMassVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.InternalMassVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::InternalMass >::size_type":
        return _openstudiomodelgeometry.InternalMassVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::InternalMass >::difference_type", j: "std::vector< openstudio::model::InternalMass >::difference_type") -> "std::vector< openstudio::model::InternalMass,std::allocator< openstudio::model::InternalMass > > *":
        return _openstudiomodelgeometry.InternalMassVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.InternalMassVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::InternalMass >::difference_type", j: "std::vector< openstudio::model::InternalMass >::difference_type") -> "void":
        return _openstudiomodelgeometry.InternalMassVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.InternalMassVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::InternalMass >::value_type const &":
        return _openstudiomodelgeometry.InternalMassVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.InternalMassVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::InternalMass >::value_type":
        return _openstudiomodelgeometry.InternalMassVector_pop(self)

    def append(self, x: "InternalMass") -> "void":
        return _openstudiomodelgeometry.InternalMassVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.InternalMassVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::InternalMass >::size_type":
        return _openstudiomodelgeometry.InternalMassVector_size(self)

    def swap(self, v: "InternalMassVector") -> "void":
        return _openstudiomodelgeometry.InternalMassVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::InternalMass >::iterator":
        return _openstudiomodelgeometry.InternalMassVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::InternalMass >::iterator":
        return _openstudiomodelgeometry.InternalMassVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::InternalMass >::reverse_iterator":
        return _openstudiomodelgeometry.InternalMassVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::InternalMass >::reverse_iterator":
        return _openstudiomodelgeometry.InternalMassVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.InternalMassVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::InternalMass >::allocator_type":
        return _openstudiomodelgeometry.InternalMassVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.InternalMassVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::InternalMass >::iterator":
        return _openstudiomodelgeometry.InternalMassVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.InternalMassVector_swiginit(self, _openstudiomodelgeometry.new_InternalMassVector(*args))

    def push_back(self, x: "InternalMass") -> "void":
        return _openstudiomodelgeometry.InternalMassVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::InternalMass >::value_type const &":
        return _openstudiomodelgeometry.InternalMassVector_front(self)

    def back(self) -> "std::vector< openstudio::model::InternalMass >::value_type const &":
        return _openstudiomodelgeometry.InternalMassVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::InternalMass >::size_type", x: "InternalMass") -> "void":
        return _openstudiomodelgeometry.InternalMassVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::InternalMass >::size_type", x: "InternalMass") -> "void":
        return _openstudiomodelgeometry.InternalMassVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.InternalMassVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::InternalMass >::size_type") -> "void":
        return _openstudiomodelgeometry.InternalMassVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::InternalMass >::size_type":
        return _openstudiomodelgeometry.InternalMassVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_InternalMassVector

# Register InternalMassVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.InternalMassVector_swigregister(InternalMassVector)

class OptionalInternalMass(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalInternalMass_swiginit(self, _openstudiomodelgeometry.new_OptionalInternalMass(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalInternalMass_reset(self)

    def __ref__(self) -> "openstudio::model::InternalMass":
        return _openstudiomodelgeometry.OptionalInternalMass___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalInternalMass_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalInternalMass_isNull(self)

    def get(self) -> "openstudio::model::InternalMass":
        return _openstudiomodelgeometry.OptionalInternalMass_get(self)

    def set(self, t: "InternalMass") -> "void":
        return _openstudiomodelgeometry.OptionalInternalMass_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalInternalMass

# Register OptionalInternalMass in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalInternalMass_swigregister(OptionalInternalMass)

class SpaceInfiltrationDesignFlowRateVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::size_type":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::difference_type", j: "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::difference_type") -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate,std::allocator< openstudio::model::SpaceInfiltrationDesignFlowRate > > *":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::difference_type", j: "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::difference_type") -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::value_type const &":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::value_type":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_pop(self)

    def append(self, x: "SpaceInfiltrationDesignFlowRate") -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::size_type":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_size(self)

    def swap(self, v: "SpaceInfiltrationDesignFlowRateVector") -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::iterator":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::iterator":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::reverse_iterator":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::reverse_iterator":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::allocator_type":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::iterator":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_swiginit(self, _openstudiomodelgeometry.new_SpaceInfiltrationDesignFlowRateVector(*args))

    def push_back(self, x: "SpaceInfiltrationDesignFlowRate") -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::value_type const &":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_front(self)

    def back(self) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::value_type const &":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::size_type", x: "SpaceInfiltrationDesignFlowRate") -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::size_type", x: "SpaceInfiltrationDesignFlowRate") -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::size_type") -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::size_type":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SpaceInfiltrationDesignFlowRateVector

# Register SpaceInfiltrationDesignFlowRateVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_swigregister(SpaceInfiltrationDesignFlowRateVector)

class OptionalSpaceInfiltrationDesignFlowRate(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalSpaceInfiltrationDesignFlowRate_swiginit(self, _openstudiomodelgeometry.new_OptionalSpaceInfiltrationDesignFlowRate(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSpaceInfiltrationDesignFlowRate_reset(self)

    def __ref__(self) -> "openstudio::model::SpaceInfiltrationDesignFlowRate":
        return _openstudiomodelgeometry.OptionalSpaceInfiltrationDesignFlowRate___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSpaceInfiltrationDesignFlowRate_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSpaceInfiltrationDesignFlowRate_isNull(self)

    def get(self) -> "openstudio::model::SpaceInfiltrationDesignFlowRate":
        return _openstudiomodelgeometry.OptionalSpaceInfiltrationDesignFlowRate_get(self)

    def set(self, t: "SpaceInfiltrationDesignFlowRate") -> "void":
        return _openstudiomodelgeometry.OptionalSpaceInfiltrationDesignFlowRate_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSpaceInfiltrationDesignFlowRate

# Register OptionalSpaceInfiltrationDesignFlowRate in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalSpaceInfiltrationDesignFlowRate_swigregister(OptionalSpaceInfiltrationDesignFlowRate)

class SpaceInfiltrationEffectiveLeakageAreaVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::size_type":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::difference_type", j: "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::difference_type") -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea,std::allocator< openstudio::model::SpaceInfiltrationEffectiveLeakageArea > > *":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::difference_type", j: "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::difference_type") -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::value_type const &":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::value_type":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_pop(self)

    def append(self, x: "SpaceInfiltrationEffectiveLeakageArea") -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::size_type":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_size(self)

    def swap(self, v: "SpaceInfiltrationEffectiveLeakageAreaVector") -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::iterator":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::iterator":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::reverse_iterator":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::reverse_iterator":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::allocator_type":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::iterator":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_swiginit(self, _openstudiomodelgeometry.new_SpaceInfiltrationEffectiveLeakageAreaVector(*args))

    def push_back(self, x: "SpaceInfiltrationEffectiveLeakageArea") -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::value_type const &":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_front(self)

    def back(self) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::value_type const &":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::size_type", x: "SpaceInfiltrationEffectiveLeakageArea") -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::size_type", x: "SpaceInfiltrationEffectiveLeakageArea") -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::size_type") -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::size_type":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SpaceInfiltrationEffectiveLeakageAreaVector

# Register SpaceInfiltrationEffectiveLeakageAreaVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_swigregister(SpaceInfiltrationEffectiveLeakageAreaVector)

class OptionalSpaceInfiltrationEffectiveLeakageArea(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalSpaceInfiltrationEffectiveLeakageArea_swiginit(self, _openstudiomodelgeometry.new_OptionalSpaceInfiltrationEffectiveLeakageArea(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSpaceInfiltrationEffectiveLeakageArea_reset(self)

    def __ref__(self) -> "openstudio::model::SpaceInfiltrationEffectiveLeakageArea":
        return _openstudiomodelgeometry.OptionalSpaceInfiltrationEffectiveLeakageArea___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSpaceInfiltrationEffectiveLeakageArea_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSpaceInfiltrationEffectiveLeakageArea_isNull(self)

    def get(self) -> "openstudio::model::SpaceInfiltrationEffectiveLeakageArea":
        return _openstudiomodelgeometry.OptionalSpaceInfiltrationEffectiveLeakageArea_get(self)

    def set(self, t: "SpaceInfiltrationEffectiveLeakageArea") -> "void":
        return _openstudiomodelgeometry.OptionalSpaceInfiltrationEffectiveLeakageArea_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSpaceInfiltrationEffectiveLeakageArea

# Register OptionalSpaceInfiltrationEffectiveLeakageArea in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalSpaceInfiltrationEffectiveLeakageArea_swigregister(OptionalSpaceInfiltrationEffectiveLeakageArea)

class DaylightingControlVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.DaylightingControlVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControlVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControlVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::DaylightingControl >::size_type":
        return _openstudiomodelgeometry.DaylightingControlVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::DaylightingControl >::difference_type", j: "std::vector< openstudio::model::DaylightingControl >::difference_type") -> "std::vector< openstudio::model::DaylightingControl,std::allocator< openstudio::model::DaylightingControl > > *":
        return _openstudiomodelgeometry.DaylightingControlVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.DaylightingControlVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::DaylightingControl >::difference_type", j: "std::vector< openstudio::model::DaylightingControl >::difference_type") -> "void":
        return _openstudiomodelgeometry.DaylightingControlVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.DaylightingControlVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::DaylightingControl >::value_type const &":
        return _openstudiomodelgeometry.DaylightingControlVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.DaylightingControlVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::DaylightingControl >::value_type":
        return _openstudiomodelgeometry.DaylightingControlVector_pop(self)

    def append(self, x: "DaylightingControl") -> "void":
        return _openstudiomodelgeometry.DaylightingControlVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControlVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::DaylightingControl >::size_type":
        return _openstudiomodelgeometry.DaylightingControlVector_size(self)

    def swap(self, v: "DaylightingControlVector") -> "void":
        return _openstudiomodelgeometry.DaylightingControlVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::DaylightingControl >::iterator":
        return _openstudiomodelgeometry.DaylightingControlVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::DaylightingControl >::iterator":
        return _openstudiomodelgeometry.DaylightingControlVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::DaylightingControl >::reverse_iterator":
        return _openstudiomodelgeometry.DaylightingControlVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::DaylightingControl >::reverse_iterator":
        return _openstudiomodelgeometry.DaylightingControlVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.DaylightingControlVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::DaylightingControl >::allocator_type":
        return _openstudiomodelgeometry.DaylightingControlVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.DaylightingControlVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::DaylightingControl >::iterator":
        return _openstudiomodelgeometry.DaylightingControlVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.DaylightingControlVector_swiginit(self, _openstudiomodelgeometry.new_DaylightingControlVector(*args))

    def push_back(self, x: "DaylightingControl") -> "void":
        return _openstudiomodelgeometry.DaylightingControlVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::DaylightingControl >::value_type const &":
        return _openstudiomodelgeometry.DaylightingControlVector_front(self)

    def back(self) -> "std::vector< openstudio::model::DaylightingControl >::value_type const &":
        return _openstudiomodelgeometry.DaylightingControlVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::DaylightingControl >::size_type", x: "DaylightingControl") -> "void":
        return _openstudiomodelgeometry.DaylightingControlVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::DaylightingControl >::size_type", x: "DaylightingControl") -> "void":
        return _openstudiomodelgeometry.DaylightingControlVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.DaylightingControlVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::DaylightingControl >::size_type") -> "void":
        return _openstudiomodelgeometry.DaylightingControlVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::DaylightingControl >::size_type":
        return _openstudiomodelgeometry.DaylightingControlVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_DaylightingControlVector

# Register DaylightingControlVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.DaylightingControlVector_swigregister(DaylightingControlVector)

class OptionalDaylightingControl(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalDaylightingControl_swiginit(self, _openstudiomodelgeometry.new_OptionalDaylightingControl(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalDaylightingControl_reset(self)

    def __ref__(self) -> "openstudio::model::DaylightingControl":
        return _openstudiomodelgeometry.OptionalDaylightingControl___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalDaylightingControl_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalDaylightingControl_isNull(self)

    def get(self) -> "openstudio::model::DaylightingControl":
        return _openstudiomodelgeometry.OptionalDaylightingControl_get(self)

    def set(self, t: "DaylightingControl") -> "void":
        return _openstudiomodelgeometry.OptionalDaylightingControl_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalDaylightingControl

# Register OptionalDaylightingControl in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalDaylightingControl_swigregister(OptionalDaylightingControl)

class GlareSensorVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.GlareSensorVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.GlareSensorVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.GlareSensorVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::GlareSensor >::size_type":
        return _openstudiomodelgeometry.GlareSensorVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::GlareSensor >::difference_type", j: "std::vector< openstudio::model::GlareSensor >::difference_type") -> "std::vector< openstudio::model::GlareSensor,std::allocator< openstudio::model::GlareSensor > > *":
        return _openstudiomodelgeometry.GlareSensorVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.GlareSensorVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::GlareSensor >::difference_type", j: "std::vector< openstudio::model::GlareSensor >::difference_type") -> "void":
        return _openstudiomodelgeometry.GlareSensorVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.GlareSensorVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::GlareSensor >::value_type const &":
        return _openstudiomodelgeometry.GlareSensorVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.GlareSensorVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::GlareSensor >::value_type":
        return _openstudiomodelgeometry.GlareSensorVector_pop(self)

    def append(self, x: "GlareSensor") -> "void":
        return _openstudiomodelgeometry.GlareSensorVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.GlareSensorVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::GlareSensor >::size_type":
        return _openstudiomodelgeometry.GlareSensorVector_size(self)

    def swap(self, v: "GlareSensorVector") -> "void":
        return _openstudiomodelgeometry.GlareSensorVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::GlareSensor >::iterator":
        return _openstudiomodelgeometry.GlareSensorVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::GlareSensor >::iterator":
        return _openstudiomodelgeometry.GlareSensorVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::GlareSensor >::reverse_iterator":
        return _openstudiomodelgeometry.GlareSensorVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::GlareSensor >::reverse_iterator":
        return _openstudiomodelgeometry.GlareSensorVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.GlareSensorVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::GlareSensor >::allocator_type":
        return _openstudiomodelgeometry.GlareSensorVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.GlareSensorVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::GlareSensor >::iterator":
        return _openstudiomodelgeometry.GlareSensorVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.GlareSensorVector_swiginit(self, _openstudiomodelgeometry.new_GlareSensorVector(*args))

    def push_back(self, x: "GlareSensor") -> "void":
        return _openstudiomodelgeometry.GlareSensorVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::GlareSensor >::value_type const &":
        return _openstudiomodelgeometry.GlareSensorVector_front(self)

    def back(self) -> "std::vector< openstudio::model::GlareSensor >::value_type const &":
        return _openstudiomodelgeometry.GlareSensorVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::GlareSensor >::size_type", x: "GlareSensor") -> "void":
        return _openstudiomodelgeometry.GlareSensorVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::GlareSensor >::size_type", x: "GlareSensor") -> "void":
        return _openstudiomodelgeometry.GlareSensorVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.GlareSensorVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::GlareSensor >::size_type") -> "void":
        return _openstudiomodelgeometry.GlareSensorVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::GlareSensor >::size_type":
        return _openstudiomodelgeometry.GlareSensorVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_GlareSensorVector

# Register GlareSensorVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.GlareSensorVector_swigregister(GlareSensorVector)

class OptionalGlareSensor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalGlareSensor_swiginit(self, _openstudiomodelgeometry.new_OptionalGlareSensor(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalGlareSensor_reset(self)

    def __ref__(self) -> "openstudio::model::GlareSensor":
        return _openstudiomodelgeometry.OptionalGlareSensor___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalGlareSensor_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalGlareSensor_isNull(self)

    def get(self) -> "openstudio::model::GlareSensor":
        return _openstudiomodelgeometry.OptionalGlareSensor_get(self)

    def set(self, t: "GlareSensor") -> "void":
        return _openstudiomodelgeometry.OptionalGlareSensor_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalGlareSensor

# Register OptionalGlareSensor in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalGlareSensor_swigregister(OptionalGlareSensor)

class IlluminanceMapVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.IlluminanceMapVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.IlluminanceMapVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.IlluminanceMapVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::IlluminanceMap >::size_type":
        return _openstudiomodelgeometry.IlluminanceMapVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::IlluminanceMap >::difference_type", j: "std::vector< openstudio::model::IlluminanceMap >::difference_type") -> "std::vector< openstudio::model::IlluminanceMap,std::allocator< openstudio::model::IlluminanceMap > > *":
        return _openstudiomodelgeometry.IlluminanceMapVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.IlluminanceMapVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::IlluminanceMap >::difference_type", j: "std::vector< openstudio::model::IlluminanceMap >::difference_type") -> "void":
        return _openstudiomodelgeometry.IlluminanceMapVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.IlluminanceMapVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::IlluminanceMap >::value_type const &":
        return _openstudiomodelgeometry.IlluminanceMapVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.IlluminanceMapVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::IlluminanceMap >::value_type":
        return _openstudiomodelgeometry.IlluminanceMapVector_pop(self)

    def append(self, x: "IlluminanceMap") -> "void":
        return _openstudiomodelgeometry.IlluminanceMapVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.IlluminanceMapVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::IlluminanceMap >::size_type":
        return _openstudiomodelgeometry.IlluminanceMapVector_size(self)

    def swap(self, v: "IlluminanceMapVector") -> "void":
        return _openstudiomodelgeometry.IlluminanceMapVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::IlluminanceMap >::iterator":
        return _openstudiomodelgeometry.IlluminanceMapVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::IlluminanceMap >::iterator":
        return _openstudiomodelgeometry.IlluminanceMapVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::IlluminanceMap >::reverse_iterator":
        return _openstudiomodelgeometry.IlluminanceMapVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::IlluminanceMap >::reverse_iterator":
        return _openstudiomodelgeometry.IlluminanceMapVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.IlluminanceMapVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::IlluminanceMap >::allocator_type":
        return _openstudiomodelgeometry.IlluminanceMapVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.IlluminanceMapVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::IlluminanceMap >::iterator":
        return _openstudiomodelgeometry.IlluminanceMapVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.IlluminanceMapVector_swiginit(self, _openstudiomodelgeometry.new_IlluminanceMapVector(*args))

    def push_back(self, x: "IlluminanceMap") -> "void":
        return _openstudiomodelgeometry.IlluminanceMapVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::IlluminanceMap >::value_type const &":
        return _openstudiomodelgeometry.IlluminanceMapVector_front(self)

    def back(self) -> "std::vector< openstudio::model::IlluminanceMap >::value_type const &":
        return _openstudiomodelgeometry.IlluminanceMapVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::IlluminanceMap >::size_type", x: "IlluminanceMap") -> "void":
        return _openstudiomodelgeometry.IlluminanceMapVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::IlluminanceMap >::size_type", x: "IlluminanceMap") -> "void":
        return _openstudiomodelgeometry.IlluminanceMapVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.IlluminanceMapVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::IlluminanceMap >::size_type") -> "void":
        return _openstudiomodelgeometry.IlluminanceMapVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::IlluminanceMap >::size_type":
        return _openstudiomodelgeometry.IlluminanceMapVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_IlluminanceMapVector

# Register IlluminanceMapVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.IlluminanceMapVector_swigregister(IlluminanceMapVector)

class OptionalIlluminanceMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalIlluminanceMap_swiginit(self, _openstudiomodelgeometry.new_OptionalIlluminanceMap(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalIlluminanceMap_reset(self)

    def __ref__(self) -> "openstudio::model::IlluminanceMap":
        return _openstudiomodelgeometry.OptionalIlluminanceMap___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalIlluminanceMap_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalIlluminanceMap_isNull(self)

    def get(self) -> "openstudio::model::IlluminanceMap":
        return _openstudiomodelgeometry.OptionalIlluminanceMap_get(self)

    def set(self, t: "IlluminanceMap") -> "void":
        return _openstudiomodelgeometry.OptionalIlluminanceMap_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalIlluminanceMap

# Register OptionalIlluminanceMap in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalIlluminanceMap_swigregister(OptionalIlluminanceMap)

class DaylightingDeviceShelfVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::DaylightingDeviceShelf >::size_type":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::DaylightingDeviceShelf >::difference_type", j: "std::vector< openstudio::model::DaylightingDeviceShelf >::difference_type") -> "std::vector< openstudio::model::DaylightingDeviceShelf,std::allocator< openstudio::model::DaylightingDeviceShelf > > *":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::DaylightingDeviceShelf >::difference_type", j: "std::vector< openstudio::model::DaylightingDeviceShelf >::difference_type") -> "void":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::DaylightingDeviceShelf >::value_type const &":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::DaylightingDeviceShelf >::value_type":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_pop(self)

    def append(self, x: "DaylightingDeviceShelf") -> "void":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::DaylightingDeviceShelf >::size_type":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_size(self)

    def swap(self, v: "DaylightingDeviceShelfVector") -> "void":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::DaylightingDeviceShelf >::iterator":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::DaylightingDeviceShelf >::iterator":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::DaylightingDeviceShelf >::reverse_iterator":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::DaylightingDeviceShelf >::reverse_iterator":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::DaylightingDeviceShelf >::allocator_type":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::DaylightingDeviceShelf >::iterator":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.DaylightingDeviceShelfVector_swiginit(self, _openstudiomodelgeometry.new_DaylightingDeviceShelfVector(*args))

    def push_back(self, x: "DaylightingDeviceShelf") -> "void":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::DaylightingDeviceShelf >::value_type const &":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_front(self)

    def back(self) -> "std::vector< openstudio::model::DaylightingDeviceShelf >::value_type const &":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::DaylightingDeviceShelf >::size_type", x: "DaylightingDeviceShelf") -> "void":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::DaylightingDeviceShelf >::size_type", x: "DaylightingDeviceShelf") -> "void":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::DaylightingDeviceShelf >::size_type") -> "void":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::DaylightingDeviceShelf >::size_type":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_DaylightingDeviceShelfVector

# Register DaylightingDeviceShelfVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.DaylightingDeviceShelfVector_swigregister(DaylightingDeviceShelfVector)

class OptionalDaylightingDeviceShelf(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalDaylightingDeviceShelf_swiginit(self, _openstudiomodelgeometry.new_OptionalDaylightingDeviceShelf(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalDaylightingDeviceShelf_reset(self)

    def __ref__(self) -> "openstudio::model::DaylightingDeviceShelf":
        return _openstudiomodelgeometry.OptionalDaylightingDeviceShelf___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalDaylightingDeviceShelf_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalDaylightingDeviceShelf_isNull(self)

    def get(self) -> "openstudio::model::DaylightingDeviceShelf":
        return _openstudiomodelgeometry.OptionalDaylightingDeviceShelf_get(self)

    def set(self, t: "DaylightingDeviceShelf") -> "void":
        return _openstudiomodelgeometry.OptionalDaylightingDeviceShelf_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalDaylightingDeviceShelf

# Register OptionalDaylightingDeviceShelf in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalDaylightingDeviceShelf_swigregister(OptionalDaylightingDeviceShelf)

class SpaceTypeVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SpaceTypeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SpaceTypeVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SpaceTypeVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::SpaceType >::size_type":
        return _openstudiomodelgeometry.SpaceTypeVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::SpaceType >::difference_type", j: "std::vector< openstudio::model::SpaceType >::difference_type") -> "std::vector< openstudio::model::SpaceType,std::allocator< openstudio::model::SpaceType > > *":
        return _openstudiomodelgeometry.SpaceTypeVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceTypeVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::SpaceType >::difference_type", j: "std::vector< openstudio::model::SpaceType >::difference_type") -> "void":
        return _openstudiomodelgeometry.SpaceTypeVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceTypeVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::SpaceType >::value_type const &":
        return _openstudiomodelgeometry.SpaceTypeVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceTypeVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::SpaceType >::value_type":
        return _openstudiomodelgeometry.SpaceTypeVector_pop(self)

    def append(self, x: "SpaceType") -> "void":
        return _openstudiomodelgeometry.SpaceTypeVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SpaceTypeVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::SpaceType >::size_type":
        return _openstudiomodelgeometry.SpaceTypeVector_size(self)

    def swap(self, v: "SpaceTypeVector") -> "void":
        return _openstudiomodelgeometry.SpaceTypeVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::SpaceType >::iterator":
        return _openstudiomodelgeometry.SpaceTypeVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::SpaceType >::iterator":
        return _openstudiomodelgeometry.SpaceTypeVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::SpaceType >::reverse_iterator":
        return _openstudiomodelgeometry.SpaceTypeVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::SpaceType >::reverse_iterator":
        return _openstudiomodelgeometry.SpaceTypeVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SpaceTypeVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::SpaceType >::allocator_type":
        return _openstudiomodelgeometry.SpaceTypeVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SpaceTypeVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::SpaceType >::iterator":
        return _openstudiomodelgeometry.SpaceTypeVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.SpaceTypeVector_swiginit(self, _openstudiomodelgeometry.new_SpaceTypeVector(*args))

    def push_back(self, x: "SpaceType") -> "void":
        return _openstudiomodelgeometry.SpaceTypeVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::SpaceType >::value_type const &":
        return _openstudiomodelgeometry.SpaceTypeVector_front(self)

    def back(self) -> "std::vector< openstudio::model::SpaceType >::value_type const &":
        return _openstudiomodelgeometry.SpaceTypeVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::SpaceType >::size_type", x: "SpaceType") -> "void":
        return _openstudiomodelgeometry.SpaceTypeVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::SpaceType >::size_type", x: "SpaceType") -> "void":
        return _openstudiomodelgeometry.SpaceTypeVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceTypeVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::SpaceType >::size_type") -> "void":
        return _openstudiomodelgeometry.SpaceTypeVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::SpaceType >::size_type":
        return _openstudiomodelgeometry.SpaceTypeVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SpaceTypeVector

# Register SpaceTypeVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.SpaceTypeVector_swigregister(SpaceTypeVector)

class OptionalSpaceType(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalSpaceType_swiginit(self, _openstudiomodelgeometry.new_OptionalSpaceType(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSpaceType_reset(self)

    def __ref__(self) -> "openstudio::model::SpaceType":
        return _openstudiomodelgeometry.OptionalSpaceType___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSpaceType_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSpaceType_isNull(self)

    def get(self) -> "openstudio::model::SpaceType":
        return _openstudiomodelgeometry.OptionalSpaceType_get(self)

    def set(self, t: "SpaceType") -> "void":
        return _openstudiomodelgeometry.OptionalSpaceType_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSpaceType

# Register OptionalSpaceType in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalSpaceType_swigregister(OptionalSpaceType)

class LightingSimulationZoneVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.LightingSimulationZoneVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.LightingSimulationZoneVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::LightingSimulationZone >::size_type":
        return _openstudiomodelgeometry.LightingSimulationZoneVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::LightingSimulationZone >::difference_type", j: "std::vector< openstudio::model::LightingSimulationZone >::difference_type") -> "std::vector< openstudio::model::LightingSimulationZone,std::allocator< openstudio::model::LightingSimulationZone > > *":
        return _openstudiomodelgeometry.LightingSimulationZoneVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.LightingSimulationZoneVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::LightingSimulationZone >::difference_type", j: "std::vector< openstudio::model::LightingSimulationZone >::difference_type") -> "void":
        return _openstudiomodelgeometry.LightingSimulationZoneVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.LightingSimulationZoneVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::LightingSimulationZone >::value_type const &":
        return _openstudiomodelgeometry.LightingSimulationZoneVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.LightingSimulationZoneVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::LightingSimulationZone >::value_type":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_pop(self)

    def append(self, x: "LightingSimulationZone") -> "void":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::LightingSimulationZone >::size_type":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_size(self)

    def swap(self, v: "LightingSimulationZoneVector") -> "void":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::LightingSimulationZone >::iterator":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::LightingSimulationZone >::iterator":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::LightingSimulationZone >::reverse_iterator":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::LightingSimulationZone >::reverse_iterator":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::LightingSimulationZone >::allocator_type":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::LightingSimulationZone >::iterator":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.LightingSimulationZoneVector_swiginit(self, _openstudiomodelgeometry.new_LightingSimulationZoneVector(*args))

    def push_back(self, x: "LightingSimulationZone") -> "void":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::LightingSimulationZone >::value_type const &":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_front(self)

    def back(self) -> "std::vector< openstudio::model::LightingSimulationZone >::value_type const &":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::LightingSimulationZone >::size_type", x: "LightingSimulationZone") -> "void":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::LightingSimulationZone >::size_type", x: "LightingSimulationZone") -> "void":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::LightingSimulationZone >::size_type") -> "void":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::LightingSimulationZone >::size_type":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_LightingSimulationZoneVector

# Register LightingSimulationZoneVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.LightingSimulationZoneVector_swigregister(LightingSimulationZoneVector)

class OptionalLightingSimulationZone(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalLightingSimulationZone_swiginit(self, _openstudiomodelgeometry.new_OptionalLightingSimulationZone(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalLightingSimulationZone_reset(self)

    def __ref__(self) -> "openstudio::model::LightingSimulationZone":
        return _openstudiomodelgeometry.OptionalLightingSimulationZone___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalLightingSimulationZone_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalLightingSimulationZone_isNull(self)

    def get(self) -> "openstudio::model::LightingSimulationZone":
        return _openstudiomodelgeometry.OptionalLightingSimulationZone_get(self)

    def set(self, t: "LightingSimulationZone") -> "void":
        return _openstudiomodelgeometry.OptionalLightingSimulationZone_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalLightingSimulationZone

# Register OptionalLightingSimulationZone in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalLightingSimulationZone_swigregister(OptionalLightingSimulationZone)

class CustomBlockVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.CustomBlockVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.CustomBlockVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.CustomBlockVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::CustomBlock >::size_type":
        return _openstudiomodelgeometry.CustomBlockVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::CustomBlock >::difference_type", j: "std::vector< openstudio::model::CustomBlock >::difference_type") -> "std::vector< openstudio::model::CustomBlock,std::allocator< openstudio::model::CustomBlock > > *":
        return _openstudiomodelgeometry.CustomBlockVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.CustomBlockVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::CustomBlock >::difference_type", j: "std::vector< openstudio::model::CustomBlock >::difference_type") -> "void":
        return _openstudiomodelgeometry.CustomBlockVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.CustomBlockVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::CustomBlock >::value_type const &":
        return _openstudiomodelgeometry.CustomBlockVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.CustomBlockVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::CustomBlock >::value_type":
        return _openstudiomodelgeometry.CustomBlockVector_pop(self)

    def append(self, x: "CustomBlock") -> "void":
        return _openstudiomodelgeometry.CustomBlockVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.CustomBlockVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::CustomBlock >::size_type":
        return _openstudiomodelgeometry.CustomBlockVector_size(self)

    def swap(self, v: "CustomBlockVector") -> "void":
        return _openstudiomodelgeometry.CustomBlockVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::CustomBlock >::iterator":
        return _openstudiomodelgeometry.CustomBlockVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::CustomBlock >::iterator":
        return _openstudiomodelgeometry.CustomBlockVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::CustomBlock >::reverse_iterator":
        return _openstudiomodelgeometry.CustomBlockVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::CustomBlock >::reverse_iterator":
        return _openstudiomodelgeometry.CustomBlockVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.CustomBlockVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::CustomBlock >::allocator_type":
        return _openstudiomodelgeometry.CustomBlockVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.CustomBlockVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::CustomBlock >::iterator":
        return _openstudiomodelgeometry.CustomBlockVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.CustomBlockVector_swiginit(self, _openstudiomodelgeometry.new_CustomBlockVector(*args))

    def push_back(self, x: "CustomBlock") -> "void":
        return _openstudiomodelgeometry.CustomBlockVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::CustomBlock >::value_type const &":
        return _openstudiomodelgeometry.CustomBlockVector_front(self)

    def back(self) -> "std::vector< openstudio::model::CustomBlock >::value_type const &":
        return _openstudiomodelgeometry.CustomBlockVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::CustomBlock >::size_type", x: "CustomBlock") -> "void":
        return _openstudiomodelgeometry.CustomBlockVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::CustomBlock >::size_type", x: "CustomBlock") -> "void":
        return _openstudiomodelgeometry.CustomBlockVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.CustomBlockVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::CustomBlock >::size_type") -> "void":
        return _openstudiomodelgeometry.CustomBlockVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::CustomBlock >::size_type":
        return _openstudiomodelgeometry.CustomBlockVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_CustomBlockVector

# Register CustomBlockVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.CustomBlockVector_swigregister(CustomBlockVector)

class OptionalCustomBlock(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalCustomBlock_swiginit(self, _openstudiomodelgeometry.new_OptionalCustomBlock(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalCustomBlock_reset(self)

    def __ref__(self) -> "openstudio::model::CustomBlock":
        return _openstudiomodelgeometry.OptionalCustomBlock___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalCustomBlock_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalCustomBlock_isNull(self)

    def get(self) -> "openstudio::model::CustomBlock":
        return _openstudiomodelgeometry.OptionalCustomBlock_get(self)

    def set(self, t: "CustomBlock") -> "void":
        return _openstudiomodelgeometry.OptionalCustomBlock_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalCustomBlock

# Register OptionalCustomBlock in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalCustomBlock_swigregister(OptionalCustomBlock)

class FoundationKivaVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.FoundationKivaVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.FoundationKivaVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.FoundationKivaVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::FoundationKiva >::size_type":
        return _openstudiomodelgeometry.FoundationKivaVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::FoundationKiva >::difference_type", j: "std::vector< openstudio::model::FoundationKiva >::difference_type") -> "std::vector< openstudio::model::FoundationKiva,std::allocator< openstudio::model::FoundationKiva > > *":
        return _openstudiomodelgeometry.FoundationKivaVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.FoundationKivaVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::FoundationKiva >::difference_type", j: "std::vector< openstudio::model::FoundationKiva >::difference_type") -> "void":
        return _openstudiomodelgeometry.FoundationKivaVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.FoundationKivaVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::FoundationKiva >::value_type const &":
        return _openstudiomodelgeometry.FoundationKivaVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.FoundationKivaVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::FoundationKiva >::value_type":
        return _openstudiomodelgeometry.FoundationKivaVector_pop(self)

    def append(self, x: "FoundationKiva") -> "void":
        return _openstudiomodelgeometry.FoundationKivaVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.FoundationKivaVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::FoundationKiva >::size_type":
        return _openstudiomodelgeometry.FoundationKivaVector_size(self)

    def swap(self, v: "FoundationKivaVector") -> "void":
        return _openstudiomodelgeometry.FoundationKivaVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::FoundationKiva >::iterator":
        return _openstudiomodelgeometry.FoundationKivaVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::FoundationKiva >::iterator":
        return _openstudiomodelgeometry.FoundationKivaVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::FoundationKiva >::reverse_iterator":
        return _openstudiomodelgeometry.FoundationKivaVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::FoundationKiva >::reverse_iterator":
        return _openstudiomodelgeometry.FoundationKivaVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.FoundationKivaVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::FoundationKiva >::allocator_type":
        return _openstudiomodelgeometry.FoundationKivaVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.FoundationKivaVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::FoundationKiva >::iterator":
        return _openstudiomodelgeometry.FoundationKivaVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.FoundationKivaVector_swiginit(self, _openstudiomodelgeometry.new_FoundationKivaVector(*args))

    def push_back(self, x: "FoundationKiva") -> "void":
        return _openstudiomodelgeometry.FoundationKivaVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::FoundationKiva >::value_type const &":
        return _openstudiomodelgeometry.FoundationKivaVector_front(self)

    def back(self) -> "std::vector< openstudio::model::FoundationKiva >::value_type const &":
        return _openstudiomodelgeometry.FoundationKivaVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::FoundationKiva >::size_type", x: "FoundationKiva") -> "void":
        return _openstudiomodelgeometry.FoundationKivaVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::FoundationKiva >::size_type", x: "FoundationKiva") -> "void":
        return _openstudiomodelgeometry.FoundationKivaVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.FoundationKivaVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::FoundationKiva >::size_type") -> "void":
        return _openstudiomodelgeometry.FoundationKivaVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::FoundationKiva >::size_type":
        return _openstudiomodelgeometry.FoundationKivaVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_FoundationKivaVector

# Register FoundationKivaVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.FoundationKivaVector_swigregister(FoundationKivaVector)

class OptionalFoundationKiva(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalFoundationKiva_swiginit(self, _openstudiomodelgeometry.new_OptionalFoundationKiva(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalFoundationKiva_reset(self)

    def __ref__(self) -> "openstudio::model::FoundationKiva":
        return _openstudiomodelgeometry.OptionalFoundationKiva___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalFoundationKiva_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalFoundationKiva_isNull(self)

    def get(self) -> "openstudio::model::FoundationKiva":
        return _openstudiomodelgeometry.OptionalFoundationKiva_get(self)

    def set(self, t: "FoundationKiva") -> "void":
        return _openstudiomodelgeometry.OptionalFoundationKiva_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalFoundationKiva

# Register OptionalFoundationKiva in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalFoundationKiva_swigregister(OptionalFoundationKiva)

class SurfacePropertyExposedFoundationPerimeterVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::size_type":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::difference_type", j: "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::difference_type") -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter,std::allocator< openstudio::model::SurfacePropertyExposedFoundationPerimeter > > *":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::difference_type", j: "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::difference_type") -> "void":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::value_type const &":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::value_type":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_pop(self)

    def append(self, x: "SurfacePropertyExposedFoundationPerimeter") -> "void":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::size_type":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_size(self)

    def swap(self, v: "SurfacePropertyExposedFoundationPerimeterVector") -> "void":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::iterator":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::iterator":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::reverse_iterator":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::reverse_iterator":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::allocator_type":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::iterator":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_swiginit(self, _openstudiomodelgeometry.new_SurfacePropertyExposedFoundationPerimeterVector(*args))

    def push_back(self, x: "SurfacePropertyExposedFoundationPerimeter") -> "void":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::value_type const &":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_front(self)

    def back(self) -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::value_type const &":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::size_type", x: "SurfacePropertyExposedFoundationPerimeter") -> "void":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::size_type", x: "SurfacePropertyExposedFoundationPerimeter") -> "void":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::size_type") -> "void":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::size_type":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SurfacePropertyExposedFoundationPerimeterVector

# Register SurfacePropertyExposedFoundationPerimeterVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_swigregister(SurfacePropertyExposedFoundationPerimeterVector)

class OptionalSurfacePropertyExposedFoundationPerimeter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalSurfacePropertyExposedFoundationPerimeter_swiginit(self, _openstudiomodelgeometry.new_OptionalSurfacePropertyExposedFoundationPerimeter(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSurfacePropertyExposedFoundationPerimeter_reset(self)

    def __ref__(self) -> "openstudio::model::SurfacePropertyExposedFoundationPerimeter":
        return _openstudiomodelgeometry.OptionalSurfacePropertyExposedFoundationPerimeter___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSurfacePropertyExposedFoundationPerimeter_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSurfacePropertyExposedFoundationPerimeter_isNull(self)

    def get(self) -> "openstudio::model::SurfacePropertyExposedFoundationPerimeter":
        return _openstudiomodelgeometry.OptionalSurfacePropertyExposedFoundationPerimeter_get(self)

    def set(self, t: "SurfacePropertyExposedFoundationPerimeter") -> "void":
        return _openstudiomodelgeometry.OptionalSurfacePropertyExposedFoundationPerimeter_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSurfacePropertyExposedFoundationPerimeter

# Register OptionalSurfacePropertyExposedFoundationPerimeter in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalSurfacePropertyExposedFoundationPerimeter_swigregister(OptionalSurfacePropertyExposedFoundationPerimeter)

class ViewFactorVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.ViewFactorVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.ViewFactorVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.ViewFactorVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::ViewFactor >::size_type":
        return _openstudiomodelgeometry.ViewFactorVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::ViewFactor >::difference_type", j: "std::vector< openstudio::model::ViewFactor >::difference_type") -> "std::vector< openstudio::model::ViewFactor,std::allocator< openstudio::model::ViewFactor > > *":
        return _openstudiomodelgeometry.ViewFactorVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.ViewFactorVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::ViewFactor >::difference_type", j: "std::vector< openstudio::model::ViewFactor >::difference_type") -> "void":
        return _openstudiomodelgeometry.ViewFactorVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ViewFactorVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::ViewFactor >::value_type const &":
        return _openstudiomodelgeometry.ViewFactorVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ViewFactorVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::ViewFactor >::value_type":
        return _openstudiomodelgeometry.ViewFactorVector_pop(self)

    def append(self, x: "ViewFactor") -> "void":
        return _openstudiomodelgeometry.ViewFactorVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.ViewFactorVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::ViewFactor >::size_type":
        return _openstudiomodelgeometry.ViewFactorVector_size(self)

    def swap(self, v: "ViewFactorVector") -> "void":
        return _openstudiomodelgeometry.ViewFactorVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::ViewFactor >::iterator":
        return _openstudiomodelgeometry.ViewFactorVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::ViewFactor >::iterator":
        return _openstudiomodelgeometry.ViewFactorVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::ViewFactor >::reverse_iterator":
        return _openstudiomodelgeometry.ViewFactorVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::ViewFactor >::reverse_iterator":
        return _openstudiomodelgeometry.ViewFactorVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.ViewFactorVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::ViewFactor >::allocator_type":
        return _openstudiomodelgeometry.ViewFactorVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.ViewFactorVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::ViewFactor >::iterator":
        return _openstudiomodelgeometry.ViewFactorVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.ViewFactorVector_swiginit(self, _openstudiomodelgeometry.new_ViewFactorVector(*args))

    def push_back(self, x: "ViewFactor") -> "void":
        return _openstudiomodelgeometry.ViewFactorVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::ViewFactor >::value_type const &":
        return _openstudiomodelgeometry.ViewFactorVector_front(self)

    def back(self) -> "std::vector< openstudio::model::ViewFactor >::value_type const &":
        return _openstudiomodelgeometry.ViewFactorVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::ViewFactor >::size_type", x: "ViewFactor") -> "void":
        return _openstudiomodelgeometry.ViewFactorVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::ViewFactor >::size_type", x: "ViewFactor") -> "void":
        return _openstudiomodelgeometry.ViewFactorVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.ViewFactorVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::ViewFactor >::size_type") -> "void":
        return _openstudiomodelgeometry.ViewFactorVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::ViewFactor >::size_type":
        return _openstudiomodelgeometry.ViewFactorVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_ViewFactorVector

# Register ViewFactorVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.ViewFactorVector_swigregister(ViewFactorVector)

class OptionalViewFactor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalViewFactor_swiginit(self, _openstudiomodelgeometry.new_OptionalViewFactor(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalViewFactor_reset(self)

    def __ref__(self) -> "openstudio::model::ViewFactor":
        return _openstudiomodelgeometry.OptionalViewFactor___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalViewFactor_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalViewFactor_isNull(self)

    def get(self) -> "openstudio::model::ViewFactor":
        return _openstudiomodelgeometry.OptionalViewFactor_get(self)

    def set(self, t: "ViewFactor") -> "void":
        return _openstudiomodelgeometry.OptionalViewFactor_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalViewFactor

# Register OptionalViewFactor in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalViewFactor_swigregister(OptionalViewFactor)

class ZonePropertyUserViewFactorsBySurfaceNameVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName >::size_type":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName >::difference_type", j: "std::vector< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName >::difference_type") -> "std::vector< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName,std::allocator< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName > > *":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName >::difference_type", j: "std::vector< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName >::difference_type") -> "void":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName >::value_type const &":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName >::value_type":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector_pop(self)

    def append(self, x: "ZonePropertyUserViewFactorsBySurfaceName") -> "void":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName >::size_type":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector_size(self)

    def swap(self, v: "ZonePropertyUserViewFactorsBySurfaceNameVector") -> "void":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName >::iterator":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName >::iterator":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName >::reverse_iterator":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName >::reverse_iterator":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName >::allocator_type":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName >::iterator":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector_swiginit(self, _openstudiomodelgeometry.new_ZonePropertyUserViewFactorsBySurfaceNameVector(*args))

    def push_back(self, x: "ZonePropertyUserViewFactorsBySurfaceName") -> "void":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName >::value_type const &":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector_front(self)

    def back(self) -> "std::vector< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName >::value_type const &":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName >::size_type", x: "ZonePropertyUserViewFactorsBySurfaceName") -> "void":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName >::size_type", x: "ZonePropertyUserViewFactorsBySurfaceName") -> "void":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName >::size_type") -> "void":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName >::size_type":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_ZonePropertyUserViewFactorsBySurfaceNameVector

# Register ZonePropertyUserViewFactorsBySurfaceNameVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceNameVector_swigregister(ZonePropertyUserViewFactorsBySurfaceNameVector)

class OptionalZonePropertyUserViewFactorsBySurfaceName(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalZonePropertyUserViewFactorsBySurfaceName_swiginit(self, _openstudiomodelgeometry.new_OptionalZonePropertyUserViewFactorsBySurfaceName(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalZonePropertyUserViewFactorsBySurfaceName_reset(self)

    def __ref__(self) -> "openstudio::model::ZonePropertyUserViewFactorsBySurfaceName":
        return _openstudiomodelgeometry.OptionalZonePropertyUserViewFactorsBySurfaceName___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalZonePropertyUserViewFactorsBySurfaceName_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalZonePropertyUserViewFactorsBySurfaceName_isNull(self)

    def get(self) -> "openstudio::model::ZonePropertyUserViewFactorsBySurfaceName":
        return _openstudiomodelgeometry.OptionalZonePropertyUserViewFactorsBySurfaceName_get(self)

    def set(self, t: "ZonePropertyUserViewFactorsBySurfaceName") -> "void":
        return _openstudiomodelgeometry.OptionalZonePropertyUserViewFactorsBySurfaceName_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalZonePropertyUserViewFactorsBySurfaceName

# Register OptionalZonePropertyUserViewFactorsBySurfaceName in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalZonePropertyUserViewFactorsBySurfaceName_swigregister(OptionalZonePropertyUserViewFactorsBySurfaceName)

class ExteriorLoadInstanceVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::ExteriorLoadInstance >::size_type":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::ExteriorLoadInstance >::difference_type", j: "std::vector< openstudio::model::ExteriorLoadInstance >::difference_type") -> "std::vector< openstudio::model::ExteriorLoadInstance,std::allocator< openstudio::model::ExteriorLoadInstance > > *":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::ExteriorLoadInstance >::difference_type", j: "std::vector< openstudio::model::ExteriorLoadInstance >::difference_type") -> "void":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::ExteriorLoadInstance >::value_type const &":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::ExteriorLoadInstance >::value_type":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_pop(self)

    def append(self, x: "ExteriorLoadInstance") -> "void":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::ExteriorLoadInstance >::size_type":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_size(self)

    def swap(self, v: "ExteriorLoadInstanceVector") -> "void":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::ExteriorLoadInstance >::iterator":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::ExteriorLoadInstance >::iterator":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::ExteriorLoadInstance >::reverse_iterator":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::ExteriorLoadInstance >::reverse_iterator":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::ExteriorLoadInstance >::allocator_type":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::ExteriorLoadInstance >::iterator":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.ExteriorLoadInstanceVector_swiginit(self, _openstudiomodelgeometry.new_ExteriorLoadInstanceVector(*args))

    def push_back(self, x: "ExteriorLoadInstance") -> "void":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::ExteriorLoadInstance >::value_type const &":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_front(self)

    def back(self) -> "std::vector< openstudio::model::ExteriorLoadInstance >::value_type const &":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::ExteriorLoadInstance >::size_type", x: "ExteriorLoadInstance") -> "void":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::ExteriorLoadInstance >::size_type", x: "ExteriorLoadInstance") -> "void":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::ExteriorLoadInstance >::size_type") -> "void":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::ExteriorLoadInstance >::size_type":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_ExteriorLoadInstanceVector

# Register ExteriorLoadInstanceVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.ExteriorLoadInstanceVector_swigregister(ExteriorLoadInstanceVector)

class OptionalExteriorLoadInstance(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalExteriorLoadInstance_swiginit(self, _openstudiomodelgeometry.new_OptionalExteriorLoadInstance(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalExteriorLoadInstance_reset(self)

    def __ref__(self) -> "openstudio::model::ExteriorLoadInstance":
        return _openstudiomodelgeometry.OptionalExteriorLoadInstance___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalExteriorLoadInstance_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalExteriorLoadInstance_isNull(self)

    def get(self) -> "openstudio::model::ExteriorLoadInstance":
        return _openstudiomodelgeometry.OptionalExteriorLoadInstance_get(self)

    def set(self, t: "ExteriorLoadInstance") -> "void":
        return _openstudiomodelgeometry.OptionalExteriorLoadInstance_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalExteriorLoadInstance

# Register OptionalExteriorLoadInstance in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalExteriorLoadInstance_swigregister(OptionalExteriorLoadInstance)

class ExteriorLightsVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.ExteriorLightsVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorLightsVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorLightsVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::ExteriorLights >::size_type":
        return _openstudiomodelgeometry.ExteriorLightsVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::ExteriorLights >::difference_type", j: "std::vector< openstudio::model::ExteriorLights >::difference_type") -> "std::vector< openstudio::model::ExteriorLights,std::allocator< openstudio::model::ExteriorLights > > *":
        return _openstudiomodelgeometry.ExteriorLightsVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorLightsVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::ExteriorLights >::difference_type", j: "std::vector< openstudio::model::ExteriorLights >::difference_type") -> "void":
        return _openstudiomodelgeometry.ExteriorLightsVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorLightsVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::ExteriorLights >::value_type const &":
        return _openstudiomodelgeometry.ExteriorLightsVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorLightsVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::ExteriorLights >::value_type":
        return _openstudiomodelgeometry.ExteriorLightsVector_pop(self)

    def append(self, x: "ExteriorLights") -> "void":
        return _openstudiomodelgeometry.ExteriorLightsVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorLightsVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::ExteriorLights >::size_type":
        return _openstudiomodelgeometry.ExteriorLightsVector_size(self)

    def swap(self, v: "ExteriorLightsVector") -> "void":
        return _openstudiomodelgeometry.ExteriorLightsVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::ExteriorLights >::iterator":
        return _openstudiomodelgeometry.ExteriorLightsVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::ExteriorLights >::iterator":
        return _openstudiomodelgeometry.ExteriorLightsVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::ExteriorLights >::reverse_iterator":
        return _openstudiomodelgeometry.ExteriorLightsVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::ExteriorLights >::reverse_iterator":
        return _openstudiomodelgeometry.ExteriorLightsVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.ExteriorLightsVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::ExteriorLights >::allocator_type":
        return _openstudiomodelgeometry.ExteriorLightsVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.ExteriorLightsVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::ExteriorLights >::iterator":
        return _openstudiomodelgeometry.ExteriorLightsVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.ExteriorLightsVector_swiginit(self, _openstudiomodelgeometry.new_ExteriorLightsVector(*args))

    def push_back(self, x: "ExteriorLights") -> "void":
        return _openstudiomodelgeometry.ExteriorLightsVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::ExteriorLights >::value_type const &":
        return _openstudiomodelgeometry.ExteriorLightsVector_front(self)

    def back(self) -> "std::vector< openstudio::model::ExteriorLights >::value_type const &":
        return _openstudiomodelgeometry.ExteriorLightsVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::ExteriorLights >::size_type", x: "ExteriorLights") -> "void":
        return _openstudiomodelgeometry.ExteriorLightsVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::ExteriorLights >::size_type", x: "ExteriorLights") -> "void":
        return _openstudiomodelgeometry.ExteriorLightsVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorLightsVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::ExteriorLights >::size_type") -> "void":
        return _openstudiomodelgeometry.ExteriorLightsVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::ExteriorLights >::size_type":
        return _openstudiomodelgeometry.ExteriorLightsVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_ExteriorLightsVector

# Register ExteriorLightsVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.ExteriorLightsVector_swigregister(ExteriorLightsVector)

class OptionalExteriorLights(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalExteriorLights_swiginit(self, _openstudiomodelgeometry.new_OptionalExteriorLights(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalExteriorLights_reset(self)

    def __ref__(self) -> "openstudio::model::ExteriorLights":
        return _openstudiomodelgeometry.OptionalExteriorLights___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalExteriorLights_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalExteriorLights_isNull(self)

    def get(self) -> "openstudio::model::ExteriorLights":
        return _openstudiomodelgeometry.OptionalExteriorLights_get(self)

    def set(self, t: "ExteriorLights") -> "void":
        return _openstudiomodelgeometry.OptionalExteriorLights_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalExteriorLights

# Register OptionalExteriorLights in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalExteriorLights_swigregister(OptionalExteriorLights)

class ExteriorFuelEquipmentVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::ExteriorFuelEquipment >::size_type":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::ExteriorFuelEquipment >::difference_type", j: "std::vector< openstudio::model::ExteriorFuelEquipment >::difference_type") -> "std::vector< openstudio::model::ExteriorFuelEquipment,std::allocator< openstudio::model::ExteriorFuelEquipment > > *":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::ExteriorFuelEquipment >::difference_type", j: "std::vector< openstudio::model::ExteriorFuelEquipment >::difference_type") -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::ExteriorFuelEquipment >::value_type const &":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::ExteriorFuelEquipment >::value_type":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_pop(self)

    def append(self, x: "ExteriorFuelEquipment") -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::ExteriorFuelEquipment >::size_type":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_size(self)

    def swap(self, v: "ExteriorFuelEquipmentVector") -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::ExteriorFuelEquipment >::iterator":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::ExteriorFuelEquipment >::iterator":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::ExteriorFuelEquipment >::reverse_iterator":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::ExteriorFuelEquipment >::reverse_iterator":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::ExteriorFuelEquipment >::allocator_type":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::ExteriorFuelEquipment >::iterator":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.ExteriorFuelEquipmentVector_swiginit(self, _openstudiomodelgeometry.new_ExteriorFuelEquipmentVector(*args))

    def push_back(self, x: "ExteriorFuelEquipment") -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::ExteriorFuelEquipment >::value_type const &":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_front(self)

    def back(self) -> "std::vector< openstudio::model::ExteriorFuelEquipment >::value_type const &":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::ExteriorFuelEquipment >::size_type", x: "ExteriorFuelEquipment") -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::ExteriorFuelEquipment >::size_type", x: "ExteriorFuelEquipment") -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::ExteriorFuelEquipment >::size_type") -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::ExteriorFuelEquipment >::size_type":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_ExteriorFuelEquipmentVector

# Register ExteriorFuelEquipmentVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.ExteriorFuelEquipmentVector_swigregister(ExteriorFuelEquipmentVector)

class OptionalExteriorFuelEquipment(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalExteriorFuelEquipment_swiginit(self, _openstudiomodelgeometry.new_OptionalExteriorFuelEquipment(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalExteriorFuelEquipment_reset(self)

    def __ref__(self) -> "openstudio::model::ExteriorFuelEquipment":
        return _openstudiomodelgeometry.OptionalExteriorFuelEquipment___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalExteriorFuelEquipment_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalExteriorFuelEquipment_isNull(self)

    def get(self) -> "openstudio::model::ExteriorFuelEquipment":
        return _openstudiomodelgeometry.OptionalExteriorFuelEquipment_get(self)

    def set(self, t: "ExteriorFuelEquipment") -> "void":
        return _openstudiomodelgeometry.OptionalExteriorFuelEquipment_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalExteriorFuelEquipment

# Register OptionalExteriorFuelEquipment in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalExteriorFuelEquipment_swigregister(OptionalExteriorFuelEquipment)

class ExteriorWaterEquipmentVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::ExteriorWaterEquipment >::size_type":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector___len__(self)

    def __getslice__(self, i: "std::vector< openstudio::model::ExteriorWaterEquipment >::difference_type", j: "std::vector< openstudio::model::ExteriorWaterEquipment >::difference_type") -> "std::vector< openstudio::model::ExteriorWaterEquipment,std::allocator< openstudio::model::ExteriorWaterEquipment > > *":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< openstudio::model::ExteriorWaterEquipment >::difference_type", j: "std::vector< openstudio::model::ExteriorWaterEquipment >::difference_type") -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::ExteriorWaterEquipment >::value_type const &":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector___setitem__(self, *args)

    def pop(self) -> "std::vector< openstudio::model::ExteriorWaterEquipment >::value_type":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_pop(self)

    def append(self, x: "ExteriorWaterEquipment") -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::ExteriorWaterEquipment >::size_type":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_size(self)

    def swap(self, v: "ExteriorWaterEquipmentVector") -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_swap(self, v)

    def begin(self) -> "std::vector< openstudio::model::ExteriorWaterEquipment >::iterator":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::ExteriorWaterEquipment >::iterator":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::ExteriorWaterEquipment >::reverse_iterator":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::ExteriorWaterEquipment >::reverse_iterator":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_rend(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_clear(self)

    def get_allocator(self) -> "std::vector< openstudio::model::ExteriorWaterEquipment >::allocator_type":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::ExteriorWaterEquipment >::iterator":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_erase(self, *args)

    def __init__(self, *args):
        _openstudiomodelgeometry.ExteriorWaterEquipmentVector_swiginit(self, _openstudiomodelgeometry.new_ExteriorWaterEquipmentVector(*args))

    def push_back(self, x: "ExteriorWaterEquipment") -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::ExteriorWaterEquipment >::value_type const &":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_front(self)

    def back(self) -> "std::vector< openstudio::model::ExteriorWaterEquipment >::value_type const &":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_back(self)

    def assign(self, n: "std::vector< openstudio::model::ExteriorWaterEquipment >::size_type", x: "ExteriorWaterEquipment") -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_assign(self, n, x)

    def resize(self, new_size: "std::vector< openstudio::model::ExteriorWaterEquipment >::size_type", x: "ExteriorWaterEquipment") -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_insert(self, *args)

    def reserve(self, n: "std::vector< openstudio::model::ExteriorWaterEquipment >::size_type") -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::ExteriorWaterEquipment >::size_type":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_ExteriorWaterEquipmentVector

# Register ExteriorWaterEquipmentVector in _openstudiomodelgeometry:
_openstudiomodelgeometry.ExteriorWaterEquipmentVector_swigregister(ExteriorWaterEquipmentVector)

class OptionalExteriorWaterEquipment(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.OptionalExteriorWaterEquipment_swiginit(self, _openstudiomodelgeometry.new_OptionalExteriorWaterEquipment(*args))

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalExteriorWaterEquipment_reset(self)

    def __ref__(self) -> "openstudio::model::ExteriorWaterEquipment":
        return _openstudiomodelgeometry.OptionalExteriorWaterEquipment___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalExteriorWaterEquipment_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalExteriorWaterEquipment_isNull(self)

    def get(self) -> "openstudio::model::ExteriorWaterEquipment":
        return _openstudiomodelgeometry.OptionalExteriorWaterEquipment_get(self)

    def set(self, t: "ExteriorWaterEquipment") -> "void":
        return _openstudiomodelgeometry.OptionalExteriorWaterEquipment_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalExteriorWaterEquipment

# Register OptionalExteriorWaterEquipment in _openstudiomodelgeometry:
_openstudiomodelgeometry.OptionalExteriorWaterEquipment_swigregister(OptionalExteriorWaterEquipment)

class Site(openstudiomodelcore.ParentObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomodelgeometry.delete_Site

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.Site_iddObjectType()

    @staticmethod
    def validTerrainValues() -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.Site_validTerrainValues()

    def latitude(self) -> "double":
        return _openstudiomodelgeometry.Site_latitude(self)

    def isLatitudeDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Site_isLatitudeDefaulted(self)

    def longitude(self) -> "double":
        return _openstudiomodelgeometry.Site_longitude(self)

    def isLongitudeDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Site_isLongitudeDefaulted(self)

    def timeZone(self) -> "double":
        return _openstudiomodelgeometry.Site_timeZone(self)

    def isTimeZoneDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Site_isTimeZoneDefaulted(self)

    def elevation(self) -> "double":
        return _openstudiomodelgeometry.Site_elevation(self)

    def isElevationDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Site_isElevationDefaulted(self)

    def terrain(self) -> "std::string":
        return _openstudiomodelgeometry.Site_terrain(self)

    def isTerrainDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Site_isTerrainDefaulted(self)

    def setLatitude(self, latitude: "double") -> "bool":
        return _openstudiomodelgeometry.Site_setLatitude(self, latitude)

    def resetLatitude(self) -> "void":
        return _openstudiomodelgeometry.Site_resetLatitude(self)

    def setLongitude(self, longitude: "double") -> "bool":
        return _openstudiomodelgeometry.Site_setLongitude(self, longitude)

    def resetLongitude(self) -> "void":
        return _openstudiomodelgeometry.Site_resetLongitude(self)

    def setTimeZone(self, timeZone: "double") -> "bool":
        return _openstudiomodelgeometry.Site_setTimeZone(self, timeZone)

    def resetTimeZone(self) -> "void":
        return _openstudiomodelgeometry.Site_resetTimeZone(self)

    def setElevation(self, elevation: "double") -> "bool":
        return _openstudiomodelgeometry.Site_setElevation(self, elevation)

    def resetElevation(self) -> "void":
        return _openstudiomodelgeometry.Site_resetElevation(self)

    def setTerrain(self, terrain: "std::string") -> "bool":
        return _openstudiomodelgeometry.Site_setTerrain(self, terrain)

    def resetTerrain(self) -> "void":
        return _openstudiomodelgeometry.Site_resetTerrain(self)

    def weatherFile(self) -> "boost::optional< openstudio::model::WeatherFile >":
        return _openstudiomodelgeometry.Site_weatherFile(self)

    def siteGroundReflectance(self) -> "boost::optional< openstudio::model::SiteGroundReflectance >":
        return _openstudiomodelgeometry.Site_siteGroundReflectance(self)

    def siteGroundTemperatureBuildingSurface(self) -> "boost::optional< openstudio::model::SiteGroundTemperatureBuildingSurface >":
        return _openstudiomodelgeometry.Site_siteGroundTemperatureBuildingSurface(self)

    def siteGroundTemperatureDeep(self) -> "boost::optional< openstudio::model::SiteGroundTemperatureDeep >":
        return _openstudiomodelgeometry.Site_siteGroundTemperatureDeep(self)

    def siteGroundTemperatureShallow(self) -> "boost::optional< openstudio::model::SiteGroundTemperatureShallow >":
        return _openstudiomodelgeometry.Site_siteGroundTemperatureShallow(self)

    def siteGroundTemperatureFCfactorMethod(self) -> "boost::optional< openstudio::model::SiteGroundTemperatureFCfactorMethod >":
        return _openstudiomodelgeometry.Site_siteGroundTemperatureFCfactorMethod(self)

    def siteWaterMainsTemperature(self) -> "boost::optional< openstudio::model::SiteWaterMainsTemperature >":
        return _openstudiomodelgeometry.Site_siteWaterMainsTemperature(self)

    def climateZones(self) -> "boost::optional< openstudio::model::ClimateZones >":
        return _openstudiomodelgeometry.Site_climateZones(self)

    def shadingSurfaceGroups(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup,std::allocator< openstudio::model::ShadingSurfaceGroup > >":
        return _openstudiomodelgeometry.Site_shadingSurfaceGroups(self)

# Register Site in _openstudiomodelgeometry:
_openstudiomodelgeometry.Site_swigregister(Site)

def Site_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.Site_iddObjectType()

def Site_validTerrainValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.Site_validTerrainValues()


def toSite(idfObject: "IdfObject") -> "boost::optional< openstudio::model::Site >":
    return _openstudiomodelgeometry.toSite(idfObject)

def getSite(t_model: "Model") -> "openstudio::model::Site":
    return _openstudiomodelgeometry.getSite(t_model)

def getOptionalSite(t_model: "Model") -> "boost::optional< openstudio::model::Site >":
    return _openstudiomodelgeometry.getOptionalSite(t_model)

def _to_Site(self) -> OptionalSite:
    return toSite(self)
openstudioutilitiesidf.IdfObject.to_Site = _to_Site

def _getSite(self) -> Site:
    return getSite(self)
Model.getSite = _getSite

def _getOptionalSite(self) -> OptionalSite:
    return getOptionalSite(self)
Model.getOptionalSite = _getOptionalSite

class Facility(openstudiomodelcore.ParentObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomodelgeometry.delete_Facility

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.Facility_iddObjectType()

    @staticmethod
    def fossilFuels() -> "std::vector< openstudio::FuelType,std::allocator< openstudio::FuelType > >":
        return _openstudiomodelgeometry.Facility_fossilFuels()

    def building(self) -> "boost::optional< openstudio::model::Building >":
        return _openstudiomodelgeometry.Facility_building(self)

    def meters(self) -> "std::vector< openstudio::model::OutputMeter,std::allocator< openstudio::model::OutputMeter > >":
        return _openstudiomodelgeometry.Facility_meters(self)

    def getMeterByFuelType(self, *args) -> "boost::optional< openstudio::model::OutputMeter >":
        return _openstudiomodelgeometry.Facility_getMeterByFuelType(self, *args)

    def exteriorLights(self) -> "std::vector< openstudio::model::ExteriorLights,std::allocator< openstudio::model::ExteriorLights > >":
        return _openstudiomodelgeometry.Facility_exteriorLights(self)

    def exteriorFuelEquipments(self) -> "std::vector< openstudio::model::ExteriorFuelEquipment,std::allocator< openstudio::model::ExteriorFuelEquipment > >":
        return _openstudiomodelgeometry.Facility_exteriorFuelEquipments(self)

    def exteriorWaterEquipments(self) -> "std::vector< openstudio::model::ExteriorWaterEquipment,std::allocator< openstudio::model::ExteriorWaterEquipment > >":
        return _openstudiomodelgeometry.Facility_exteriorWaterEquipments(self)

    def totalSiteEnergy(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_totalSiteEnergy(self)

    def netSiteEnergy(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_netSiteEnergy(self)

    def totalSourceEnergy(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_totalSourceEnergy(self)

    def netSourceEnergy(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_netSourceEnergy(self)

    def annualTotalCost(self, fuel: "FuelType") -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_annualTotalCost(self, fuel)

    def annualTotalCostPerBldgArea(self, fuel: "FuelType") -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_annualTotalCostPerBldgArea(self, fuel)

    def annualTotalCostPerNetConditionedBldgArea(self, fuel: "FuelType") -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_annualTotalCostPerNetConditionedBldgArea(self, fuel)

    def annualTotalUtilityCost(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_annualTotalUtilityCost(self)

    def annualElectricTotalCost(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_annualElectricTotalCost(self)

    def annualGasTotalCost(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_annualGasTotalCost(self)

    def annualDistrictCoolingTotalCost(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_annualDistrictCoolingTotalCost(self)

    def annualDistrictHeatingTotalCost(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_annualDistrictHeatingTotalCost(self)

    def annualWaterTotalCost(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_annualWaterTotalCost(self)

    def economicsCapitalCost(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_economicsCapitalCost(self)

    def economicsEnergyCost(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_economicsEnergyCost(self)

    def economicsTLCC(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_economicsTLCC(self)

    def economicsVirtualRateGas(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_economicsVirtualRateGas(self)

    def economicsVirtualRateElec(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_economicsVirtualRateElec(self)

    def economicsVirtualRateCombined(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_economicsVirtualRateCombined(self)

    def economicsSPB(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_economicsSPB(self)

    def economicsDPB(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_economicsDPB(self)

    def economicsNPV(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_economicsNPV(self)

    def economicsIRR(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_economicsIRR(self)

    def electricityHeating(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityHeating(self)

    def electricityCooling(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityCooling(self)

    def electricityInteriorLighting(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityInteriorLighting(self)

    def electricityExteriorLighting(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityExteriorLighting(self)

    def electricityInteriorEquipment(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityInteriorEquipment(self)

    def electricityExteriorEquipment(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityExteriorEquipment(self)

    def electricityFans(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityFans(self)

    def electricityPumps(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityPumps(self)

    def electricityHeatRejection(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityHeatRejection(self)

    def electricityHumidification(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityHumidification(self)

    def electricityHeatRecovery(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityHeatRecovery(self)

    def electricityWaterSystems(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityWaterSystems(self)

    def electricityRefrigeration(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityRefrigeration(self)

    def electricityGenerators(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityGenerators(self)

    def electricityTotalEndUses(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityTotalEndUses(self)

    def naturalGasHeating(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasHeating(self)

    def naturalGasCooling(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasCooling(self)

    def naturalGasInteriorLighting(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasInteriorLighting(self)

    def naturalGasExteriorLighting(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasExteriorLighting(self)

    def naturalGasInteriorEquipment(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasInteriorEquipment(self)

    def naturalGasExteriorEquipment(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasExteriorEquipment(self)

    def naturalGasFans(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasFans(self)

    def naturalGasPumps(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasPumps(self)

    def naturalGasHeatRejection(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasHeatRejection(self)

    def naturalGasHumidification(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasHumidification(self)

    def naturalGasHeatRecovery(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasHeatRecovery(self)

    def naturalGasWaterSystems(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasWaterSystems(self)

    def naturalGasRefrigeration(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasRefrigeration(self)

    def naturalGasGenerators(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasGenerators(self)

    def naturalGasTotalEndUses(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasTotalEndUses(self)

    def otherFuelHeating(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelHeating(self)

    def otherFuelCooling(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelCooling(self)

    def otherFuelInteriorLighting(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelInteriorLighting(self)

    def otherFuelExteriorLighting(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelExteriorLighting(self)

    def otherFuelInteriorEquipment(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelInteriorEquipment(self)

    def otherFuelExteriorEquipment(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelExteriorEquipment(self)

    def otherFuelFans(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelFans(self)

    def otherFuelPumps(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelPumps(self)

    def otherFuelHeatRejection(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelHeatRejection(self)

    def otherFuelHumidification(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelHumidification(self)

    def otherFuelHeatRecovery(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelHeatRecovery(self)

    def otherFuelWaterSystems(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelWaterSystems(self)

    def otherFuelRefrigeration(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelRefrigeration(self)

    def otherFuelGenerators(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelGenerators(self)

    def otherFuelTotalEndUses(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelTotalEndUses(self)

    def districtCoolingHeating(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingHeating(self)

    def districtCoolingCooling(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingCooling(self)

    def districtCoolingInteriorLighting(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingInteriorLighting(self)

    def districtCoolingExteriorLighting(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingExteriorLighting(self)

    def districtCoolingInteriorEquipment(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingInteriorEquipment(self)

    def districtCoolingExteriorEquipment(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingExteriorEquipment(self)

    def districtCoolingFans(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingFans(self)

    def districtCoolingPumps(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingPumps(self)

    def districtCoolingHeatRejection(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingHeatRejection(self)

    def districtCoolingHumidification(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingHumidification(self)

    def districtCoolingHeatRecovery(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingHeatRecovery(self)

    def districtCoolingWaterSystems(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingWaterSystems(self)

    def districtCoolingRefrigeration(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingRefrigeration(self)

    def districtCoolingGenerators(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingGenerators(self)

    def districtCoolingTotalEndUses(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingTotalEndUses(self)

    def districtHeatingHeating(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingHeating(self)

    def districtHeatingCooling(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingCooling(self)

    def districtHeatingInteriorLighting(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingInteriorLighting(self)

    def districtHeatingExteriorLighting(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingExteriorLighting(self)

    def districtHeatingInteriorEquipment(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingInteriorEquipment(self)

    def districtHeatingExteriorEquipment(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingExteriorEquipment(self)

    def districtHeatingFans(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingFans(self)

    def districtHeatingPumps(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingPumps(self)

    def districtHeatingHeatRejection(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingHeatRejection(self)

    def districtHeatingHumidification(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingHumidification(self)

    def districtHeatingHeatRecovery(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingHeatRecovery(self)

    def districtHeatingWaterSystems(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingWaterSystems(self)

    def districtHeatingRefrigeration(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingRefrigeration(self)

    def districtHeatingGenerators(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingGenerators(self)

    def districtHeatingTotalEndUses(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingTotalEndUses(self)

    def waterHeating(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterHeating(self)

    def waterCooling(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterCooling(self)

    def waterInteriorLighting(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterInteriorLighting(self)

    def waterExteriorLighting(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterExteriorLighting(self)

    def waterInteriorEquipment(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterInteriorEquipment(self)

    def waterExteriorEquipment(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterExteriorEquipment(self)

    def waterFans(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterFans(self)

    def waterPumps(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterPumps(self)

    def waterHeatRejection(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterHeatRejection(self)

    def waterHumidification(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterHumidification(self)

    def waterHeatRecovery(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterHeatRecovery(self)

    def waterWaterSystems(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterWaterSystems(self)

    def waterRefrigeration(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterRefrigeration(self)

    def waterGenerators(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterGenerators(self)

    def waterTotalEndUses(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterTotalEndUses(self)

    def hoursHeatingSetpointNotMet(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_hoursHeatingSetpointNotMet(self)

    def hoursCoolingSetpointNotMet(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_hoursCoolingSetpointNotMet(self)

    def endUses(self) -> "boost::optional< openstudio::EndUses >":
        return _openstudiomodelgeometry.Facility_endUses(self)

    def endUsesAttribute(self) -> "boost::optional< openstudio::Attribute >":
        return _openstudiomodelgeometry.Facility_endUsesAttribute(self)

    def calibrationResult(self) -> "boost::optional< openstudio::CalibrationResult >":
        return _openstudiomodelgeometry.Facility_calibrationResult(self)

    def calibrationResultAttribute(self) -> "boost::optional< openstudio::Attribute >":
        return _openstudiomodelgeometry.Facility_calibrationResultAttribute(self)

# Register Facility in _openstudiomodelgeometry:
_openstudiomodelgeometry.Facility_swigregister(Facility)

def Facility_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.Facility_iddObjectType()

def Facility_fossilFuels() -> "std::vector< openstudio::FuelType,std::allocator< openstudio::FuelType > >":
    return _openstudiomodelgeometry.Facility_fossilFuels()


def toFacility(idfObject: "IdfObject") -> "boost::optional< openstudio::model::Facility >":
    return _openstudiomodelgeometry.toFacility(idfObject)

def getFacility(t_model: "Model") -> "openstudio::model::Facility":
    return _openstudiomodelgeometry.getFacility(t_model)

def getOptionalFacility(t_model: "Model") -> "boost::optional< openstudio::model::Facility >":
    return _openstudiomodelgeometry.getOptionalFacility(t_model)

def _to_Facility(self) -> OptionalFacility:
    return toFacility(self)
openstudioutilitiesidf.IdfObject.to_Facility = _to_Facility

def _getFacility(self) -> Facility:
    return getFacility(self)
Model.getFacility = _getFacility

def _getOptionalFacility(self) -> OptionalFacility:
    return getOptionalFacility(self)
Model.getOptionalFacility = _getOptionalFacility

class Building(openstudiomodelcore.ParentObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomodelgeometry.delete_Building

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.Building_iddObjectType()

    def northAxis(self) -> "double":
        return _openstudiomodelgeometry.Building_northAxis(self)

    def isNorthAxisDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Building_isNorthAxisDefaulted(self)

    def nominalFloortoFloorHeight(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Building_nominalFloortoFloorHeight(self)

    def standardsNumberOfStories(self) -> "boost::optional< int >":
        return _openstudiomodelgeometry.Building_standardsNumberOfStories(self)

    def standardsNumberOfAboveGroundStories(self) -> "boost::optional< int >":
        return _openstudiomodelgeometry.Building_standardsNumberOfAboveGroundStories(self)

    def standardsNumberOfLivingUnits(self) -> "boost::optional< int >":
        return _openstudiomodelgeometry.Building_standardsNumberOfLivingUnits(self)

    def nominalFloortoCeilingHeight(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Building_nominalFloortoCeilingHeight(self)

    def standardsTemplate(self) -> "boost::optional< std::string >":
        return _openstudiomodelgeometry.Building_standardsTemplate(self)

    def suggestedStandardsTemplates(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.Building_suggestedStandardsTemplates(self)

    def standardsBuildingType(self) -> "boost::optional< std::string >":
        return _openstudiomodelgeometry.Building_standardsBuildingType(self)

    def suggestedStandardsBuildingTypes(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.Building_suggestedStandardsBuildingTypes(self)

    def relocatable(self) -> "bool":
        return _openstudiomodelgeometry.Building_relocatable(self)

    def isRelocatableDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Building_isRelocatableDefaulted(self)

    def getDefaultSchedule(self, defaultScheduleType: "DefaultScheduleType") -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.Building_getDefaultSchedule(self, defaultScheduleType)

    def setNorthAxis(self, northAxis: "double") -> "bool":
        return _openstudiomodelgeometry.Building_setNorthAxis(self, northAxis)

    def resetNorthAxis(self) -> "void":
        return _openstudiomodelgeometry.Building_resetNorthAxis(self)

    def setNominalFloortoFloorHeight(self, nominalFloortoFloorHeight: "double") -> "bool":
        return _openstudiomodelgeometry.Building_setNominalFloortoFloorHeight(self, nominalFloortoFloorHeight)

    def resetNominalFloortoFloorHeight(self) -> "void":
        return _openstudiomodelgeometry.Building_resetNominalFloortoFloorHeight(self)

    def setStandardsNumberOfStories(self, value: "int") -> "bool":
        return _openstudiomodelgeometry.Building_setStandardsNumberOfStories(self, value)

    def resetStandardsNumberOfStories(self) -> "void":
        return _openstudiomodelgeometry.Building_resetStandardsNumberOfStories(self)

    def setStandardsNumberOfAboveGroundStories(self, value: "int") -> "bool":
        return _openstudiomodelgeometry.Building_setStandardsNumberOfAboveGroundStories(self, value)

    def resetStandardsNumberOfAboveGroundStories(self) -> "void":
        return _openstudiomodelgeometry.Building_resetStandardsNumberOfAboveGroundStories(self)

    def setStandardsNumberOfLivingUnits(self, value: "int") -> "bool":
        return _openstudiomodelgeometry.Building_setStandardsNumberOfLivingUnits(self, value)

    def resetStandardsNumberOfLivingUnits(self) -> "void":
        return _openstudiomodelgeometry.Building_resetStandardsNumberOfLivingUnits(self)

    def setNominalFloortoCeilingHeight(self, nominalFloortoCeilingHeight: "double") -> "bool":
        return _openstudiomodelgeometry.Building_setNominalFloortoCeilingHeight(self, nominalFloortoCeilingHeight)

    def resetNominalFloortoCeilingHeight(self) -> "void":
        return _openstudiomodelgeometry.Building_resetNominalFloortoCeilingHeight(self)

    def setStandardsTemplate(self, standardsTemplate: "std::string const &") -> "bool":
        return _openstudiomodelgeometry.Building_setStandardsTemplate(self, standardsTemplate)

    def resetStandardsTemplate(self) -> "void":
        return _openstudiomodelgeometry.Building_resetStandardsTemplate(self)

    def setStandardsBuildingType(self, standardsBuildingType: "std::string const &") -> "bool":
        return _openstudiomodelgeometry.Building_setStandardsBuildingType(self, standardsBuildingType)

    def resetStandardsBuildingType(self) -> "void":
        return _openstudiomodelgeometry.Building_resetStandardsBuildingType(self)

    def setRelocatable(self, isRelocatable: "bool") -> "bool":
        return _openstudiomodelgeometry.Building_setRelocatable(self, isRelocatable)

    def setRelocatableNoFail(self, isRelocatable: "bool") -> "void":
        return _openstudiomodelgeometry.Building_setRelocatableNoFail(self, isRelocatable)

    def resetRelocatable(self) -> "void":
        return _openstudiomodelgeometry.Building_resetRelocatable(self)

    def spaceType(self) -> "boost::optional< openstudio::model::SpaceType >":
        return _openstudiomodelgeometry.Building_spaceType(self)

    def setSpaceType(self, spaceType: "SpaceType") -> "bool":
        return _openstudiomodelgeometry.Building_setSpaceType(self, spaceType)

    def resetSpaceType(self) -> "void":
        return _openstudiomodelgeometry.Building_resetSpaceType(self)

    def defaultConstructionSet(self) -> "boost::optional< openstudio::model::DefaultConstructionSet >":
        return _openstudiomodelgeometry.Building_defaultConstructionSet(self)

    def setDefaultConstructionSet(self, defaultConstructionSet: "DefaultConstructionSet") -> "bool":
        return _openstudiomodelgeometry.Building_setDefaultConstructionSet(self, defaultConstructionSet)

    def resetDefaultConstructionSet(self) -> "void":
        return _openstudiomodelgeometry.Building_resetDefaultConstructionSet(self)

    def defaultScheduleSet(self) -> "boost::optional< openstudio::model::DefaultScheduleSet >":
        return _openstudiomodelgeometry.Building_defaultScheduleSet(self)

    def setDefaultScheduleSet(self, defaultScheduleSet: "DefaultScheduleSet") -> "bool":
        return _openstudiomodelgeometry.Building_setDefaultScheduleSet(self, defaultScheduleSet)

    def resetDefaultScheduleSet(self) -> "void":
        return _openstudiomodelgeometry.Building_resetDefaultScheduleSet(self)

    def meters(self) -> "std::vector< openstudio::model::OutputMeter,std::allocator< openstudio::model::OutputMeter > >":
        return _openstudiomodelgeometry.Building_meters(self)

    def buildingStories(self) -> "std::vector< openstudio::model::BuildingStory,std::allocator< openstudio::model::BuildingStory > >":
        return _openstudiomodelgeometry.Building_buildingStories(self)

    def facility(self) -> "boost::optional< openstudio::model::Facility >":
        return _openstudiomodelgeometry.Building_facility(self)

    def spaces(self) -> "std::vector< openstudio::model::Space,std::allocator< openstudio::model::Space > >":
        return _openstudiomodelgeometry.Building_spaces(self)

    def shadingSurfaceGroups(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup,std::allocator< openstudio::model::ShadingSurfaceGroup > >":
        return _openstudiomodelgeometry.Building_shadingSurfaceGroups(self)

    def thermalZones(self) -> "std::vector< openstudio::model::ThermalZone,std::allocator< openstudio::model::ThermalZone > >":
        return _openstudiomodelgeometry.Building_thermalZones(self)

    def exteriorWalls(self) -> "std::vector< openstudio::model::Surface,std::allocator< openstudio::model::Surface > >":
        return _openstudiomodelgeometry.Building_exteriorWalls(self)

    def roofs(self) -> "std::vector< openstudio::model::Surface,std::allocator< openstudio::model::Surface > >":
        return _openstudiomodelgeometry.Building_roofs(self)

    def floorArea(self) -> "double":
        return _openstudiomodelgeometry.Building_floorArea(self)

    def conditionedFloorArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Building_conditionedFloorArea(self)

    def exteriorSurfaceArea(self) -> "double":
        return _openstudiomodelgeometry.Building_exteriorSurfaceArea(self)

    def exteriorWallArea(self) -> "double":
        return _openstudiomodelgeometry.Building_exteriorWallArea(self)

    def airVolume(self) -> "double":
        return _openstudiomodelgeometry.Building_airVolume(self)

    def numberOfPeople(self) -> "double":
        return _openstudiomodelgeometry.Building_numberOfPeople(self)

    def peoplePerFloorArea(self) -> "double":
        return _openstudiomodelgeometry.Building_peoplePerFloorArea(self)

    def floorAreaPerPerson(self) -> "double":
        return _openstudiomodelgeometry.Building_floorAreaPerPerson(self)

    def lightingPower(self) -> "double":
        return _openstudiomodelgeometry.Building_lightingPower(self)

    def lightingPowerPerFloorArea(self) -> "double":
        return _openstudiomodelgeometry.Building_lightingPowerPerFloorArea(self)

    def lightingPowerPerPerson(self) -> "double":
        return _openstudiomodelgeometry.Building_lightingPowerPerPerson(self)

    def electricEquipmentPower(self) -> "double":
        return _openstudiomodelgeometry.Building_electricEquipmentPower(self)

    def electricEquipmentPowerPerFloorArea(self) -> "double":
        return _openstudiomodelgeometry.Building_electricEquipmentPowerPerFloorArea(self)

    def electricEquipmentPowerPerPerson(self) -> "double":
        return _openstudiomodelgeometry.Building_electricEquipmentPowerPerPerson(self)

    def gasEquipmentPower(self) -> "double":
        return _openstudiomodelgeometry.Building_gasEquipmentPower(self)

    def gasEquipmentPowerPerFloorArea(self) -> "double":
        return _openstudiomodelgeometry.Building_gasEquipmentPowerPerFloorArea(self)

    def gasEquipmentPowerPerPerson(self) -> "double":
        return _openstudiomodelgeometry.Building_gasEquipmentPowerPerPerson(self)

    def infiltrationDesignFlowRate(self) -> "double":
        return _openstudiomodelgeometry.Building_infiltrationDesignFlowRate(self)

    def infiltrationDesignFlowPerSpaceFloorArea(self) -> "double":
        return _openstudiomodelgeometry.Building_infiltrationDesignFlowPerSpaceFloorArea(self)

    def infiltrationDesignFlowPerExteriorSurfaceArea(self) -> "double":
        return _openstudiomodelgeometry.Building_infiltrationDesignFlowPerExteriorSurfaceArea(self)

    def infiltrationDesignFlowPerExteriorWallArea(self) -> "double":
        return _openstudiomodelgeometry.Building_infiltrationDesignFlowPerExteriorWallArea(self)

    def infiltrationDesignAirChangesPerHour(self) -> "double":
        return _openstudiomodelgeometry.Building_infiltrationDesignAirChangesPerHour(self)

    def transformation(self) -> "openstudio::Transformation":
        return _openstudiomodelgeometry.Building_transformation(self)

    def generateSkylightPattern(self, skylightToProjectedFloorRatio: "double", desiredWidth: "double", desiredHeight: "double") -> "std::vector< std::vector< openstudio::Point3d,std::allocator< openstudio::Point3d > >,std::allocator< std::vector< openstudio::Point3d,std::allocator< openstudio::Point3d > > > >":
        return _openstudiomodelgeometry.Building_generateSkylightPattern(self, skylightToProjectedFloorRatio, desiredWidth, desiredHeight)

# Register Building in _openstudiomodelgeometry:
_openstudiomodelgeometry.Building_swigregister(Building)

def Building_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.Building_iddObjectType()


def toBuilding(idfObject: "IdfObject") -> "boost::optional< openstudio::model::Building >":
    return _openstudiomodelgeometry.toBuilding(idfObject)

def getBuilding(t_model: "Model") -> "openstudio::model::Building":
    return _openstudiomodelgeometry.getBuilding(t_model)

def getOptionalBuilding(t_model: "Model") -> "boost::optional< openstudio::model::Building >":
    return _openstudiomodelgeometry.getOptionalBuilding(t_model)

def _to_Building(self) -> OptionalBuilding:
    return toBuilding(self)
openstudioutilitiesidf.IdfObject.to_Building = _to_Building

def _getBuilding(self) -> Building:
    return getBuilding(self)
Model.getBuilding = _getBuilding

def _getOptionalBuilding(self) -> OptionalBuilding:
    return getOptionalBuilding(self)
Model.getOptionalBuilding = _getOptionalBuilding

class BuildingStory(openstudiomodelcore.ModelObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, model: "Model"):
        _openstudiomodelgeometry.BuildingStory_swiginit(self, _openstudiomodelgeometry.new_BuildingStory(model))
    __swig_destroy__ = _openstudiomodelgeometry.delete_BuildingStory

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.BuildingStory_iddObjectType()

    def nominalZCoordinate(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.BuildingStory_nominalZCoordinate(self)

    def nominalFloortoFloorHeight(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.BuildingStory_nominalFloortoFloorHeight(self)

    def nominalFloortoCeilingHeight(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.BuildingStory_nominalFloortoCeilingHeight(self)

    def boundingBoxBuildingCoordinates(self) -> "openstudio::BoundingBox":
        return _openstudiomodelgeometry.BuildingStory_boundingBoxBuildingCoordinates(self)

    def boundingBoxSiteCoordinates(self) -> "openstudio::BoundingBox":
        return _openstudiomodelgeometry.BuildingStory_boundingBoxSiteCoordinates(self)

    def setNominalZCoordinate(self, nominalZCoordinate: "double") -> "bool":
        return _openstudiomodelgeometry.BuildingStory_setNominalZCoordinate(self, nominalZCoordinate)

    def resetNominalZCoordinate(self) -> "void":
        return _openstudiomodelgeometry.BuildingStory_resetNominalZCoordinate(self)

    def setNominalFloortoFloorHeight(self, nominalFloortoFloorHeight: "double") -> "bool":
        return _openstudiomodelgeometry.BuildingStory_setNominalFloortoFloorHeight(self, nominalFloortoFloorHeight)

    def resetNominalFloortoFloorHeight(self) -> "void":
        return _openstudiomodelgeometry.BuildingStory_resetNominalFloortoFloorHeight(self)

    def setNominalFloortoCeilingHeight(self, nominalFloortoCeilingHeight: "double") -> "bool":
        return _openstudiomodelgeometry.BuildingStory_setNominalFloortoCeilingHeight(self, nominalFloortoCeilingHeight)

    def resetNominalFloortoCeilingHeight(self) -> "void":
        return _openstudiomodelgeometry.BuildingStory_resetNominalFloortoCeilingHeight(self)

    def spaces(self) -> "std::vector< openstudio::model::Space,std::allocator< openstudio::model::Space > >":
        return _openstudiomodelgeometry.BuildingStory_spaces(self)

    def defaultConstructionSet(self) -> "boost::optional< openstudio::model::DefaultConstructionSet >":
        return _openstudiomodelgeometry.BuildingStory_defaultConstructionSet(self)

    def setDefaultConstructionSet(self, defaultConstructionSet: "DefaultConstructionSet") -> "bool":
        return _openstudiomodelgeometry.BuildingStory_setDefaultConstructionSet(self, defaultConstructionSet)

    def resetDefaultConstructionSet(self) -> "void":
        return _openstudiomodelgeometry.BuildingStory_resetDefaultConstructionSet(self)

    def defaultScheduleSet(self) -> "boost::optional< openstudio::model::DefaultScheduleSet >":
        return _openstudiomodelgeometry.BuildingStory_defaultScheduleSet(self)

    def setDefaultScheduleSet(self, defaultScheduleSet: "DefaultScheduleSet") -> "bool":
        return _openstudiomodelgeometry.BuildingStory_setDefaultScheduleSet(self, defaultScheduleSet)

    def resetDefaultScheduleSet(self) -> "void":
        return _openstudiomodelgeometry.BuildingStory_resetDefaultScheduleSet(self)

    def getDefaultSchedule(self, defaultScheduleType: "DefaultScheduleType") -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.BuildingStory_getDefaultSchedule(self, defaultScheduleType)

    def renderingColor(self) -> "boost::optional< openstudio::model::RenderingColor >":
        return _openstudiomodelgeometry.BuildingStory_renderingColor(self)

    def setRenderingColor(self, renderingColor: "RenderingColor") -> "bool":
        return _openstudiomodelgeometry.BuildingStory_setRenderingColor(self, renderingColor)

    def resetRenderingColor(self) -> "void":
        return _openstudiomodelgeometry.BuildingStory_resetRenderingColor(self)

# Register BuildingStory in _openstudiomodelgeometry:
_openstudiomodelgeometry.BuildingStory_swigregister(BuildingStory)

def BuildingStory_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.BuildingStory_iddObjectType()


def toBuildingStory(idfObject: "IdfObject") -> "boost::optional< openstudio::model::BuildingStory >":
    return _openstudiomodelgeometry.toBuildingStory(idfObject)

def getBuildingStory(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::BuildingStory >":
    return _openstudiomodelgeometry.getBuildingStory(t_model, t_handle)

def getBuildingStorys(t_model: "Model") -> "std::vector< openstudio::model::BuildingStory,std::allocator< openstudio::model::BuildingStory > >":
    return _openstudiomodelgeometry.getBuildingStorys(t_model)

def getBuildingStoryByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::BuildingStory >":
    return _openstudiomodelgeometry.getBuildingStoryByName(t_model, t_name)

def getBuildingStorysByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::BuildingStory,std::allocator< openstudio::model::BuildingStory > >":
    return _openstudiomodelgeometry.getBuildingStorysByName(t_model, t_name, t_exactMatch)

def _to_BuildingStory(self) -> OptionalBuildingStory:
    return toBuildingStory(self)
openstudioutilitiesidf.IdfObject.to_BuildingStory = _to_BuildingStory

def _getBuildingStory(self, t_handle: "UUID") -> OptionalBuildingStory:
    return getBuildingStory(self, t_handle)
Model.getBuildingStory = _getBuildingStory

def _getBuildingStory(self, t_handle_str: str) -> OptionalBuildingStory:
    return getBuildingStory(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getBuildingStory = _getBuildingStory

def _getBuildingStorys(self) -> BuildingStoryVector:
    return getBuildingStorys(self)
Model.getBuildingStorys = _getBuildingStorys

def _getBuildingStoryByName(self, t_name: str) -> OptionalBuildingStory:
    return getBuildingStoryByName(self, t_name)
Model.getBuildingStoryByName = _getBuildingStoryByName

def _getBuildingStorysByName(self, t_name: str, t_exactMatch: bool) -> BuildingStoryVector:
    return getBuildingStorysByName(self, t_name, t_exactMatch)
Model.getBuildingStorysByName = _getBuildingStorysByName

class BuildingUnit(openstudiomodelcore.ModelObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, model: "Model"):
        _openstudiomodelgeometry.BuildingUnit_swiginit(self, _openstudiomodelgeometry.new_BuildingUnit(model))
    __swig_destroy__ = _openstudiomodelgeometry.delete_BuildingUnit

    @staticmethod
    def buildingUnitTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.BuildingUnit_buildingUnitTypeValues()

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.BuildingUnit_iddObjectType()

    def renderingColor(self) -> "boost::optional< openstudio::model::RenderingColor >":
        return _openstudiomodelgeometry.BuildingUnit_renderingColor(self)

    def buildingUnitType(self) -> "std::string":
        return _openstudiomodelgeometry.BuildingUnit_buildingUnitType(self)

    def spaces(self) -> "std::vector< openstudio::model::Space,std::allocator< openstudio::model::Space > >":
        return _openstudiomodelgeometry.BuildingUnit_spaces(self)

    def featureNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.BuildingUnit_featureNames(self)

    def getFeatureDataType(self, name: "std::string const &") -> "boost::optional< std::string >":
        return _openstudiomodelgeometry.BuildingUnit_getFeatureDataType(self, name)

    def getFeatureAsString(self, name: "std::string const &") -> "boost::optional< std::string >":
        return _openstudiomodelgeometry.BuildingUnit_getFeatureAsString(self, name)

    def getFeatureAsDouble(self, name: "std::string const &") -> "boost::optional< double >":
        return _openstudiomodelgeometry.BuildingUnit_getFeatureAsDouble(self, name)

    def getFeatureAsInteger(self, name: "std::string const &") -> "boost::optional< int >":
        return _openstudiomodelgeometry.BuildingUnit_getFeatureAsInteger(self, name)

    def getFeatureAsBoolean(self, name: "std::string const &") -> "boost::optional< bool >":
        return _openstudiomodelgeometry.BuildingUnit_getFeatureAsBoolean(self, name)

    def suggestedFeatures(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.BuildingUnit_suggestedFeatures(self)

    def floorArea(self) -> "double":
        return _openstudiomodelgeometry.BuildingUnit_floorArea(self)

    def setRenderingColor(self, renderingColor: "RenderingColor") -> "bool":
        return _openstudiomodelgeometry.BuildingUnit_setRenderingColor(self, renderingColor)

    def resetRenderingColor(self) -> "void":
        return _openstudiomodelgeometry.BuildingUnit_resetRenderingColor(self)

    def setBuildingUnitType(self, buildingUnitType: "std::string const &") -> "bool":
        return _openstudiomodelgeometry.BuildingUnit_setBuildingUnitType(self, buildingUnitType)

    def resetBuildingUnitType(self) -> "void":
        return _openstudiomodelgeometry.BuildingUnit_resetBuildingUnitType(self)

    def setFeature(self, *args) -> "bool":
        return _openstudiomodelgeometry.BuildingUnit_setFeature(self, *args)

    def resetFeature(self, name: "std::string const &") -> "bool":
        return _openstudiomodelgeometry.BuildingUnit_resetFeature(self, name)

# Register BuildingUnit in _openstudiomodelgeometry:
_openstudiomodelgeometry.BuildingUnit_swigregister(BuildingUnit)

def BuildingUnit_buildingUnitTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.BuildingUnit_buildingUnitTypeValues()

def BuildingUnit_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.BuildingUnit_iddObjectType()


def toBuildingUnit(idfObject: "IdfObject") -> "boost::optional< openstudio::model::BuildingUnit >":
    return _openstudiomodelgeometry.toBuildingUnit(idfObject)

def getBuildingUnit(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::BuildingUnit >":
    return _openstudiomodelgeometry.getBuildingUnit(t_model, t_handle)

def getBuildingUnits(t_model: "Model") -> "std::vector< openstudio::model::BuildingUnit,std::allocator< openstudio::model::BuildingUnit > >":
    return _openstudiomodelgeometry.getBuildingUnits(t_model)

def getBuildingUnitByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::BuildingUnit >":
    return _openstudiomodelgeometry.getBuildingUnitByName(t_model, t_name)

def getBuildingUnitsByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::BuildingUnit,std::allocator< openstudio::model::BuildingUnit > >":
    return _openstudiomodelgeometry.getBuildingUnitsByName(t_model, t_name, t_exactMatch)

def _to_BuildingUnit(self) -> OptionalBuildingUnit:
    return toBuildingUnit(self)
openstudioutilitiesidf.IdfObject.to_BuildingUnit = _to_BuildingUnit

def _getBuildingUnit(self, t_handle: "UUID") -> OptionalBuildingUnit:
    return getBuildingUnit(self, t_handle)
Model.getBuildingUnit = _getBuildingUnit

def _getBuildingUnit(self, t_handle_str: str) -> OptionalBuildingUnit:
    return getBuildingUnit(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getBuildingUnit = _getBuildingUnit

def _getBuildingUnits(self) -> BuildingUnitVector:
    return getBuildingUnits(self)
Model.getBuildingUnits = _getBuildingUnits

def _getBuildingUnitByName(self, t_name: str) -> OptionalBuildingUnit:
    return getBuildingUnitByName(self, t_name)
Model.getBuildingUnitByName = _getBuildingUnitByName

def _getBuildingUnitsByName(self, t_name: str, t_exactMatch: bool) -> BuildingUnitVector:
    return getBuildingUnitsByName(self, t_name, t_exactMatch)
Model.getBuildingUnitsByName = _getBuildingUnitsByName

class PlanarSurfaceGroup(openstudiomodelcore.ParentObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomodelgeometry.delete_PlanarSurfaceGroup

    def directionofRelativeNorth(self) -> "double":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_directionofRelativeNorth(self)

    def isDirectionofRelativeNorthDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_isDirectionofRelativeNorthDefaulted(self)

    def xOrigin(self) -> "double":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_xOrigin(self)

    def isXOriginDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_isXOriginDefaulted(self)

    def yOrigin(self) -> "double":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_yOrigin(self)

    def isYOriginDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_isYOriginDefaulted(self)

    def zOrigin(self) -> "double":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_zOrigin(self)

    def isZOriginDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_isZOriginDefaulted(self)

    def setDirectionofRelativeNorth(self, directionofRelativeNorth: "double") -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_setDirectionofRelativeNorth(self, directionofRelativeNorth)

    def resetDirectionofRelativeNorth(self) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_resetDirectionofRelativeNorth(self)

    def setXOrigin(self, xOrigin: "double") -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_setXOrigin(self, xOrigin)

    def resetXOrigin(self) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_resetXOrigin(self)

    def setYOrigin(self, yOrigin: "double") -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_setYOrigin(self, yOrigin)

    def resetYOrigin(self) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_resetYOrigin(self)

    def setZOrigin(self, zOrigin: "double") -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_setZOrigin(self, zOrigin)

    def resetZOrigin(self) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_resetZOrigin(self)

    def transformation(self) -> "openstudio::Transformation":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_transformation(self)

    def buildingTransformation(self) -> "openstudio::Transformation":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_buildingTransformation(self)

    def siteTransformation(self) -> "openstudio::Transformation":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_siteTransformation(self)

    def setTransformation(self, transformation: "Transformation") -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_setTransformation(self, transformation)

    def changeTransformation(self, transformation: "Transformation") -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_changeTransformation(self, transformation)

    def boundingBox(self) -> "openstudio::BoundingBox":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_boundingBox(self)

    def boundingBoxParentCoordinates(self) -> "openstudio::BoundingBox":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_boundingBoxParentCoordinates(self)

    def boundingBoxBuildingCoordinates(self) -> "openstudio::BoundingBox":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_boundingBoxBuildingCoordinates(self)

    def boundingBoxSiteCoordinates(self) -> "openstudio::BoundingBox":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_boundingBoxSiteCoordinates(self)

# Register PlanarSurfaceGroup in _openstudiomodelgeometry:
_openstudiomodelgeometry.PlanarSurfaceGroup_swigregister(PlanarSurfaceGroup)


def toPlanarSurfaceGroup(idfObject: "IdfObject") -> "boost::optional< openstudio::model::PlanarSurfaceGroup >":
    return _openstudiomodelgeometry.toPlanarSurfaceGroup(idfObject)

def getPlanarSurfaceGroup(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::PlanarSurfaceGroup >":
    return _openstudiomodelgeometry.getPlanarSurfaceGroup(t_model, t_handle)

def getPlanarSurfaceGroups(t_model: "Model") -> "std::vector< openstudio::model::PlanarSurfaceGroup,std::allocator< openstudio::model::PlanarSurfaceGroup > >":
    return _openstudiomodelgeometry.getPlanarSurfaceGroups(t_model)

def getPlanarSurfaceGroupByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::PlanarSurfaceGroup >":
    return _openstudiomodelgeometry.getPlanarSurfaceGroupByName(t_model, t_name)

def getPlanarSurfaceGroupsByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::PlanarSurfaceGroup,std::allocator< openstudio::model::PlanarSurfaceGroup > >":
    return _openstudiomodelgeometry.getPlanarSurfaceGroupsByName(t_model, t_name, t_exactMatch)

def _to_PlanarSurfaceGroup(self) -> OptionalPlanarSurfaceGroup:
    return toPlanarSurfaceGroup(self)
openstudioutilitiesidf.IdfObject.to_PlanarSurfaceGroup = _to_PlanarSurfaceGroup

def _getPlanarSurfaceGroup(self, t_handle: "UUID") -> OptionalPlanarSurfaceGroup:
    return getPlanarSurfaceGroup(self, t_handle)
Model.getPlanarSurfaceGroup = _getPlanarSurfaceGroup

def _getPlanarSurfaceGroup(self, t_handle_str: str) -> OptionalPlanarSurfaceGroup:
    return getPlanarSurfaceGroup(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getPlanarSurfaceGroup = _getPlanarSurfaceGroup

def _getPlanarSurfaceGroups(self) -> PlanarSurfaceGroupVector:
    return getPlanarSurfaceGroups(self)
Model.getPlanarSurfaceGroups = _getPlanarSurfaceGroups

def _getPlanarSurfaceGroupByName(self, t_name: str) -> OptionalPlanarSurfaceGroup:
    return getPlanarSurfaceGroupByName(self, t_name)
Model.getPlanarSurfaceGroupByName = _getPlanarSurfaceGroupByName

def _getPlanarSurfaceGroupsByName(self, t_name: str, t_exactMatch: bool) -> PlanarSurfaceGroupVector:
    return getPlanarSurfaceGroupsByName(self, t_name, t_exactMatch)
Model.getPlanarSurfaceGroupsByName = _getPlanarSurfaceGroupsByName

class Space(PlanarSurfaceGroup):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, model: "Model"):
        _openstudiomodelgeometry.Space_swiginit(self, _openstudiomodelgeometry.new_Space(model))
    __swig_destroy__ = _openstudiomodelgeometry.delete_Space

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.Space_iddObjectType()

    @staticmethod
    def fromFloorPrint(floorPrint: "Point3dVector", floorHeight: "double", model: "Model") -> "boost::optional< openstudio::model::Space >":
        return _openstudiomodelgeometry.Space_fromFloorPrint(floorPrint, floorHeight, model)

    def partofTotalFloorArea(self) -> "bool":
        return _openstudiomodelgeometry.Space_partofTotalFloorArea(self)

    def isPartofTotalFloorAreaDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Space_isPartofTotalFloorAreaDefaulted(self)

    def setPartofTotalFloorArea(self, partofTotalFloorArea: "bool") -> "bool":
        return _openstudiomodelgeometry.Space_setPartofTotalFloorArea(self, partofTotalFloorArea)

    def resetPartofTotalFloorArea(self) -> "void":
        return _openstudiomodelgeometry.Space_resetPartofTotalFloorArea(self)

    def spaceType(self) -> "boost::optional< openstudio::model::SpaceType >":
        return _openstudiomodelgeometry.Space_spaceType(self)

    def isSpaceTypeDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Space_isSpaceTypeDefaulted(self)

    def setSpaceType(self, spaceType: "SpaceType") -> "bool":
        return _openstudiomodelgeometry.Space_setSpaceType(self, spaceType)

    def resetSpaceType(self) -> "void":
        return _openstudiomodelgeometry.Space_resetSpaceType(self)

    def defaultConstructionSet(self) -> "boost::optional< openstudio::model::DefaultConstructionSet >":
        return _openstudiomodelgeometry.Space_defaultConstructionSet(self)

    def getDefaultConstruction(self, planarSurface: "PlanarSurface") -> "boost::optional< openstudio::model::ConstructionBase >":
        return _openstudiomodelgeometry.Space_getDefaultConstruction(self, planarSurface)

    def setDefaultConstructionSet(self, defaultConstructionSet: "DefaultConstructionSet") -> "bool":
        return _openstudiomodelgeometry.Space_setDefaultConstructionSet(self, defaultConstructionSet)

    def resetDefaultConstructionSet(self) -> "void":
        return _openstudiomodelgeometry.Space_resetDefaultConstructionSet(self)

    def defaultScheduleSet(self) -> "boost::optional< openstudio::model::DefaultScheduleSet >":
        return _openstudiomodelgeometry.Space_defaultScheduleSet(self)

    def getDefaultSchedule(self, defaultScheduleType: "DefaultScheduleType") -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.Space_getDefaultSchedule(self, defaultScheduleType)

    def setDefaultScheduleSet(self, defaultScheduleSet: "DefaultScheduleSet") -> "bool":
        return _openstudiomodelgeometry.Space_setDefaultScheduleSet(self, defaultScheduleSet)

    def resetDefaultScheduleSet(self) -> "void":
        return _openstudiomodelgeometry.Space_resetDefaultScheduleSet(self)

    def thermalZone(self) -> "boost::optional< openstudio::model::ThermalZone >":
        return _openstudiomodelgeometry.Space_thermalZone(self)

    def setThermalZone(self, thermalZone: "openstudio::model::ThermalZone &") -> "bool":
        return _openstudiomodelgeometry.Space_setThermalZone(self, thermalZone)

    def resetThermalZone(self) -> "void":
        return _openstudiomodelgeometry.Space_resetThermalZone(self)

    def buildingStory(self) -> "boost::optional< openstudio::model::BuildingStory >":
        return _openstudiomodelgeometry.Space_buildingStory(self)

    def setBuildingStory(self, buildingStory: "BuildingStory") -> "bool":
        return _openstudiomodelgeometry.Space_setBuildingStory(self, buildingStory)

    def resetBuildingStory(self) -> "void":
        return _openstudiomodelgeometry.Space_resetBuildingStory(self)

    def buildingUnit(self) -> "boost::optional< openstudio::model::BuildingUnit >":
        return _openstudiomodelgeometry.Space_buildingUnit(self)

    def setBuildingUnit(self, buildingUnit: "BuildingUnit") -> "bool":
        return _openstudiomodelgeometry.Space_setBuildingUnit(self, buildingUnit)

    def resetBuildingUnit(self) -> "void":
        return _openstudiomodelgeometry.Space_resetBuildingUnit(self)

    def shadingSurfaceGroups(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup,std::allocator< openstudio::model::ShadingSurfaceGroup > >":
        return _openstudiomodelgeometry.Space_shadingSurfaceGroups(self)

    def interiorPartitionSurfaceGroups(self) -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup,std::allocator< openstudio::model::InteriorPartitionSurfaceGroup > >":
        return _openstudiomodelgeometry.Space_interiorPartitionSurfaceGroups(self)

    def surfaces(self) -> "std::vector< openstudio::model::Surface,std::allocator< openstudio::model::Surface > >":
        return _openstudiomodelgeometry.Space_surfaces(self)

    def internalMass(self) -> "std::vector< openstudio::model::InternalMass,std::allocator< openstudio::model::InternalMass > >":
        return _openstudiomodelgeometry.Space_internalMass(self)

    def people(self) -> "std::vector< openstudio::model::People,std::allocator< openstudio::model::People > >":
        return _openstudiomodelgeometry.Space_people(self)

    def lights(self) -> "std::vector< openstudio::model::Lights,std::allocator< openstudio::model::Lights > >":
        return _openstudiomodelgeometry.Space_lights(self)

    def luminaires(self) -> "std::vector< openstudio::model::Luminaire,std::allocator< openstudio::model::Luminaire > >":
        return _openstudiomodelgeometry.Space_luminaires(self)

    def electricEquipment(self) -> "std::vector< openstudio::model::ElectricEquipment,std::allocator< openstudio::model::ElectricEquipment > >":
        return _openstudiomodelgeometry.Space_electricEquipment(self)

    def electricEquipmentITEAirCooled(self) -> "std::vector< openstudio::model::ElectricEquipmentITEAirCooled,std::allocator< openstudio::model::ElectricEquipmentITEAirCooled > >":
        return _openstudiomodelgeometry.Space_electricEquipmentITEAirCooled(self)

    def gasEquipment(self) -> "std::vector< openstudio::model::GasEquipment,std::allocator< openstudio::model::GasEquipment > >":
        return _openstudiomodelgeometry.Space_gasEquipment(self)

    def hotWaterEquipment(self) -> "std::vector< openstudio::model::HotWaterEquipment,std::allocator< openstudio::model::HotWaterEquipment > >":
        return _openstudiomodelgeometry.Space_hotWaterEquipment(self)

    def steamEquipment(self) -> "std::vector< openstudio::model::SteamEquipment,std::allocator< openstudio::model::SteamEquipment > >":
        return _openstudiomodelgeometry.Space_steamEquipment(self)

    def otherEquipment(self) -> "std::vector< openstudio::model::OtherEquipment,std::allocator< openstudio::model::OtherEquipment > >":
        return _openstudiomodelgeometry.Space_otherEquipment(self)

    def waterUseEquipment(self) -> "std::vector< openstudio::model::WaterUseEquipment,std::allocator< openstudio::model::WaterUseEquipment > >":
        return _openstudiomodelgeometry.Space_waterUseEquipment(self)

    def daylightingControls(self) -> "std::vector< openstudio::model::DaylightingControl,std::allocator< openstudio::model::DaylightingControl > >":
        return _openstudiomodelgeometry.Space_daylightingControls(self)

    def illuminanceMaps(self) -> "std::vector< openstudio::model::IlluminanceMap,std::allocator< openstudio::model::IlluminanceMap > >":
        return _openstudiomodelgeometry.Space_illuminanceMaps(self)

    def glareSensors(self) -> "std::vector< openstudio::model::GlareSensor,std::allocator< openstudio::model::GlareSensor > >":
        return _openstudiomodelgeometry.Space_glareSensors(self)

    def spaceInfiltrationDesignFlowRates(self) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate,std::allocator< openstudio::model::SpaceInfiltrationDesignFlowRate > >":
        return _openstudiomodelgeometry.Space_spaceInfiltrationDesignFlowRates(self)

    def spaceInfiltrationEffectiveLeakageAreas(self) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea,std::allocator< openstudio::model::SpaceInfiltrationEffectiveLeakageArea > >":
        return _openstudiomodelgeometry.Space_spaceInfiltrationEffectiveLeakageAreas(self)

    def designSpecificationOutdoorAir(self) -> "boost::optional< openstudio::model::DesignSpecificationOutdoorAir >":
        return _openstudiomodelgeometry.Space_designSpecificationOutdoorAir(self)

    def isDesignSpecificationOutdoorAirDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Space_isDesignSpecificationOutdoorAirDefaulted(self)

    def setDesignSpecificationOutdoorAir(self, designSpecificationOutdoorAir: "DesignSpecificationOutdoorAir") -> "bool":
        return _openstudiomodelgeometry.Space_setDesignSpecificationOutdoorAir(self, designSpecificationOutdoorAir)

    def resetDesignSpecificationOutdoorAir(self) -> "void":
        return _openstudiomodelgeometry.Space_resetDesignSpecificationOutdoorAir(self)

    def multiplier(self) -> "int":
        return _openstudiomodelgeometry.Space_multiplier(self)

    def floorArea(self) -> "double":
        return _openstudiomodelgeometry.Space_floorArea(self)

    def exteriorArea(self) -> "double":
        return _openstudiomodelgeometry.Space_exteriorArea(self)

    def exteriorWallArea(self) -> "double":
        return _openstudiomodelgeometry.Space_exteriorWallArea(self)

    def volume(self) -> "double":
        return _openstudiomodelgeometry.Space_volume(self)

    def numberOfPeople(self) -> "double":
        return _openstudiomodelgeometry.Space_numberOfPeople(self)

    def setNumberOfPeople(self, *args) -> "bool":
        return _openstudiomodelgeometry.Space_setNumberOfPeople(self, *args)

    def peoplePerFloorArea(self) -> "double":
        return _openstudiomodelgeometry.Space_peoplePerFloorArea(self)

    def setPeoplePerFloorArea(self, *args) -> "bool":
        return _openstudiomodelgeometry.Space_setPeoplePerFloorArea(self, *args)

    def floorAreaPerPerson(self) -> "double":
        return _openstudiomodelgeometry.Space_floorAreaPerPerson(self)

    def setFloorAreaPerPerson(self, *args) -> "bool":
        return _openstudiomodelgeometry.Space_setFloorAreaPerPerson(self, *args)

    def lightingPower(self) -> "double":
        return _openstudiomodelgeometry.Space_lightingPower(self)

    def setLightingPower(self, *args) -> "bool":
        return _openstudiomodelgeometry.Space_setLightingPower(self, *args)

    def lightingPowerPerFloorArea(self) -> "double":
        return _openstudiomodelgeometry.Space_lightingPowerPerFloorArea(self)

    def setLightingPowerPerFloorArea(self, *args) -> "bool":
        return _openstudiomodelgeometry.Space_setLightingPowerPerFloorArea(self, *args)

    def lightingPowerPerPerson(self) -> "double":
        return _openstudiomodelgeometry.Space_lightingPowerPerPerson(self)

    def setLightingPowerPerPerson(self, *args) -> "bool":
        return _openstudiomodelgeometry.Space_setLightingPowerPerPerson(self, *args)

    def electricEquipmentPower(self) -> "double":
        return _openstudiomodelgeometry.Space_electricEquipmentPower(self)

    def setElectricEquipmentPower(self, *args) -> "bool":
        return _openstudiomodelgeometry.Space_setElectricEquipmentPower(self, *args)

    def electricEquipmentPowerPerFloorArea(self) -> "double":
        return _openstudiomodelgeometry.Space_electricEquipmentPowerPerFloorArea(self)

    def setElectricEquipmentPowerPerFloorArea(self, *args) -> "bool":
        return _openstudiomodelgeometry.Space_setElectricEquipmentPowerPerFloorArea(self, *args)

    def electricEquipmentPowerPerPerson(self) -> "double":
        return _openstudiomodelgeometry.Space_electricEquipmentPowerPerPerson(self)

    def setElectricEquipmentPowerPerPerson(self, *args) -> "bool":
        return _openstudiomodelgeometry.Space_setElectricEquipmentPowerPerPerson(self, *args)

    def electricEquipmentITEAirCooledPower(self) -> "double":
        return _openstudiomodelgeometry.Space_electricEquipmentITEAirCooledPower(self)

    def electricEquipmentITEAirCooledPowerPerFloorArea(self) -> "double":
        return _openstudiomodelgeometry.Space_electricEquipmentITEAirCooledPowerPerFloorArea(self)

    def gasEquipmentPower(self) -> "double":
        return _openstudiomodelgeometry.Space_gasEquipmentPower(self)

    def setGasEquipmentPower(self, *args) -> "bool":
        return _openstudiomodelgeometry.Space_setGasEquipmentPower(self, *args)

    def gasEquipmentPowerPerFloorArea(self) -> "double":
        return _openstudiomodelgeometry.Space_gasEquipmentPowerPerFloorArea(self)

    def setGasEquipmentPowerPerFloorArea(self, *args) -> "bool":
        return _openstudiomodelgeometry.Space_setGasEquipmentPowerPerFloorArea(self, *args)

    def gasEquipmentPowerPerPerson(self) -> "double":
        return _openstudiomodelgeometry.Space_gasEquipmentPowerPerPerson(self)

    def setGasEquipmentPowerPerPerson(self, *args) -> "bool":
        return _openstudiomodelgeometry.Space_setGasEquipmentPowerPerPerson(self, *args)

    def infiltrationDesignFlowRate(self) -> "double":
        return _openstudiomodelgeometry.Space_infiltrationDesignFlowRate(self)

    def infiltrationDesignFlowPerSpaceFloorArea(self) -> "double":
        return _openstudiomodelgeometry.Space_infiltrationDesignFlowPerSpaceFloorArea(self)

    def infiltrationDesignFlowPerExteriorSurfaceArea(self) -> "double":
        return _openstudiomodelgeometry.Space_infiltrationDesignFlowPerExteriorSurfaceArea(self)

    def infiltrationDesignFlowPerExteriorWallArea(self) -> "double":
        return _openstudiomodelgeometry.Space_infiltrationDesignFlowPerExteriorWallArea(self)

    def infiltrationDesignAirChangesPerHour(self) -> "double":
        return _openstudiomodelgeometry.Space_infiltrationDesignAirChangesPerHour(self)

    def hardApplySpaceType(self, hardSizeLoads: "bool") -> "void":
        return _openstudiomodelgeometry.Space_hardApplySpaceType(self, hardSizeLoads)

    def hardApplySpaceLoadSchedules(self) -> "void":
        return _openstudiomodelgeometry.Space_hardApplySpaceLoadSchedules(self)

    def hardApplyConstructions(self) -> "void":
        return _openstudiomodelgeometry.Space_hardApplyConstructions(self)

    def unmatchSurfaces(self) -> "void":
        return _openstudiomodelgeometry.Space_unmatchSurfaces(self)

    def matchSurfaces(self, other: "Space") -> "void":
        return _openstudiomodelgeometry.Space_matchSurfaces(self, other)

    def intersectSurfaces(self, other: "Space") -> "void":
        return _openstudiomodelgeometry.Space_intersectSurfaces(self, other)

    def findSurfaces(self, minDegreesFromNorth: "OptionalDouble", maxDegreesFromNorth: "OptionalDouble", minDegreesTilt: "OptionalDouble", maxDegreesTilt: "OptionalDouble", tol: "double"=1) -> "std::vector< openstudio::model::Surface,std::allocator< openstudio::model::Surface > >":
        return _openstudiomodelgeometry.Space_findSurfaces(self, minDegreesFromNorth, maxDegreesFromNorth, minDegreesTilt, maxDegreesTilt, tol)

    def floorPrint(self) -> "std::vector< openstudio::Point3d,std::allocator< openstudio::Point3d > >":
        return _openstudiomodelgeometry.Space_floorPrint(self)

    def isPlenum(self) -> "bool":
        return _openstudiomodelgeometry.Space_isPlenum(self)

# Register Space in _openstudiomodelgeometry:
_openstudiomodelgeometry.Space_swigregister(Space)

def Space_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.Space_iddObjectType()

def Space_fromFloorPrint(floorPrint: "Point3dVector", floorHeight: "double", model: "Model") -> "boost::optional< openstudio::model::Space >":
    return _openstudiomodelgeometry.Space_fromFloorPrint(floorPrint, floorHeight, model)


def intersectSurfaces(spaces: "SpaceVector") -> "void":
    return _openstudiomodelgeometry.intersectSurfaces(spaces)

def matchSurfaces(spaces: "SpaceVector") -> "void":
    return _openstudiomodelgeometry.matchSurfaces(spaces)

def unmatchSurfaces(spaces: "SpaceVector") -> "void":
    return _openstudiomodelgeometry.unmatchSurfaces(spaces)

def generateSkylightPattern(spaces: "SpaceVector", directionOfRelativeNorth: "double", skylightToProjectedFloorRatio: "double", desiredWidth: "double", desiredHeight: "double") -> "std::vector< std::vector< openstudio::Point3d,std::allocator< openstudio::Point3d > >,std::allocator< std::vector< openstudio::Point3d,std::allocator< openstudio::Point3d > > > >":
    return _openstudiomodelgeometry.generateSkylightPattern(spaces, directionOfRelativeNorth, skylightToProjectedFloorRatio, desiredWidth, desiredHeight)

def toSpace(idfObject: "IdfObject") -> "boost::optional< openstudio::model::Space >":
    return _openstudiomodelgeometry.toSpace(idfObject)

def getSpace(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::Space >":
    return _openstudiomodelgeometry.getSpace(t_model, t_handle)

def getSpaces(t_model: "Model") -> "std::vector< openstudio::model::Space,std::allocator< openstudio::model::Space > >":
    return _openstudiomodelgeometry.getSpaces(t_model)

def getSpaceByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::Space >":
    return _openstudiomodelgeometry.getSpaceByName(t_model, t_name)

def getSpacesByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::Space,std::allocator< openstudio::model::Space > >":
    return _openstudiomodelgeometry.getSpacesByName(t_model, t_name, t_exactMatch)

def _to_Space(self) -> OptionalSpace:
    return toSpace(self)
openstudioutilitiesidf.IdfObject.to_Space = _to_Space

def _getSpace(self, t_handle: "UUID") -> OptionalSpace:
    return getSpace(self, t_handle)
Model.getSpace = _getSpace

def _getSpace(self, t_handle_str: str) -> OptionalSpace:
    return getSpace(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getSpace = _getSpace

def _getSpaces(self) -> SpaceVector:
    return getSpaces(self)
Model.getSpaces = _getSpaces

def _getSpaceByName(self, t_name: str) -> OptionalSpace:
    return getSpaceByName(self, t_name)
Model.getSpaceByName = _getSpaceByName

def _getSpacesByName(self, t_name: str, t_exactMatch: bool) -> SpaceVector:
    return getSpacesByName(self, t_name, t_exactMatch)
Model.getSpacesByName = _getSpacesByName

class SpaceItem(openstudiomodelcore.ModelObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomodelgeometry.delete_SpaceItem

    def space(self) -> "boost::optional< openstudio::model::Space >":
        return _openstudiomodelgeometry.SpaceItem_space(self)

    def setSpace(self, space: "Space") -> "bool":
        return _openstudiomodelgeometry.SpaceItem_setSpace(self, space)

    def resetSpace(self) -> "void":
        return _openstudiomodelgeometry.SpaceItem_resetSpace(self)

# Register SpaceItem in _openstudiomodelgeometry:
_openstudiomodelgeometry.SpaceItem_swigregister(SpaceItem)


def toSpaceItem(idfObject: "IdfObject") -> "boost::optional< openstudio::model::SpaceItem >":
    return _openstudiomodelgeometry.toSpaceItem(idfObject)

def getSpaceItem(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::SpaceItem >":
    return _openstudiomodelgeometry.getSpaceItem(t_model, t_handle)

def getSpaceItems(t_model: "Model") -> "std::vector< openstudio::model::SpaceItem,std::allocator< openstudio::model::SpaceItem > >":
    return _openstudiomodelgeometry.getSpaceItems(t_model)

def getSpaceItemByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::SpaceItem >":
    return _openstudiomodelgeometry.getSpaceItemByName(t_model, t_name)

def getSpaceItemsByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::SpaceItem,std::allocator< openstudio::model::SpaceItem > >":
    return _openstudiomodelgeometry.getSpaceItemsByName(t_model, t_name, t_exactMatch)

def _to_SpaceItem(self) -> OptionalSpaceItem:
    return toSpaceItem(self)
openstudioutilitiesidf.IdfObject.to_SpaceItem = _to_SpaceItem

def _getSpaceItem(self, t_handle: "UUID") -> OptionalSpaceItem:
    return getSpaceItem(self, t_handle)
Model.getSpaceItem = _getSpaceItem

def _getSpaceItem(self, t_handle_str: str) -> OptionalSpaceItem:
    return getSpaceItem(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getSpaceItem = _getSpaceItem

def _getSpaceItems(self) -> SpaceItemVector:
    return getSpaceItems(self)
Model.getSpaceItems = _getSpaceItems

def _getSpaceItemByName(self, t_name: str) -> OptionalSpaceItem:
    return getSpaceItemByName(self, t_name)
Model.getSpaceItemByName = _getSpaceItemByName

def _getSpaceItemsByName(self, t_name: str, t_exactMatch: bool) -> SpaceItemVector:
    return getSpaceItemsByName(self, t_name, t_exactMatch)
Model.getSpaceItemsByName = _getSpaceItemsByName

class SpaceLoad(SpaceItem):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomodelgeometry.delete_SpaceLoad

    def spaceType(self) -> "boost::optional< openstudio::model::SpaceType >":
        return _openstudiomodelgeometry.SpaceLoad_spaceType(self)

    def setSpaceType(self, spaceType: "SpaceType") -> "bool":
        return _openstudiomodelgeometry.SpaceLoad_setSpaceType(self, spaceType)

    def resetSpaceType(self) -> "void":
        return _openstudiomodelgeometry.SpaceLoad_resetSpaceType(self)

    def hardSize(self) -> "bool":
        return _openstudiomodelgeometry.SpaceLoad_hardSize(self)

    def hardApplySchedules(self) -> "bool":
        return _openstudiomodelgeometry.SpaceLoad_hardApplySchedules(self)

    def isAbsolute(self) -> "bool":
        return _openstudiomodelgeometry.SpaceLoad_isAbsolute(self)

# Register SpaceLoad in _openstudiomodelgeometry:
_openstudiomodelgeometry.SpaceLoad_swigregister(SpaceLoad)


def toSpaceLoad(idfObject: "IdfObject") -> "boost::optional< openstudio::model::SpaceLoad >":
    return _openstudiomodelgeometry.toSpaceLoad(idfObject)

def getSpaceLoad(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::SpaceLoad >":
    return _openstudiomodelgeometry.getSpaceLoad(t_model, t_handle)

def getSpaceLoads(t_model: "Model") -> "std::vector< openstudio::model::SpaceLoad,std::allocator< openstudio::model::SpaceLoad > >":
    return _openstudiomodelgeometry.getSpaceLoads(t_model)

def getSpaceLoadByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::SpaceLoad >":
    return _openstudiomodelgeometry.getSpaceLoadByName(t_model, t_name)

def getSpaceLoadsByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::SpaceLoad,std::allocator< openstudio::model::SpaceLoad > >":
    return _openstudiomodelgeometry.getSpaceLoadsByName(t_model, t_name, t_exactMatch)

def _to_SpaceLoad(self) -> OptionalSpaceLoad:
    return toSpaceLoad(self)
openstudioutilitiesidf.IdfObject.to_SpaceLoad = _to_SpaceLoad

def _getSpaceLoad(self, t_handle: "UUID") -> OptionalSpaceLoad:
    return getSpaceLoad(self, t_handle)
Model.getSpaceLoad = _getSpaceLoad

def _getSpaceLoad(self, t_handle_str: str) -> OptionalSpaceLoad:
    return getSpaceLoad(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getSpaceLoad = _getSpaceLoad

def _getSpaceLoads(self) -> SpaceLoadVector:
    return getSpaceLoads(self)
Model.getSpaceLoads = _getSpaceLoads

def _getSpaceLoadByName(self, t_name: str) -> OptionalSpaceLoad:
    return getSpaceLoadByName(self, t_name)
Model.getSpaceLoadByName = _getSpaceLoadByName

def _getSpaceLoadsByName(self, t_name: str, t_exactMatch: bool) -> SpaceLoadVector:
    return getSpaceLoadsByName(self, t_name, t_exactMatch)
Model.getSpaceLoadsByName = _getSpaceLoadsByName

class SpaceLoadInstance(SpaceLoad):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomodelgeometry.delete_SpaceLoadInstance

    def definition(self) -> "openstudio::model::SpaceLoadDefinition":
        return _openstudiomodelgeometry.SpaceLoadInstance_definition(self)

    def setDefinition(self, definition: "SpaceLoadDefinition") -> "bool":
        return _openstudiomodelgeometry.SpaceLoadInstance_setDefinition(self, definition)

    def makeUnique(self) -> "void":
        return _openstudiomodelgeometry.SpaceLoadInstance_makeUnique(self)

    def multiplier(self) -> "double":
        return _openstudiomodelgeometry.SpaceLoadInstance_multiplier(self)

    def isMultiplierDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SpaceLoadInstance_isMultiplierDefaulted(self)

    def floorArea(self) -> "double":
        return _openstudiomodelgeometry.SpaceLoadInstance_floorArea(self)

    def quantity(self) -> "int":
        return _openstudiomodelgeometry.SpaceLoadInstance_quantity(self)

# Register SpaceLoadInstance in _openstudiomodelgeometry:
_openstudiomodelgeometry.SpaceLoadInstance_swigregister(SpaceLoadInstance)


def toSpaceLoadInstance(idfObject: "IdfObject") -> "boost::optional< openstudio::model::SpaceLoadInstance >":
    return _openstudiomodelgeometry.toSpaceLoadInstance(idfObject)

def getSpaceLoadInstance(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::SpaceLoadInstance >":
    return _openstudiomodelgeometry.getSpaceLoadInstance(t_model, t_handle)

def getSpaceLoadInstances(t_model: "Model") -> "std::vector< openstudio::model::SpaceLoadInstance,std::allocator< openstudio::model::SpaceLoadInstance > >":
    return _openstudiomodelgeometry.getSpaceLoadInstances(t_model)

def getSpaceLoadInstanceByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::SpaceLoadInstance >":
    return _openstudiomodelgeometry.getSpaceLoadInstanceByName(t_model, t_name)

def getSpaceLoadInstancesByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::SpaceLoadInstance,std::allocator< openstudio::model::SpaceLoadInstance > >":
    return _openstudiomodelgeometry.getSpaceLoadInstancesByName(t_model, t_name, t_exactMatch)

def _to_SpaceLoadInstance(self) -> OptionalSpaceLoadInstance:
    return toSpaceLoadInstance(self)
openstudioutilitiesidf.IdfObject.to_SpaceLoadInstance = _to_SpaceLoadInstance

def _getSpaceLoadInstance(self, t_handle: "UUID") -> OptionalSpaceLoadInstance:
    return getSpaceLoadInstance(self, t_handle)
Model.getSpaceLoadInstance = _getSpaceLoadInstance

def _getSpaceLoadInstance(self, t_handle_str: str) -> OptionalSpaceLoadInstance:
    return getSpaceLoadInstance(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getSpaceLoadInstance = _getSpaceLoadInstance

def _getSpaceLoadInstances(self) -> SpaceLoadInstanceVector:
    return getSpaceLoadInstances(self)
Model.getSpaceLoadInstances = _getSpaceLoadInstances

def _getSpaceLoadInstanceByName(self, t_name: str) -> OptionalSpaceLoadInstance:
    return getSpaceLoadInstanceByName(self, t_name)
Model.getSpaceLoadInstanceByName = _getSpaceLoadInstanceByName

def _getSpaceLoadInstancesByName(self, t_name: str, t_exactMatch: bool) -> SpaceLoadInstanceVector:
    return getSpaceLoadInstancesByName(self, t_name, t_exactMatch)
Model.getSpaceLoadInstancesByName = _getSpaceLoadInstancesByName

class Lights(SpaceLoadInstance):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, lightsDefinition: "LightsDefinition"):
        _openstudiomodelgeometry.Lights_swiginit(self, _openstudiomodelgeometry.new_Lights(lightsDefinition))
    __swig_destroy__ = _openstudiomodelgeometry.delete_Lights

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.Lights_iddObjectType()

    def lightsDefinition(self) -> "openstudio::model::LightsDefinition":
        return _openstudiomodelgeometry.Lights_lightsDefinition(self)

    def schedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.Lights_schedule(self)

    def isScheduleDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Lights_isScheduleDefaulted(self)

    def fractionReplaceable(self) -> "double":
        return _openstudiomodelgeometry.Lights_fractionReplaceable(self)

    def isFractionReplaceableDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Lights_isFractionReplaceableDefaulted(self)

    def endUseSubcategory(self) -> "std::string":
        return _openstudiomodelgeometry.Lights_endUseSubcategory(self)

    def isEndUseSubcategoryDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Lights_isEndUseSubcategoryDefaulted(self)

    def setLightsDefinition(self, definition: "LightsDefinition") -> "bool":
        return _openstudiomodelgeometry.Lights_setLightsDefinition(self, definition)

    def setSchedule(self, schedule: "Schedule") -> "bool":
        return _openstudiomodelgeometry.Lights_setSchedule(self, schedule)

    def resetSchedule(self) -> "void":
        return _openstudiomodelgeometry.Lights_resetSchedule(self)

    def setFractionReplaceable(self, fractionReplaceable: "double") -> "bool":
        return _openstudiomodelgeometry.Lights_setFractionReplaceable(self, fractionReplaceable)

    def resetFractionReplaceable(self) -> "void":
        return _openstudiomodelgeometry.Lights_resetFractionReplaceable(self)

    def setMultiplier(self, multiplier: "double") -> "bool":
        return _openstudiomodelgeometry.Lights_setMultiplier(self, multiplier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.Lights_resetMultiplier(self)

    def setEndUseSubcategory(self, endUseSubcategory: "std::string") -> "bool":
        return _openstudiomodelgeometry.Lights_setEndUseSubcategory(self, endUseSubcategory)

    def resetEndUseSubcategory(self) -> "void":
        return _openstudiomodelgeometry.Lights_resetEndUseSubcategory(self)

    def lightingLevel(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Lights_lightingLevel(self)

    def powerPerFloorArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Lights_powerPerFloorArea(self)

    def powerPerPerson(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Lights_powerPerPerson(self)

    def getLightingPower(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.Lights_getLightingPower(self, floorArea, numPeople)

    def getPowerPerFloorArea(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.Lights_getPowerPerFloorArea(self, floorArea, numPeople)

    def getPowerPerPerson(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.Lights_getPowerPerPerson(self, floorArea, numPeople)

# Register Lights in _openstudiomodelgeometry:
_openstudiomodelgeometry.Lights_swigregister(Lights)

def Lights_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.Lights_iddObjectType()


def toLights(idfObject: "IdfObject") -> "boost::optional< openstudio::model::Lights >":
    return _openstudiomodelgeometry.toLights(idfObject)

def getLights(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::Lights >":
    return _openstudiomodelgeometry.getLights(t_model, t_handle)

def getLightss(t_model: "Model") -> "std::vector< openstudio::model::Lights,std::allocator< openstudio::model::Lights > >":
    return _openstudiomodelgeometry.getLightss(t_model)

def getLightsByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::Lights >":
    return _openstudiomodelgeometry.getLightsByName(t_model, t_name)

def getLightssByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::Lights,std::allocator< openstudio::model::Lights > >":
    return _openstudiomodelgeometry.getLightssByName(t_model, t_name, t_exactMatch)

def _to_Lights(self) -> OptionalLights:
    return toLights(self)
openstudioutilitiesidf.IdfObject.to_Lights = _to_Lights

def _getLights(self, t_handle: "UUID") -> OptionalLights:
    return getLights(self, t_handle)
Model.getLights = _getLights

def _getLights(self, t_handle_str: str) -> OptionalLights:
    return getLights(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getLights = _getLights

def _getLightss(self) -> LightsVector:
    return getLightss(self)
Model.getLightss = _getLightss

def _getLightsByName(self, t_name: str) -> OptionalLights:
    return getLightsByName(self, t_name)
Model.getLightsByName = _getLightsByName

def _getLightssByName(self, t_name: str, t_exactMatch: bool) -> LightsVector:
    return getLightssByName(self, t_name, t_exactMatch)
Model.getLightssByName = _getLightssByName

class FilmResistanceType(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.FilmResistanceType_swiginit(self, _openstudiomodelgeometry.new_FilmResistanceType(*args))

    def valueName(self) -> "std::string":
        return _openstudiomodelgeometry.FilmResistanceType_valueName(self)

    def value(self) -> "int":
        return _openstudiomodelgeometry.FilmResistanceType_value(self)

    def valueDescription(self) -> "std::string":
        return _openstudiomodelgeometry.FilmResistanceType_valueDescription(self)

    def __eq__(self, other: "FilmResistanceType") -> "bool":
        return _openstudiomodelgeometry.FilmResistanceType___eq__(self, other)

    def __ne__(self, other: "FilmResistanceType") -> "bool":
        return _openstudiomodelgeometry.FilmResistanceType___ne__(self, other)

    def __gt__(self, other: "FilmResistanceType") -> "bool":
        return _openstudiomodelgeometry.FilmResistanceType___gt__(self, other)

    def __ge__(self, other: "FilmResistanceType") -> "bool":
        return _openstudiomodelgeometry.FilmResistanceType___ge__(self, other)

    def __lt__(self, other: "FilmResistanceType") -> "bool":
        return _openstudiomodelgeometry.FilmResistanceType___lt__(self, other)

    def __le__(self, other: "FilmResistanceType") -> "bool":
        return _openstudiomodelgeometry.FilmResistanceType___le__(self, other)

    @staticmethod
    def enumName() -> "std::string":
        return _openstudiomodelgeometry.FilmResistanceType_enumName()

    @staticmethod
    def getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
        return _openstudiomodelgeometry.FilmResistanceType_getValues()

    def __str__(self) -> "std::string":
        return _openstudiomodelgeometry.FilmResistanceType___str__(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_FilmResistanceType

# Register FilmResistanceType in _openstudiomodelgeometry:
_openstudiomodelgeometry.FilmResistanceType_swigregister(FilmResistanceType)

def FilmResistanceType_enumName() -> "std::string":
    return _openstudiomodelgeometry.FilmResistanceType_enumName()

def FilmResistanceType_getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
    return _openstudiomodelgeometry.FilmResistanceType_getValues()

class PlanarSurface(openstudiomodelcore.ParentObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomodelgeometry.delete_PlanarSurface

    def construction(self) -> "boost::optional< openstudio::model::ConstructionBase >":
        return _openstudiomodelgeometry.PlanarSurface_construction(self)

    def isConstructionDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.PlanarSurface_isConstructionDefaulted(self)

    def planarSurfaceGroup(self) -> "boost::optional< openstudio::model::PlanarSurfaceGroup >":
        return _openstudiomodelgeometry.PlanarSurface_planarSurfaceGroup(self)

    def space(self) -> "boost::optional< openstudio::model::Space >":
        return _openstudiomodelgeometry.PlanarSurface_space(self)

    def vertices(self) -> "std::vector< openstudio::Point3d,std::allocator< openstudio::Point3d > >":
        return _openstudiomodelgeometry.PlanarSurface_vertices(self)

    def setVertices(self, vertices: "Point3dVector") -> "bool":
        return _openstudiomodelgeometry.PlanarSurface_setVertices(self, vertices)

    def setConstruction(self, construction: "ConstructionBase") -> "bool":
        return _openstudiomodelgeometry.PlanarSurface_setConstruction(self, construction)

    def resetConstruction(self) -> "void":
        return _openstudiomodelgeometry.PlanarSurface_resetConstruction(self)

    @staticmethod
    def findPlanarSurfaces(planarSurfaces: "PlanarSurfaceVector", minDegreesFromNorth: "OptionalDouble", maxDegreesFromNorth: "OptionalDouble", minDegreesTilt: "OptionalDouble", maxDegreesTilt: "OptionalDouble", tol: "double"=1) -> "std::vector< openstudio::model::PlanarSurface,std::allocator< openstudio::model::PlanarSurface > >":
        return _openstudiomodelgeometry.PlanarSurface_findPlanarSurfaces(planarSurfaces, minDegreesFromNorth, maxDegreesFromNorth, minDegreesTilt, maxDegreesTilt, tol)

    @staticmethod
    def filmResistance(type: "FilmResistanceType") -> "double":
        return _openstudiomodelgeometry.PlanarSurface_filmResistance(type)

    @staticmethod
    def stillAirFilmResistance(tilt: "double") -> "double":
        return _openstudiomodelgeometry.PlanarSurface_stillAirFilmResistance(tilt)

    def isAirWall(self) -> "bool":
        return _openstudiomodelgeometry.PlanarSurface_isAirWall(self)

    def grossArea(self) -> "double":
        return _openstudiomodelgeometry.PlanarSurface_grossArea(self)

    def subtractFromGrossArea(self) -> "bool":
        return _openstudiomodelgeometry.PlanarSurface_subtractFromGrossArea(self)

    def netArea(self) -> "double":
        return _openstudiomodelgeometry.PlanarSurface_netArea(self)

    def outwardNormal(self) -> "openstudio::Vector3d":
        return _openstudiomodelgeometry.PlanarSurface_outwardNormal(self)

    def tilt(self) -> "double":
        return _openstudiomodelgeometry.PlanarSurface_tilt(self)

    def azimuth(self) -> "double":
        return _openstudiomodelgeometry.PlanarSurface_azimuth(self)

    def uFactor(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.PlanarSurface_uFactor(self)

    def setUFactor(self, value: "double") -> "bool":
        return _openstudiomodelgeometry.PlanarSurface_setUFactor(self, value)

    def thermalConductance(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.PlanarSurface_thermalConductance(self)

    def setThermalConductance(self, value: "double") -> "bool":
        return _openstudiomodelgeometry.PlanarSurface_setThermalConductance(self, value)

    def heatCapacity(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.PlanarSurface_heatCapacity(self)

    def interiorVisibleAbsorptance(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.PlanarSurface_interiorVisibleAbsorptance(self)

    def interiorVisibleAbsorbtance(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.PlanarSurface_interiorVisibleAbsorbtance(self)

    def exteriorVisibleAbsorptance(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.PlanarSurface_exteriorVisibleAbsorptance(self)

    def exteriorVisibleAbsorbtance(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.PlanarSurface_exteriorVisibleAbsorbtance(self)

    def visibleTransmittance(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.PlanarSurface_visibleTransmittance(self)

    def equalVertices(self, other: "PlanarSurface") -> "bool":
        return _openstudiomodelgeometry.PlanarSurface_equalVertices(self, other)

    def reverseEqualVertices(self, other: "PlanarSurface") -> "bool":
        return _openstudiomodelgeometry.PlanarSurface_reverseEqualVertices(self, other)

    def plane(self) -> "openstudio::Plane":
        return _openstudiomodelgeometry.PlanarSurface_plane(self)

    def triangulation(self) -> "std::vector< std::vector< openstudio::Point3d,std::allocator< openstudio::Point3d > >,std::allocator< std::vector< openstudio::Point3d,std::allocator< openstudio::Point3d > > > >":
        return _openstudiomodelgeometry.PlanarSurface_triangulation(self)

    def centroid(self) -> "openstudio::Point3d":
        return _openstudiomodelgeometry.PlanarSurface_centroid(self)

    def solarCollectors(self) -> "std::vector< openstudio::model::ModelObject,std::allocator< openstudio::model::ModelObject > >":
        return _openstudiomodelgeometry.PlanarSurface_solarCollectors(self)

    def generatorPhotovoltaics(self) -> "std::vector< openstudio::model::GeneratorPhotovoltaic,std::allocator< openstudio::model::GeneratorPhotovoltaic > >":
        return _openstudiomodelgeometry.PlanarSurface_generatorPhotovoltaics(self)

    def surfacePropertyConvectionCoefficients(self) -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients,std::allocator< openstudio::model::SurfacePropertyConvectionCoefficients > >":
        return _openstudiomodelgeometry.PlanarSurface_surfacePropertyConvectionCoefficients(self)

# Register PlanarSurface in _openstudiomodelgeometry:
_openstudiomodelgeometry.PlanarSurface_swigregister(PlanarSurface)

def PlanarSurface_findPlanarSurfaces(planarSurfaces: "PlanarSurfaceVector", minDegreesFromNorth: "OptionalDouble", maxDegreesFromNorth: "OptionalDouble", minDegreesTilt: "OptionalDouble", maxDegreesTilt: "OptionalDouble", tol: "double"=1) -> "std::vector< openstudio::model::PlanarSurface,std::allocator< openstudio::model::PlanarSurface > >":
    return _openstudiomodelgeometry.PlanarSurface_findPlanarSurfaces(planarSurfaces, minDegreesFromNorth, maxDegreesFromNorth, minDegreesTilt, maxDegreesTilt, tol)

def PlanarSurface_filmResistance(type: "FilmResistanceType") -> "double":
    return _openstudiomodelgeometry.PlanarSurface_filmResistance(type)

def PlanarSurface_stillAirFilmResistance(tilt: "double") -> "double":
    return _openstudiomodelgeometry.PlanarSurface_stillAirFilmResistance(tilt)


def toPlanarSurface(idfObject: "IdfObject") -> "boost::optional< openstudio::model::PlanarSurface >":
    return _openstudiomodelgeometry.toPlanarSurface(idfObject)

def getPlanarSurface(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::PlanarSurface >":
    return _openstudiomodelgeometry.getPlanarSurface(t_model, t_handle)

def getPlanarSurfaces(t_model: "Model") -> "std::vector< openstudio::model::PlanarSurface,std::allocator< openstudio::model::PlanarSurface > >":
    return _openstudiomodelgeometry.getPlanarSurfaces(t_model)

def getPlanarSurfaceByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::PlanarSurface >":
    return _openstudiomodelgeometry.getPlanarSurfaceByName(t_model, t_name)

def getPlanarSurfacesByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::PlanarSurface,std::allocator< openstudio::model::PlanarSurface > >":
    return _openstudiomodelgeometry.getPlanarSurfacesByName(t_model, t_name, t_exactMatch)

def _to_PlanarSurface(self) -> OptionalPlanarSurface:
    return toPlanarSurface(self)
openstudioutilitiesidf.IdfObject.to_PlanarSurface = _to_PlanarSurface

def _getPlanarSurface(self, t_handle: "UUID") -> OptionalPlanarSurface:
    return getPlanarSurface(self, t_handle)
Model.getPlanarSurface = _getPlanarSurface

def _getPlanarSurface(self, t_handle_str: str) -> OptionalPlanarSurface:
    return getPlanarSurface(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getPlanarSurface = _getPlanarSurface

def _getPlanarSurfaces(self) -> PlanarSurfaceVector:
    return getPlanarSurfaces(self)
Model.getPlanarSurfaces = _getPlanarSurfaces

def _getPlanarSurfaceByName(self, t_name: str) -> OptionalPlanarSurface:
    return getPlanarSurfaceByName(self, t_name)
Model.getPlanarSurfaceByName = _getPlanarSurfaceByName

def _getPlanarSurfacesByName(self, t_name: str, t_exactMatch: bool) -> PlanarSurfaceVector:
    return getPlanarSurfacesByName(self, t_name, t_exactMatch)
Model.getPlanarSurfacesByName = _getPlanarSurfacesByName

class DefaultConstructionSet(openstudiomodelcore.ResourceObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, model: "Model"):
        _openstudiomodelgeometry.DefaultConstructionSet_swiginit(self, _openstudiomodelgeometry.new_DefaultConstructionSet(model))
    __swig_destroy__ = _openstudiomodelgeometry.delete_DefaultConstructionSet

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.DefaultConstructionSet_iddObjectType()

    def defaultExteriorSurfaceConstructions(self) -> "boost::optional< openstudio::model::DefaultSurfaceConstructions >":
        return _openstudiomodelgeometry.DefaultConstructionSet_defaultExteriorSurfaceConstructions(self)

    def defaultInteriorSurfaceConstructions(self) -> "boost::optional< openstudio::model::DefaultSurfaceConstructions >":
        return _openstudiomodelgeometry.DefaultConstructionSet_defaultInteriorSurfaceConstructions(self)

    def defaultGroundContactSurfaceConstructions(self) -> "boost::optional< openstudio::model::DefaultSurfaceConstructions >":
        return _openstudiomodelgeometry.DefaultConstructionSet_defaultGroundContactSurfaceConstructions(self)

    def defaultExteriorSubSurfaceConstructions(self) -> "boost::optional< openstudio::model::DefaultSubSurfaceConstructions >":
        return _openstudiomodelgeometry.DefaultConstructionSet_defaultExteriorSubSurfaceConstructions(self)

    def defaultInteriorSubSurfaceConstructions(self) -> "boost::optional< openstudio::model::DefaultSubSurfaceConstructions >":
        return _openstudiomodelgeometry.DefaultConstructionSet_defaultInteriorSubSurfaceConstructions(self)

    def interiorPartitionConstruction(self) -> "boost::optional< openstudio::model::ConstructionBase >":
        return _openstudiomodelgeometry.DefaultConstructionSet_interiorPartitionConstruction(self)

    def spaceShadingConstruction(self) -> "boost::optional< openstudio::model::ConstructionBase >":
        return _openstudiomodelgeometry.DefaultConstructionSet_spaceShadingConstruction(self)

    def buildingShadingConstruction(self) -> "boost::optional< openstudio::model::ConstructionBase >":
        return _openstudiomodelgeometry.DefaultConstructionSet_buildingShadingConstruction(self)

    def siteShadingConstruction(self) -> "boost::optional< openstudio::model::ConstructionBase >":
        return _openstudiomodelgeometry.DefaultConstructionSet_siteShadingConstruction(self)

    def adiabaticSurfaceConstruction(self) -> "boost::optional< openstudio::model::ConstructionBase >":
        return _openstudiomodelgeometry.DefaultConstructionSet_adiabaticSurfaceConstruction(self)

    def setDefaultExteriorSurfaceConstructions(self, defaultSurfaceConstructions: "DefaultSurfaceConstructions") -> "bool":
        return _openstudiomodelgeometry.DefaultConstructionSet_setDefaultExteriorSurfaceConstructions(self, defaultSurfaceConstructions)

    def resetDefaultExteriorSurfaceConstructions(self) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSet_resetDefaultExteriorSurfaceConstructions(self)

    def setDefaultInteriorSurfaceConstructions(self, defaultSurfaceConstructions: "DefaultSurfaceConstructions") -> "bool":
        return _openstudiomodelgeometry.DefaultConstructionSet_setDefaultInteriorSurfaceConstructions(self, defaultSurfaceConstructions)

    def resetDefaultInteriorSurfaceConstructions(self) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSet_resetDefaultInteriorSurfaceConstructions(self)

    def setDefaultGroundContactSurfaceConstructions(self, defaultSurfaceConstructions: "DefaultSurfaceConstructions") -> "bool":
        return _openstudiomodelgeometry.DefaultConstructionSet_setDefaultGroundContactSurfaceConstructions(self, defaultSurfaceConstructions)

    def resetDefaultGroundContactSurfaceConstructions(self) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSet_resetDefaultGroundContactSurfaceConstructions(self)

    def setDefaultExteriorSubSurfaceConstructions(self, defaultSubSurfaceConstructions: "DefaultSubSurfaceConstructions") -> "bool":
        return _openstudiomodelgeometry.DefaultConstructionSet_setDefaultExteriorSubSurfaceConstructions(self, defaultSubSurfaceConstructions)

    def resetDefaultExteriorSubSurfaceConstructions(self) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSet_resetDefaultExteriorSubSurfaceConstructions(self)

    def setDefaultInteriorSubSurfaceConstructions(self, defaultSubSurfaceConstructions: "DefaultSubSurfaceConstructions") -> "bool":
        return _openstudiomodelgeometry.DefaultConstructionSet_setDefaultInteriorSubSurfaceConstructions(self, defaultSubSurfaceConstructions)

    def resetDefaultInteriorSubSurfaceConstructions(self) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSet_resetDefaultInteriorSubSurfaceConstructions(self)

    def setInteriorPartitionConstruction(self, construction: "ConstructionBase") -> "bool":
        return _openstudiomodelgeometry.DefaultConstructionSet_setInteriorPartitionConstruction(self, construction)

    def resetInteriorPartitionConstruction(self) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSet_resetInteriorPartitionConstruction(self)

    def setSpaceShadingConstruction(self, construction: "ConstructionBase") -> "bool":
        return _openstudiomodelgeometry.DefaultConstructionSet_setSpaceShadingConstruction(self, construction)

    def resetSpaceShadingConstruction(self) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSet_resetSpaceShadingConstruction(self)

    def setBuildingShadingConstruction(self, construction: "ConstructionBase") -> "bool":
        return _openstudiomodelgeometry.DefaultConstructionSet_setBuildingShadingConstruction(self, construction)

    def resetBuildingShadingConstruction(self) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSet_resetBuildingShadingConstruction(self)

    def setSiteShadingConstruction(self, construction: "ConstructionBase") -> "bool":
        return _openstudiomodelgeometry.DefaultConstructionSet_setSiteShadingConstruction(self, construction)

    def resetSiteShadingConstruction(self) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSet_resetSiteShadingConstruction(self)

    def setAdiabaticSurfaceConstruction(self, construction: "ConstructionBase") -> "bool":
        return _openstudiomodelgeometry.DefaultConstructionSet_setAdiabaticSurfaceConstruction(self, construction)

    def resetAdiabaticSurfaceConstruction(self) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSet_resetAdiabaticSurfaceConstruction(self)

    def getDefaultConstruction(self, planarSurface: "PlanarSurface") -> "boost::optional< openstudio::model::ConstructionBase >":
        return _openstudiomodelgeometry.DefaultConstructionSet_getDefaultConstruction(self, planarSurface)

    def merge(self, other: "DefaultConstructionSet") -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSet_merge(self, other)

# Register DefaultConstructionSet in _openstudiomodelgeometry:
_openstudiomodelgeometry.DefaultConstructionSet_swigregister(DefaultConstructionSet)

def DefaultConstructionSet_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.DefaultConstructionSet_iddObjectType()


def toDefaultConstructionSet(idfObject: "IdfObject") -> "boost::optional< openstudio::model::DefaultConstructionSet >":
    return _openstudiomodelgeometry.toDefaultConstructionSet(idfObject)

def getDefaultConstructionSet(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::DefaultConstructionSet >":
    return _openstudiomodelgeometry.getDefaultConstructionSet(t_model, t_handle)

def getDefaultConstructionSets(t_model: "Model") -> "std::vector< openstudio::model::DefaultConstructionSet,std::allocator< openstudio::model::DefaultConstructionSet > >":
    return _openstudiomodelgeometry.getDefaultConstructionSets(t_model)

def getDefaultConstructionSetByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::DefaultConstructionSet >":
    return _openstudiomodelgeometry.getDefaultConstructionSetByName(t_model, t_name)

def getDefaultConstructionSetsByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::DefaultConstructionSet,std::allocator< openstudio::model::DefaultConstructionSet > >":
    return _openstudiomodelgeometry.getDefaultConstructionSetsByName(t_model, t_name, t_exactMatch)

def _to_DefaultConstructionSet(self) -> OptionalDefaultConstructionSet:
    return toDefaultConstructionSet(self)
openstudioutilitiesidf.IdfObject.to_DefaultConstructionSet = _to_DefaultConstructionSet

def _getDefaultConstructionSet(self, t_handle: "UUID") -> OptionalDefaultConstructionSet:
    return getDefaultConstructionSet(self, t_handle)
Model.getDefaultConstructionSet = _getDefaultConstructionSet

def _getDefaultConstructionSet(self, t_handle_str: str) -> OptionalDefaultConstructionSet:
    return getDefaultConstructionSet(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getDefaultConstructionSet = _getDefaultConstructionSet

def _getDefaultConstructionSets(self) -> DefaultConstructionSetVector:
    return getDefaultConstructionSets(self)
Model.getDefaultConstructionSets = _getDefaultConstructionSets

def _getDefaultConstructionSetByName(self, t_name: str) -> OptionalDefaultConstructionSet:
    return getDefaultConstructionSetByName(self, t_name)
Model.getDefaultConstructionSetByName = _getDefaultConstructionSetByName

def _getDefaultConstructionSetsByName(self, t_name: str, t_exactMatch: bool) -> DefaultConstructionSetVector:
    return getDefaultConstructionSetsByName(self, t_name, t_exactMatch)
Model.getDefaultConstructionSetsByName = _getDefaultConstructionSetsByName

class Surface(PlanarSurface):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, vertices: "Point3dVector", model: "Model"):
        _openstudiomodelgeometry.Surface_swiginit(self, _openstudiomodelgeometry.new_Surface(vertices, model))
    __swig_destroy__ = _openstudiomodelgeometry.delete_Surface

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.Surface_iddObjectType()

    @staticmethod
    def validSurfaceTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.Surface_validSurfaceTypeValues()

    @staticmethod
    def validOutsideBoundaryConditionValues() -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.Surface_validOutsideBoundaryConditionValues()

    @staticmethod
    def validSunExposureValues() -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.Surface_validSunExposureValues()

    @staticmethod
    def validWindExposureValues() -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.Surface_validWindExposureValues()

    def surfaceType(self) -> "std::string":
        return _openstudiomodelgeometry.Surface_surfaceType(self)

    def outsideBoundaryCondition(self) -> "std::string":
        return _openstudiomodelgeometry.Surface_outsideBoundaryCondition(self)

    def isGroundSurface(self) -> "bool":
        return _openstudiomodelgeometry.Surface_isGroundSurface(self)

    def sunExposure(self) -> "std::string":
        return _openstudiomodelgeometry.Surface_sunExposure(self)

    def isSunExposureDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Surface_isSunExposureDefaulted(self)

    def windExposure(self) -> "std::string":
        return _openstudiomodelgeometry.Surface_windExposure(self)

    def isWindExposureDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Surface_isWindExposureDefaulted(self)

    def viewFactortoGround(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Surface_viewFactortoGround(self)

    def isViewFactortoGroundDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Surface_isViewFactortoGroundDefaulted(self)

    def isViewFactortoGroundAutocalculated(self) -> "bool":
        return _openstudiomodelgeometry.Surface_isViewFactortoGroundAutocalculated(self)

    def numberofVertices(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Surface_numberofVertices(self)

    def isNumberofVerticesDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Surface_isNumberofVerticesDefaulted(self)

    def isNumberofVerticesAutocalculated(self) -> "bool":
        return _openstudiomodelgeometry.Surface_isNumberofVerticesAutocalculated(self)

    def setSurfaceType(self, surfaceType: "std::string") -> "bool":
        return _openstudiomodelgeometry.Surface_setSurfaceType(self, surfaceType)

    def setOutsideBoundaryCondition(self, outsideBoundaryCondition: "std::string") -> "bool":
        return _openstudiomodelgeometry.Surface_setOutsideBoundaryCondition(self, outsideBoundaryCondition)

    def setSunExposure(self, sunExposure: "std::string") -> "bool":
        return _openstudiomodelgeometry.Surface_setSunExposure(self, sunExposure)

    def resetSunExposure(self) -> "void":
        return _openstudiomodelgeometry.Surface_resetSunExposure(self)

    def setWindExposure(self, windExposure: "std::string") -> "bool":
        return _openstudiomodelgeometry.Surface_setWindExposure(self, windExposure)

    def resetWindExposure(self) -> "void":
        return _openstudiomodelgeometry.Surface_resetWindExposure(self)

    def setViewFactortoGround(self, *args) -> "bool":
        return _openstudiomodelgeometry.Surface_setViewFactortoGround(self, *args)

    def resetViewFactortoGround(self) -> "void":
        return _openstudiomodelgeometry.Surface_resetViewFactortoGround(self)

    def autocalculateViewFactortoGround(self) -> "void":
        return _openstudiomodelgeometry.Surface_autocalculateViewFactortoGround(self)

    def setNumberofVertices(self, *args) -> "bool":
        return _openstudiomodelgeometry.Surface_setNumberofVertices(self, *args)

    def resetNumberofVertices(self) -> "void":
        return _openstudiomodelgeometry.Surface_resetNumberofVertices(self)

    def autocalculateNumberofVertices(self) -> "void":
        return _openstudiomodelgeometry.Surface_autocalculateNumberofVertices(self)

    def subSurfaces(self) -> "std::vector< openstudio::model::SubSurface,std::allocator< openstudio::model::SubSurface > >":
        return _openstudiomodelgeometry.Surface_subSurfaces(self)

    def setSpace(self, space: "Space") -> "bool":
        return _openstudiomodelgeometry.Surface_setSpace(self, space)

    def adjacentSurface(self) -> "boost::optional< openstudio::model::Surface >":
        return _openstudiomodelgeometry.Surface_adjacentSurface(self)

    def setAdjacentSurface(self, surface: "Surface") -> "bool":
        return _openstudiomodelgeometry.Surface_setAdjacentSurface(self, surface)

    def resetAdjacentSurface(self) -> "void":
        return _openstudiomodelgeometry.Surface_resetAdjacentSurface(self)

    def surfaceControlMovableInsulation(self) -> "boost::optional< openstudio::model::SurfaceControlMovableInsulation >":
        return _openstudiomodelgeometry.Surface_surfaceControlMovableInsulation(self)

    def surfacePropertyConvectionCoefficients(self) -> "boost::optional< openstudio::model::SurfacePropertyConvectionCoefficients >":
        return _openstudiomodelgeometry.Surface_surfacePropertyConvectionCoefficients(self)

    def surfacePropertyOtherSideCoefficients(self) -> "boost::optional< openstudio::model::SurfacePropertyOtherSideCoefficients >":
        return _openstudiomodelgeometry.Surface_surfacePropertyOtherSideCoefficients(self)

    def setSurfacePropertyOtherSideCoefficients(self, otherSideCoefficients: "SurfacePropertyOtherSideCoefficients") -> "bool":
        return _openstudiomodelgeometry.Surface_setSurfacePropertyOtherSideCoefficients(self, otherSideCoefficients)

    def resetSurfacePropertyOtherSideCoefficients(self) -> "void":
        return _openstudiomodelgeometry.Surface_resetSurfacePropertyOtherSideCoefficients(self)

    def surfacePropertyOtherSideConditionsModel(self) -> "boost::optional< openstudio::model::SurfacePropertyOtherSideConditionsModel >":
        return _openstudiomodelgeometry.Surface_surfacePropertyOtherSideConditionsModel(self)

    def setSurfacePropertyOtherSideConditionsModel(self, otherSideModel: "SurfacePropertyOtherSideConditionsModel") -> "bool":
        return _openstudiomodelgeometry.Surface_setSurfacePropertyOtherSideConditionsModel(self, otherSideModel)

    def resetSurfacePropertyOtherSideConditionsModel(self) -> "void":
        return _openstudiomodelgeometry.Surface_resetSurfacePropertyOtherSideConditionsModel(self)

    def intersect(self, otherSurface: "Surface") -> "bool":
        return _openstudiomodelgeometry.Surface_intersect(self, otherSurface)

    def computeIntersection(self, otherSurface: "Surface") -> "boost::optional< openstudio::model::SurfaceIntersection >":
        return _openstudiomodelgeometry.Surface_computeIntersection(self, otherSurface)

    def createAdjacentSurface(self, otherSpace: "Space") -> "boost::optional< openstudio::model::Surface >":
        return _openstudiomodelgeometry.Surface_createAdjacentSurface(self, otherSpace)

    def isPartOfEnvelope(self) -> "bool":
        return _openstudiomodelgeometry.Surface_isPartOfEnvelope(self)

    def assignDefaultSurfaceType(self) -> "void":
        return _openstudiomodelgeometry.Surface_assignDefaultSurfaceType(self)

    def assignDefaultBoundaryCondition(self) -> "void":
        return _openstudiomodelgeometry.Surface_assignDefaultBoundaryCondition(self)

    def assignDefaultSunExposure(self) -> "void":
        return _openstudiomodelgeometry.Surface_assignDefaultSunExposure(self)

    def assignDefaultWindExposure(self) -> "void":
        return _openstudiomodelgeometry.Surface_assignDefaultWindExposure(self)

    def filmResistance(self) -> "double":
        return _openstudiomodelgeometry.Surface_filmResistance(self)

    def windowToWallRatio(self) -> "double":
        return _openstudiomodelgeometry.Surface_windowToWallRatio(self)

    def skylightToRoofRatio(self) -> "double":
        return _openstudiomodelgeometry.Surface_skylightToRoofRatio(self)

    def skylightToProjectedFloorRatio(self) -> "double":
        return _openstudiomodelgeometry.Surface_skylightToProjectedFloorRatio(self)

    def setWindowToWallRatio(self, *args) -> "boost::optional< openstudio::model::SubSurface >":
        return _openstudiomodelgeometry.Surface_setWindowToWallRatio(self, *args)

    def applyViewAndDaylightingGlassRatios(self, viewGlassToWallRatio: "double", daylightingGlassToWallRatio: "double", desiredViewGlassSillHeight: "double", desiredDaylightingGlassHeaderHeight: "double", exteriorShadingProjectionFactor: "double", interiorShelfProjectionFactor: "double", viewGlassConstruction: "OptionalConstructionBase", daylightingGlassConstruction: "OptionalConstructionBase") -> "std::vector< openstudio::model::SubSurface,std::allocator< openstudio::model::SubSurface > >":
        return _openstudiomodelgeometry.Surface_applyViewAndDaylightingGlassRatios(self, viewGlassToWallRatio, daylightingGlassToWallRatio, desiredViewGlassSillHeight, desiredDaylightingGlassHeaderHeight, exteriorShadingProjectionFactor, interiorShelfProjectionFactor, viewGlassConstruction, daylightingGlassConstruction)

    def shadingSurfaceGroups(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup,std::allocator< openstudio::model::ShadingSurfaceGroup > >":
        return _openstudiomodelgeometry.Surface_shadingSurfaceGroups(self)

    def splitSurfaceForSubSurfaces(self) -> "std::vector< openstudio::model::Surface,std::allocator< openstudio::model::Surface > >":
        return _openstudiomodelgeometry.Surface_splitSurfaceForSubSurfaces(self)

    def createSubSurfaces(self, faces: "Point3dVectorVector", inset: "double", construction: "OptionalConstructionBase") -> "std::vector< openstudio::model::SubSurface,std::allocator< openstudio::model::SubSurface > >":
        return _openstudiomodelgeometry.Surface_createSubSurfaces(self, faces, inset, construction)

    def getAirflowNetworkSurface(self, *args) -> "openstudio::model::AirflowNetworkSurface":
        return _openstudiomodelgeometry.Surface_getAirflowNetworkSurface(self, *args)

    def airflowNetworkSurface(self) -> "boost::optional< openstudio::model::AirflowNetworkSurface >":
        return _openstudiomodelgeometry.Surface_airflowNetworkSurface(self)

    def setAdjacentFoundation(self, kiva: "FoundationKiva") -> "bool":
        return _openstudiomodelgeometry.Surface_setAdjacentFoundation(self, kiva)

    def adjacentFoundation(self) -> "boost::optional< openstudio::model::FoundationKiva >":
        return _openstudiomodelgeometry.Surface_adjacentFoundation(self)

    def resetAdjacentFoundation(self) -> "void":
        return _openstudiomodelgeometry.Surface_resetAdjacentFoundation(self)

    def createSurfacePropertyExposedFoundationPerimeter(self, exposedPerimeterCalculationMethod: "std::string", exposedPerimeter: "double") -> "boost::optional< openstudio::model::SurfacePropertyExposedFoundationPerimeter >":
        return _openstudiomodelgeometry.Surface_createSurfacePropertyExposedFoundationPerimeter(self, exposedPerimeterCalculationMethod, exposedPerimeter)

    def surfacePropertyExposedFoundationPerimeter(self) -> "boost::optional< openstudio::model::SurfacePropertyExposedFoundationPerimeter >":
        return _openstudiomodelgeometry.Surface_surfacePropertyExposedFoundationPerimeter(self)

    def resetSurfacePropertyExposedFoundationPerimeter(self) -> "void":
        return _openstudiomodelgeometry.Surface_resetSurfacePropertyExposedFoundationPerimeter(self)

# Register Surface in _openstudiomodelgeometry:
_openstudiomodelgeometry.Surface_swigregister(Surface)

def Surface_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.Surface_iddObjectType()

def Surface_validSurfaceTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.Surface_validSurfaceTypeValues()

def Surface_validOutsideBoundaryConditionValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.Surface_validOutsideBoundaryConditionValues()

def Surface_validSunExposureValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.Surface_validSunExposureValues()

def Surface_validWindExposureValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.Surface_validWindExposureValues()

class SurfaceIntersection(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, surface1: "Surface", surface2: "Surface", newSurfaces1: "SurfaceVector", newSurfaces2: "SurfaceVector"):
        _openstudiomodelgeometry.SurfaceIntersection_swiginit(self, _openstudiomodelgeometry.new_SurfaceIntersection(surface1, surface2, newSurfaces1, newSurfaces2))

    def surface1(self) -> "openstudio::model::Surface":
        return _openstudiomodelgeometry.SurfaceIntersection_surface1(self)

    def surface2(self) -> "openstudio::model::Surface":
        return _openstudiomodelgeometry.SurfaceIntersection_surface2(self)

    def newSurfaces1(self) -> "std::vector< openstudio::model::Surface,std::allocator< openstudio::model::Surface > >":
        return _openstudiomodelgeometry.SurfaceIntersection_newSurfaces1(self)

    def newSurfaces2(self) -> "std::vector< openstudio::model::Surface,std::allocator< openstudio::model::Surface > >":
        return _openstudiomodelgeometry.SurfaceIntersection_newSurfaces2(self)

    def __str__(self) -> "std::string":
        return _openstudiomodelgeometry.SurfaceIntersection___str__(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SurfaceIntersection

# Register SurfaceIntersection in _openstudiomodelgeometry:
_openstudiomodelgeometry.SurfaceIntersection_swigregister(SurfaceIntersection)


def toSurface(idfObject: "IdfObject") -> "boost::optional< openstudio::model::Surface >":
    return _openstudiomodelgeometry.toSurface(idfObject)

def getSurface(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::Surface >":
    return _openstudiomodelgeometry.getSurface(t_model, t_handle)

def getSurfaces(t_model: "Model") -> "std::vector< openstudio::model::Surface,std::allocator< openstudio::model::Surface > >":
    return _openstudiomodelgeometry.getSurfaces(t_model)

def getSurfaceByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::Surface >":
    return _openstudiomodelgeometry.getSurfaceByName(t_model, t_name)

def getSurfacesByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::Surface,std::allocator< openstudio::model::Surface > >":
    return _openstudiomodelgeometry.getSurfacesByName(t_model, t_name, t_exactMatch)

def _to_Surface(self) -> OptionalSurface:
    return toSurface(self)
openstudioutilitiesidf.IdfObject.to_Surface = _to_Surface

def _getSurface(self, t_handle: "UUID") -> OptionalSurface:
    return getSurface(self, t_handle)
Model.getSurface = _getSurface

def _getSurface(self, t_handle_str: str) -> OptionalSurface:
    return getSurface(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getSurface = _getSurface

def _getSurfaces(self) -> SurfaceVector:
    return getSurfaces(self)
Model.getSurfaces = _getSurfaces

def _getSurfaceByName(self, t_name: str) -> OptionalSurface:
    return getSurfaceByName(self, t_name)
Model.getSurfaceByName = _getSurfaceByName

def _getSurfacesByName(self, t_name: str, t_exactMatch: bool) -> SurfaceVector:
    return getSurfacesByName(self, t_name, t_exactMatch)
Model.getSurfacesByName = _getSurfacesByName

class SubSurface(PlanarSurface):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, vertices: "Point3dVector", model: "Model"):
        _openstudiomodelgeometry.SubSurface_swiginit(self, _openstudiomodelgeometry.new_SubSurface(vertices, model))
    __swig_destroy__ = _openstudiomodelgeometry.delete_SubSurface

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.SubSurface_iddObjectType()

    @staticmethod
    def validSubSurfaceTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.SubSurface_validSubSurfaceTypeValues()

    def subSurfaceType(self) -> "std::string":
        return _openstudiomodelgeometry.SubSurface_subSurfaceType(self)

    def isSubSurfaceTypeDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SubSurface_isSubSurfaceTypeDefaulted(self)

    def viewFactortoGround(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SubSurface_viewFactortoGround(self)

    def isViewFactortoGroundDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SubSurface_isViewFactortoGroundDefaulted(self)

    def isViewFactortoGroundAutocalculated(self) -> "bool":
        return _openstudiomodelgeometry.SubSurface_isViewFactortoGroundAutocalculated(self)

    def allowShadingControl(self) -> "bool":
        return _openstudiomodelgeometry.SubSurface_allowShadingControl(self)

    def shadingControl(self) -> "boost::optional< openstudio::model::ShadingControl >":
        return _openstudiomodelgeometry.SubSurface_shadingControl(self)

    def shadingControls(self) -> "std::vector< openstudio::model::ShadingControl,std::allocator< openstudio::model::ShadingControl > >":
        return _openstudiomodelgeometry.SubSurface_shadingControls(self)

    def numberofShadingControls(self) -> "unsigned int":
        return _openstudiomodelgeometry.SubSurface_numberofShadingControls(self)

    def allowWindowPropertyFrameAndDivider(self) -> "bool":
        return _openstudiomodelgeometry.SubSurface_allowWindowPropertyFrameAndDivider(self)

    def windowPropertyFrameAndDivider(self) -> "boost::optional< openstudio::model::WindowPropertyFrameAndDivider >":
        return _openstudiomodelgeometry.SubSurface_windowPropertyFrameAndDivider(self)

    def multiplier(self) -> "double":
        return _openstudiomodelgeometry.SubSurface_multiplier(self)

    def isMultiplierDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SubSurface_isMultiplierDefaulted(self)

    def numberofVertices(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SubSurface_numberofVertices(self)

    def isNumberofVerticesDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SubSurface_isNumberofVerticesDefaulted(self)

    def isNumberofVerticesAutocalculated(self) -> "bool":
        return _openstudiomodelgeometry.SubSurface_isNumberofVerticesAutocalculated(self)

    def setSubSurfaceType(self, subSurfaceType: "std::string") -> "bool":
        return _openstudiomodelgeometry.SubSurface_setSubSurfaceType(self, subSurfaceType)

    def resetSubSurfaceType(self) -> "void":
        return _openstudiomodelgeometry.SubSurface_resetSubSurfaceType(self)

    def setViewFactortoGround(self, *args) -> "bool":
        return _openstudiomodelgeometry.SubSurface_setViewFactortoGround(self, *args)

    def resetViewFactortoGround(self) -> "void":
        return _openstudiomodelgeometry.SubSurface_resetViewFactortoGround(self)

    def autocalculateViewFactortoGround(self) -> "void":
        return _openstudiomodelgeometry.SubSurface_autocalculateViewFactortoGround(self)

    def setShadingControl(self, shadingControl: "ShadingControl") -> "bool":
        return _openstudiomodelgeometry.SubSurface_setShadingControl(self, shadingControl)

    def resetShadingControl(self) -> "void":
        return _openstudiomodelgeometry.SubSurface_resetShadingControl(self)

    def addShadingControl(self, shadingControl: "ShadingControl") -> "bool":
        return _openstudiomodelgeometry.SubSurface_addShadingControl(self, shadingControl)

    def addShadingControls(self, shadingControls: "ShadingControlVector") -> "bool":
        return _openstudiomodelgeometry.SubSurface_addShadingControls(self, shadingControls)

    def removeShadingControl(self, shadingControl: "ShadingControl") -> "void":
        return _openstudiomodelgeometry.SubSurface_removeShadingControl(self, shadingControl)

    def removeAllShadingControls(self) -> "void":
        return _openstudiomodelgeometry.SubSurface_removeAllShadingControls(self)

    def setWindowPropertyFrameAndDivider(self, windowPropertyFrameAndDivider: "WindowPropertyFrameAndDivider") -> "bool":
        return _openstudiomodelgeometry.SubSurface_setWindowPropertyFrameAndDivider(self, windowPropertyFrameAndDivider)

    def resetWindowPropertyFrameAndDivider(self) -> "void":
        return _openstudiomodelgeometry.SubSurface_resetWindowPropertyFrameAndDivider(self)

    def setMultiplier(self, multiplier: "double") -> "bool":
        return _openstudiomodelgeometry.SubSurface_setMultiplier(self, multiplier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.SubSurface_resetMultiplier(self)

    def setNumberofVertices(self, *args) -> "bool":
        return _openstudiomodelgeometry.SubSurface_setNumberofVertices(self, *args)

    def resetNumberofVertices(self) -> "void":
        return _openstudiomodelgeometry.SubSurface_resetNumberofVertices(self)

    def autocalculateNumberofVertices(self) -> "void":
        return _openstudiomodelgeometry.SubSurface_autocalculateNumberofVertices(self)

    def surface(self) -> "boost::optional< openstudio::model::Surface >":
        return _openstudiomodelgeometry.SubSurface_surface(self)

    def setSurface(self, surface: "Surface") -> "bool":
        return _openstudiomodelgeometry.SubSurface_setSurface(self, surface)

    def adjacentSubSurface(self) -> "boost::optional< openstudio::model::SubSurface >":
        return _openstudiomodelgeometry.SubSurface_adjacentSubSurface(self)

    def setAdjacentSubSurface(self, subSurface: "SubSurface") -> "bool":
        return _openstudiomodelgeometry.SubSurface_setAdjacentSubSurface(self, subSurface)

    def resetAdjacentSubSurface(self) -> "void":
        return _openstudiomodelgeometry.SubSurface_resetAdjacentSubSurface(self)

    def surfacePropertyConvectionCoefficients(self) -> "boost::optional< openstudio::model::SurfacePropertyConvectionCoefficients >":
        return _openstudiomodelgeometry.SubSurface_surfacePropertyConvectionCoefficients(self)

    def surfacePropertyOtherSideCoefficients(self) -> "boost::optional< openstudio::model::SurfacePropertyOtherSideCoefficients >":
        return _openstudiomodelgeometry.SubSurface_surfacePropertyOtherSideCoefficients(self)

    def setSurfacePropertyOtherSideCoefficients(self, otherSideCoefficients: "SurfacePropertyOtherSideCoefficients") -> "bool":
        return _openstudiomodelgeometry.SubSurface_setSurfacePropertyOtherSideCoefficients(self, otherSideCoefficients)

    def resetSurfacePropertyOtherSideCoefficients(self) -> "void":
        return _openstudiomodelgeometry.SubSurface_resetSurfacePropertyOtherSideCoefficients(self)

    def surfacePropertyOtherSideConditionsModel(self) -> "boost::optional< openstudio::model::SurfacePropertyOtherSideConditionsModel >":
        return _openstudiomodelgeometry.SubSurface_surfacePropertyOtherSideConditionsModel(self)

    def setSurfacePropertyOtherSideConditionsModel(self, otherSideModel: "SurfacePropertyOtherSideConditionsModel") -> "bool":
        return _openstudiomodelgeometry.SubSurface_setSurfacePropertyOtherSideConditionsModel(self, otherSideModel)

    def resetSurfacePropertyOtherSideConditionsModel(self) -> "void":
        return _openstudiomodelgeometry.SubSurface_resetSurfacePropertyOtherSideConditionsModel(self)

    def assignDefaultSubSurfaceType(self) -> "void":
        return _openstudiomodelgeometry.SubSurface_assignDefaultSubSurfaceType(self)

    def outsideBoundaryCondition(self) -> "std::string":
        return _openstudiomodelgeometry.SubSurface_outsideBoundaryCondition(self)

    def addOverhang(self, depth: "double", offset: "double") -> "boost::optional< openstudio::model::ShadingSurface >":
        return _openstudiomodelgeometry.SubSurface_addOverhang(self, depth, offset)

    def addOverhangByProjectionFactor(self, projectionFactor: "double", offsetFraction: "double") -> "boost::optional< openstudio::model::ShadingSurface >":
        return _openstudiomodelgeometry.SubSurface_addOverhangByProjectionFactor(self, projectionFactor, offsetFraction)

    def shadingSurfaceGroups(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup,std::allocator< openstudio::model::ShadingSurfaceGroup > >":
        return _openstudiomodelgeometry.SubSurface_shadingSurfaceGroups(self)

    def allowDaylightingDeviceShelf(self) -> "bool":
        return _openstudiomodelgeometry.SubSurface_allowDaylightingDeviceShelf(self)

    def daylightingDeviceShelf(self) -> "boost::optional< openstudio::model::DaylightingDeviceShelf >":
        return _openstudiomodelgeometry.SubSurface_daylightingDeviceShelf(self)

    def addDaylightingDeviceShelf(self) -> "boost::optional< openstudio::model::DaylightingDeviceShelf >":
        return _openstudiomodelgeometry.SubSurface_addDaylightingDeviceShelf(self)

    def getAirflowNetworkSurface(self, *args) -> "openstudio::model::AirflowNetworkSurface":
        return _openstudiomodelgeometry.SubSurface_getAirflowNetworkSurface(self, *args)

    def airflowNetworkSurface(self) -> "boost::optional< openstudio::model::AirflowNetworkSurface >":
        return _openstudiomodelgeometry.SubSurface_airflowNetworkSurface(self)

# Register SubSurface in _openstudiomodelgeometry:
_openstudiomodelgeometry.SubSurface_swigregister(SubSurface)

def SubSurface_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.SubSurface_iddObjectType()

def SubSurface_validSubSurfaceTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.SubSurface_validSubSurfaceTypeValues()


def applySkylightPattern(pattern: "Point3dVectorVector", spaces: "SpaceVector", construction: "OptionalConstructionBase") -> "std::vector< openstudio::model::SubSurface,std::allocator< openstudio::model::SubSurface > >":
    return _openstudiomodelgeometry.applySkylightPattern(pattern, spaces, construction)

def toSubSurface(idfObject: "IdfObject") -> "boost::optional< openstudio::model::SubSurface >":
    return _openstudiomodelgeometry.toSubSurface(idfObject)

def getSubSurface(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::SubSurface >":
    return _openstudiomodelgeometry.getSubSurface(t_model, t_handle)

def getSubSurfaces(t_model: "Model") -> "std::vector< openstudio::model::SubSurface,std::allocator< openstudio::model::SubSurface > >":
    return _openstudiomodelgeometry.getSubSurfaces(t_model)

def getSubSurfaceByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::SubSurface >":
    return _openstudiomodelgeometry.getSubSurfaceByName(t_model, t_name)

def getSubSurfacesByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::SubSurface,std::allocator< openstudio::model::SubSurface > >":
    return _openstudiomodelgeometry.getSubSurfacesByName(t_model, t_name, t_exactMatch)

def _to_SubSurface(self) -> OptionalSubSurface:
    return toSubSurface(self)
openstudioutilitiesidf.IdfObject.to_SubSurface = _to_SubSurface

def _getSubSurface(self, t_handle: "UUID") -> OptionalSubSurface:
    return getSubSurface(self, t_handle)
Model.getSubSurface = _getSubSurface

def _getSubSurface(self, t_handle_str: str) -> OptionalSubSurface:
    return getSubSurface(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getSubSurface = _getSubSurface

def _getSubSurfaces(self) -> SubSurfaceVector:
    return getSubSurfaces(self)
Model.getSubSurfaces = _getSubSurfaces

def _getSubSurfaceByName(self, t_name: str) -> OptionalSubSurface:
    return getSubSurfaceByName(self, t_name)
Model.getSubSurfaceByName = _getSubSurfaceByName

def _getSubSurfacesByName(self, t_name: str, t_exactMatch: bool) -> SubSurfaceVector:
    return getSubSurfacesByName(self, t_name, t_exactMatch)
Model.getSubSurfacesByName = _getSubSurfacesByName

class ShadingSurfaceGroup(PlanarSurfaceGroup):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, model: "Model"):
        _openstudiomodelgeometry.ShadingSurfaceGroup_swiginit(self, _openstudiomodelgeometry.new_ShadingSurfaceGroup(model))
    __swig_destroy__ = _openstudiomodelgeometry.delete_ShadingSurfaceGroup

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.ShadingSurfaceGroup_iddObjectType()

    @staticmethod
    def validShadingSurfaceTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.ShadingSurfaceGroup_validShadingSurfaceTypeValues()

    def shadingSurfaceType(self) -> "std::string":
        return _openstudiomodelgeometry.ShadingSurfaceGroup_shadingSurfaceType(self)

    def setShadingSurfaceType(self, shadingSurfaceType: "std::string") -> "bool":
        return _openstudiomodelgeometry.ShadingSurfaceGroup_setShadingSurfaceType(self, shadingSurfaceType)

    def space(self) -> "boost::optional< openstudio::model::Space >":
        return _openstudiomodelgeometry.ShadingSurfaceGroup_space(self)

    def setSpace(self, space: "Space") -> "bool":
        return _openstudiomodelgeometry.ShadingSurfaceGroup_setSpace(self, space)

    def resetSpace(self) -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroup_resetSpace(self)

    def shadingSurfaces(self) -> "std::vector< openstudio::model::ShadingSurface,std::allocator< openstudio::model::ShadingSurface > >":
        return _openstudiomodelgeometry.ShadingSurfaceGroup_shadingSurfaces(self)

    def shadedSubSurface(self) -> "boost::optional< openstudio::model::SubSurface >":
        return _openstudiomodelgeometry.ShadingSurfaceGroup_shadedSubSurface(self)

    def shadedSurface(self) -> "boost::optional< openstudio::model::Surface >":
        return _openstudiomodelgeometry.ShadingSurfaceGroup_shadedSurface(self)

    def setShadedSubSurface(self, subSurface: "SubSurface") -> "bool":
        return _openstudiomodelgeometry.ShadingSurfaceGroup_setShadedSubSurface(self, subSurface)

    def setShadedSurface(self, surface: "Surface") -> "bool":
        return _openstudiomodelgeometry.ShadingSurfaceGroup_setShadedSurface(self, surface)

    def resetShadedObject(self) -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroup_resetShadedObject(self)

# Register ShadingSurfaceGroup in _openstudiomodelgeometry:
_openstudiomodelgeometry.ShadingSurfaceGroup_swigregister(ShadingSurfaceGroup)

def ShadingSurfaceGroup_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.ShadingSurfaceGroup_iddObjectType()

def ShadingSurfaceGroup_validShadingSurfaceTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.ShadingSurfaceGroup_validShadingSurfaceTypeValues()


def toShadingSurfaceGroup(idfObject: "IdfObject") -> "boost::optional< openstudio::model::ShadingSurfaceGroup >":
    return _openstudiomodelgeometry.toShadingSurfaceGroup(idfObject)

def getShadingSurfaceGroup(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::ShadingSurfaceGroup >":
    return _openstudiomodelgeometry.getShadingSurfaceGroup(t_model, t_handle)

def getShadingSurfaceGroups(t_model: "Model") -> "std::vector< openstudio::model::ShadingSurfaceGroup,std::allocator< openstudio::model::ShadingSurfaceGroup > >":
    return _openstudiomodelgeometry.getShadingSurfaceGroups(t_model)

def getShadingSurfaceGroupByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::ShadingSurfaceGroup >":
    return _openstudiomodelgeometry.getShadingSurfaceGroupByName(t_model, t_name)

def getShadingSurfaceGroupsByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::ShadingSurfaceGroup,std::allocator< openstudio::model::ShadingSurfaceGroup > >":
    return _openstudiomodelgeometry.getShadingSurfaceGroupsByName(t_model, t_name, t_exactMatch)

def _to_ShadingSurfaceGroup(self) -> OptionalShadingSurfaceGroup:
    return toShadingSurfaceGroup(self)
openstudioutilitiesidf.IdfObject.to_ShadingSurfaceGroup = _to_ShadingSurfaceGroup

def _getShadingSurfaceGroup(self, t_handle: "UUID") -> OptionalShadingSurfaceGroup:
    return getShadingSurfaceGroup(self, t_handle)
Model.getShadingSurfaceGroup = _getShadingSurfaceGroup

def _getShadingSurfaceGroup(self, t_handle_str: str) -> OptionalShadingSurfaceGroup:
    return getShadingSurfaceGroup(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getShadingSurfaceGroup = _getShadingSurfaceGroup

def _getShadingSurfaceGroups(self) -> ShadingSurfaceGroupVector:
    return getShadingSurfaceGroups(self)
Model.getShadingSurfaceGroups = _getShadingSurfaceGroups

def _getShadingSurfaceGroupByName(self, t_name: str) -> OptionalShadingSurfaceGroup:
    return getShadingSurfaceGroupByName(self, t_name)
Model.getShadingSurfaceGroupByName = _getShadingSurfaceGroupByName

def _getShadingSurfaceGroupsByName(self, t_name: str, t_exactMatch: bool) -> ShadingSurfaceGroupVector:
    return getShadingSurfaceGroupsByName(self, t_name, t_exactMatch)
Model.getShadingSurfaceGroupsByName = _getShadingSurfaceGroupsByName

class ShadingSurface(PlanarSurface):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, vertices: "Point3dVector", model: "Model"):
        _openstudiomodelgeometry.ShadingSurface_swiginit(self, _openstudiomodelgeometry.new_ShadingSurface(vertices, model))
    __swig_destroy__ = _openstudiomodelgeometry.delete_ShadingSurface

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.ShadingSurface_iddObjectType()

    def shadingSurfaceGroup(self) -> "boost::optional< openstudio::model::ShadingSurfaceGroup >":
        return _openstudiomodelgeometry.ShadingSurface_shadingSurfaceGroup(self)

    def transmittanceSchedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.ShadingSurface_transmittanceSchedule(self)

    def numberofVertices(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.ShadingSurface_numberofVertices(self)

    def isNumberofVerticesDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.ShadingSurface_isNumberofVerticesDefaulted(self)

    def isNumberofVerticesAutocalculated(self) -> "bool":
        return _openstudiomodelgeometry.ShadingSurface_isNumberofVerticesAutocalculated(self)

    def setShadingSurfaceGroup(self, shadingSurfaceGroup: "ShadingSurfaceGroup") -> "bool":
        return _openstudiomodelgeometry.ShadingSurface_setShadingSurfaceGroup(self, shadingSurfaceGroup)

    def resetShadingSurfaceGroup(self) -> "void":
        return _openstudiomodelgeometry.ShadingSurface_resetShadingSurfaceGroup(self)

    def setTransmittanceSchedule(self, transmittanceSchedule: "Schedule") -> "bool":
        return _openstudiomodelgeometry.ShadingSurface_setTransmittanceSchedule(self, transmittanceSchedule)

    def resetTransmittanceSchedule(self) -> "void":
        return _openstudiomodelgeometry.ShadingSurface_resetTransmittanceSchedule(self)

    def setNumberofVertices(self, *args) -> "bool":
        return _openstudiomodelgeometry.ShadingSurface_setNumberofVertices(self, *args)

    def resetNumberofVertices(self) -> "void":
        return _openstudiomodelgeometry.ShadingSurface_resetNumberofVertices(self)

    def autocalculateNumberofVertices(self) -> "void":
        return _openstudiomodelgeometry.ShadingSurface_autocalculateNumberofVertices(self)

    def daylightingDeviceShelf(self) -> "boost::optional< openstudio::model::DaylightingDeviceShelf >":
        return _openstudiomodelgeometry.ShadingSurface_daylightingDeviceShelf(self)

# Register ShadingSurface in _openstudiomodelgeometry:
_openstudiomodelgeometry.ShadingSurface_swigregister(ShadingSurface)

def ShadingSurface_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.ShadingSurface_iddObjectType()


def toShadingSurface(idfObject: "IdfObject") -> "boost::optional< openstudio::model::ShadingSurface >":
    return _openstudiomodelgeometry.toShadingSurface(idfObject)

def getShadingSurface(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::ShadingSurface >":
    return _openstudiomodelgeometry.getShadingSurface(t_model, t_handle)

def getShadingSurfaces(t_model: "Model") -> "std::vector< openstudio::model::ShadingSurface,std::allocator< openstudio::model::ShadingSurface > >":
    return _openstudiomodelgeometry.getShadingSurfaces(t_model)

def getShadingSurfaceByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::ShadingSurface >":
    return _openstudiomodelgeometry.getShadingSurfaceByName(t_model, t_name)

def getShadingSurfacesByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::ShadingSurface,std::allocator< openstudio::model::ShadingSurface > >":
    return _openstudiomodelgeometry.getShadingSurfacesByName(t_model, t_name, t_exactMatch)

def _to_ShadingSurface(self) -> OptionalShadingSurface:
    return toShadingSurface(self)
openstudioutilitiesidf.IdfObject.to_ShadingSurface = _to_ShadingSurface

def _getShadingSurface(self, t_handle: "UUID") -> OptionalShadingSurface:
    return getShadingSurface(self, t_handle)
Model.getShadingSurface = _getShadingSurface

def _getShadingSurface(self, t_handle_str: str) -> OptionalShadingSurface:
    return getShadingSurface(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getShadingSurface = _getShadingSurface

def _getShadingSurfaces(self) -> ShadingSurfaceVector:
    return getShadingSurfaces(self)
Model.getShadingSurfaces = _getShadingSurfaces

def _getShadingSurfaceByName(self, t_name: str) -> OptionalShadingSurface:
    return getShadingSurfaceByName(self, t_name)
Model.getShadingSurfaceByName = _getShadingSurfaceByName

def _getShadingSurfacesByName(self, t_name: str, t_exactMatch: bool) -> ShadingSurfaceVector:
    return getShadingSurfacesByName(self, t_name, t_exactMatch)
Model.getShadingSurfacesByName = _getShadingSurfacesByName

class InteriorPartitionSurfaceGroup(PlanarSurfaceGroup):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, model: "Model"):
        _openstudiomodelgeometry.InteriorPartitionSurfaceGroup_swiginit(self, _openstudiomodelgeometry.new_InteriorPartitionSurfaceGroup(model))
    __swig_destroy__ = _openstudiomodelgeometry.delete_InteriorPartitionSurfaceGroup

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroup_iddObjectType()

    def multiplier(self) -> "int":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroup_multiplier(self)

    def isMultiplierDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroup_isMultiplierDefaulted(self)

    def setMultiplier(self, multiplier: "int") -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroup_setMultiplier(self, multiplier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroup_resetMultiplier(self)

    def space(self) -> "boost::optional< openstudio::model::Space >":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroup_space(self)

    def setSpace(self, space: "Space") -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroup_setSpace(self, space)

    def resetSpace(self) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroup_resetSpace(self)

    def interiorPartitionSurfaces(self) -> "std::vector< openstudio::model::InteriorPartitionSurface,std::allocator< openstudio::model::InteriorPartitionSurface > >":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroup_interiorPartitionSurfaces(self)

# Register InteriorPartitionSurfaceGroup in _openstudiomodelgeometry:
_openstudiomodelgeometry.InteriorPartitionSurfaceGroup_swigregister(InteriorPartitionSurfaceGroup)

def InteriorPartitionSurfaceGroup_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.InteriorPartitionSurfaceGroup_iddObjectType()


def toInteriorPartitionSurfaceGroup(idfObject: "IdfObject") -> "boost::optional< openstudio::model::InteriorPartitionSurfaceGroup >":
    return _openstudiomodelgeometry.toInteriorPartitionSurfaceGroup(idfObject)

def getInteriorPartitionSurfaceGroup(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::InteriorPartitionSurfaceGroup >":
    return _openstudiomodelgeometry.getInteriorPartitionSurfaceGroup(t_model, t_handle)

def getInteriorPartitionSurfaceGroups(t_model: "Model") -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup,std::allocator< openstudio::model::InteriorPartitionSurfaceGroup > >":
    return _openstudiomodelgeometry.getInteriorPartitionSurfaceGroups(t_model)

def getInteriorPartitionSurfaceGroupByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::InteriorPartitionSurfaceGroup >":
    return _openstudiomodelgeometry.getInteriorPartitionSurfaceGroupByName(t_model, t_name)

def getInteriorPartitionSurfaceGroupsByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup,std::allocator< openstudio::model::InteriorPartitionSurfaceGroup > >":
    return _openstudiomodelgeometry.getInteriorPartitionSurfaceGroupsByName(t_model, t_name, t_exactMatch)

def _to_InteriorPartitionSurfaceGroup(self) -> OptionalInteriorPartitionSurfaceGroup:
    return toInteriorPartitionSurfaceGroup(self)
openstudioutilitiesidf.IdfObject.to_InteriorPartitionSurfaceGroup = _to_InteriorPartitionSurfaceGroup

def _getInteriorPartitionSurfaceGroup(self, t_handle: "UUID") -> OptionalInteriorPartitionSurfaceGroup:
    return getInteriorPartitionSurfaceGroup(self, t_handle)
Model.getInteriorPartitionSurfaceGroup = _getInteriorPartitionSurfaceGroup

def _getInteriorPartitionSurfaceGroup(self, t_handle_str: str) -> OptionalInteriorPartitionSurfaceGroup:
    return getInteriorPartitionSurfaceGroup(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getInteriorPartitionSurfaceGroup = _getInteriorPartitionSurfaceGroup

def _getInteriorPartitionSurfaceGroups(self) -> InteriorPartitionSurfaceGroupVector:
    return getInteriorPartitionSurfaceGroups(self)
Model.getInteriorPartitionSurfaceGroups = _getInteriorPartitionSurfaceGroups

def _getInteriorPartitionSurfaceGroupByName(self, t_name: str) -> OptionalInteriorPartitionSurfaceGroup:
    return getInteriorPartitionSurfaceGroupByName(self, t_name)
Model.getInteriorPartitionSurfaceGroupByName = _getInteriorPartitionSurfaceGroupByName

def _getInteriorPartitionSurfaceGroupsByName(self, t_name: str, t_exactMatch: bool) -> InteriorPartitionSurfaceGroupVector:
    return getInteriorPartitionSurfaceGroupsByName(self, t_name, t_exactMatch)
Model.getInteriorPartitionSurfaceGroupsByName = _getInteriorPartitionSurfaceGroupsByName

class InteriorPartitionSurface(PlanarSurface):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, vertices: "Point3dVector", model: "Model"):
        _openstudiomodelgeometry.InteriorPartitionSurface_swiginit(self, _openstudiomodelgeometry.new_InteriorPartitionSurface(vertices, model))
    __swig_destroy__ = _openstudiomodelgeometry.delete_InteriorPartitionSurface

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.InteriorPartitionSurface_iddObjectType()

    def converttoInternalMass(self) -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurface_converttoInternalMass(self)

    def isConverttoInternalMassDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurface_isConverttoInternalMassDefaulted(self)

    def surfaceArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.InteriorPartitionSurface_surfaceArea(self)

    def numberofVertices(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.InteriorPartitionSurface_numberofVertices(self)

    def isNumberofVerticesDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurface_isNumberofVerticesDefaulted(self)

    def isNumberofVerticesAutocalculated(self) -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurface_isNumberofVerticesAutocalculated(self)

    def setConverttoInternalMass(self, converttoInternalMass: "bool") -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurface_setConverttoInternalMass(self, converttoInternalMass)

    def resetConverttoInternalMass(self) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurface_resetConverttoInternalMass(self)

    def setSurfaceArea(self, *args) -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurface_setSurfaceArea(self, *args)

    def resetSurfaceArea(self) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurface_resetSurfaceArea(self)

    def setNumberofVertices(self, *args) -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurface_setNumberofVertices(self, *args)

    def resetNumberofVertices(self) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurface_resetNumberofVertices(self)

    def autocalculateNumberofVertices(self) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurface_autocalculateNumberofVertices(self)

    def interiorPartitionSurfaceGroup(self) -> "boost::optional< openstudio::model::InteriorPartitionSurfaceGroup >":
        return _openstudiomodelgeometry.InteriorPartitionSurface_interiorPartitionSurfaceGroup(self)

    def setInteriorPartitionSurfaceGroup(self, interiorPartitionSurfaceGroup: "InteriorPartitionSurfaceGroup") -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurface_setInteriorPartitionSurfaceGroup(self, interiorPartitionSurfaceGroup)

    def resetInteriorPartitionSurfaceGroup(self) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurface_resetInteriorPartitionSurfaceGroup(self)

    def daylightingDeviceShelf(self) -> "boost::optional< openstudio::model::DaylightingDeviceShelf >":
        return _openstudiomodelgeometry.InteriorPartitionSurface_daylightingDeviceShelf(self)

# Register InteriorPartitionSurface in _openstudiomodelgeometry:
_openstudiomodelgeometry.InteriorPartitionSurface_swigregister(InteriorPartitionSurface)

def InteriorPartitionSurface_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.InteriorPartitionSurface_iddObjectType()


def toInteriorPartitionSurface(idfObject: "IdfObject") -> "boost::optional< openstudio::model::InteriorPartitionSurface >":
    return _openstudiomodelgeometry.toInteriorPartitionSurface(idfObject)

def getInteriorPartitionSurface(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::InteriorPartitionSurface >":
    return _openstudiomodelgeometry.getInteriorPartitionSurface(t_model, t_handle)

def getInteriorPartitionSurfaces(t_model: "Model") -> "std::vector< openstudio::model::InteriorPartitionSurface,std::allocator< openstudio::model::InteriorPartitionSurface > >":
    return _openstudiomodelgeometry.getInteriorPartitionSurfaces(t_model)

def getInteriorPartitionSurfaceByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::InteriorPartitionSurface >":
    return _openstudiomodelgeometry.getInteriorPartitionSurfaceByName(t_model, t_name)

def getInteriorPartitionSurfacesByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::InteriorPartitionSurface,std::allocator< openstudio::model::InteriorPartitionSurface > >":
    return _openstudiomodelgeometry.getInteriorPartitionSurfacesByName(t_model, t_name, t_exactMatch)

def _to_InteriorPartitionSurface(self) -> OptionalInteriorPartitionSurface:
    return toInteriorPartitionSurface(self)
openstudioutilitiesidf.IdfObject.to_InteriorPartitionSurface = _to_InteriorPartitionSurface

def _getInteriorPartitionSurface(self, t_handle: "UUID") -> OptionalInteriorPartitionSurface:
    return getInteriorPartitionSurface(self, t_handle)
Model.getInteriorPartitionSurface = _getInteriorPartitionSurface

def _getInteriorPartitionSurface(self, t_handle_str: str) -> OptionalInteriorPartitionSurface:
    return getInteriorPartitionSurface(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getInteriorPartitionSurface = _getInteriorPartitionSurface

def _getInteriorPartitionSurfaces(self) -> InteriorPartitionSurfaceVector:
    return getInteriorPartitionSurfaces(self)
Model.getInteriorPartitionSurfaces = _getInteriorPartitionSurfaces

def _getInteriorPartitionSurfaceByName(self, t_name: str) -> OptionalInteriorPartitionSurface:
    return getInteriorPartitionSurfaceByName(self, t_name)
Model.getInteriorPartitionSurfaceByName = _getInteriorPartitionSurfaceByName

def _getInteriorPartitionSurfacesByName(self, t_name: str, t_exactMatch: bool) -> InteriorPartitionSurfaceVector:
    return getInteriorPartitionSurfacesByName(self, t_name, t_exactMatch)
Model.getInteriorPartitionSurfacesByName = _getInteriorPartitionSurfacesByName

class SurfaceControlMovableInsulation(openstudiomodelcore.ModelObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, surface: "Surface", material: "Material"):
        _openstudiomodelgeometry.SurfaceControlMovableInsulation_swiginit(self, _openstudiomodelgeometry.new_SurfaceControlMovableInsulation(surface, material))
    __swig_destroy__ = _openstudiomodelgeometry.delete_SurfaceControlMovableInsulation

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulation_iddObjectType()

    @staticmethod
    def insulationTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulation_insulationTypeValues()

    @staticmethod
    def validInsulationTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulation_validInsulationTypeValues()

    def insulationType(self) -> "std::string":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulation_insulationType(self)

    def surface(self) -> "openstudio::model::Surface":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulation_surface(self)

    def material(self) -> "openstudio::model::Material":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulation_material(self)

    def schedule(self) -> "openstudio::model::Schedule":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulation_schedule(self)

    def setInsulationType(self, insulationType: "std::string const &") -> "bool":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulation_setInsulationType(self, insulationType)

    def setSurface(self, surface: "Surface") -> "bool":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulation_setSurface(self, surface)

    def setMaterial(self, material: "Material") -> "bool":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulation_setMaterial(self, material)

    def setSchedule(self, schedule: "Schedule") -> "bool":
        return _openstudiomodelgeometry.SurfaceControlMovableInsulation_setSchedule(self, schedule)

# Register SurfaceControlMovableInsulation in _openstudiomodelgeometry:
_openstudiomodelgeometry.SurfaceControlMovableInsulation_swigregister(SurfaceControlMovableInsulation)

def SurfaceControlMovableInsulation_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.SurfaceControlMovableInsulation_iddObjectType()

def SurfaceControlMovableInsulation_insulationTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.SurfaceControlMovableInsulation_insulationTypeValues()

def SurfaceControlMovableInsulation_validInsulationTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.SurfaceControlMovableInsulation_validInsulationTypeValues()


def toSurfaceControlMovableInsulation(idfObject: "IdfObject") -> "boost::optional< openstudio::model::SurfaceControlMovableInsulation >":
    return _openstudiomodelgeometry.toSurfaceControlMovableInsulation(idfObject)

def getSurfaceControlMovableInsulation(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::SurfaceControlMovableInsulation >":
    return _openstudiomodelgeometry.getSurfaceControlMovableInsulation(t_model, t_handle)

def getSurfaceControlMovableInsulations(t_model: "Model") -> "std::vector< openstudio::model::SurfaceControlMovableInsulation,std::allocator< openstudio::model::SurfaceControlMovableInsulation > >":
    return _openstudiomodelgeometry.getSurfaceControlMovableInsulations(t_model)

def getSurfaceControlMovableInsulationByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::SurfaceControlMovableInsulation >":
    return _openstudiomodelgeometry.getSurfaceControlMovableInsulationByName(t_model, t_name)

def getSurfaceControlMovableInsulationsByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::SurfaceControlMovableInsulation,std::allocator< openstudio::model::SurfaceControlMovableInsulation > >":
    return _openstudiomodelgeometry.getSurfaceControlMovableInsulationsByName(t_model, t_name, t_exactMatch)

def _to_SurfaceControlMovableInsulation(self) -> OptionalSurfaceControlMovableInsulation:
    return toSurfaceControlMovableInsulation(self)
openstudioutilitiesidf.IdfObject.to_SurfaceControlMovableInsulation = _to_SurfaceControlMovableInsulation

def _getSurfaceControlMovableInsulation(self, t_handle: "UUID") -> OptionalSurfaceControlMovableInsulation:
    return getSurfaceControlMovableInsulation(self, t_handle)
Model.getSurfaceControlMovableInsulation = _getSurfaceControlMovableInsulation

def _getSurfaceControlMovableInsulation(self, t_handle_str: str) -> OptionalSurfaceControlMovableInsulation:
    return getSurfaceControlMovableInsulation(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getSurfaceControlMovableInsulation = _getSurfaceControlMovableInsulation

def _getSurfaceControlMovableInsulations(self) -> SurfaceControlMovableInsulationVector:
    return getSurfaceControlMovableInsulations(self)
Model.getSurfaceControlMovableInsulations = _getSurfaceControlMovableInsulations

def _getSurfaceControlMovableInsulationByName(self, t_name: str) -> OptionalSurfaceControlMovableInsulation:
    return getSurfaceControlMovableInsulationByName(self, t_name)
Model.getSurfaceControlMovableInsulationByName = _getSurfaceControlMovableInsulationByName

def _getSurfaceControlMovableInsulationsByName(self, t_name: str, t_exactMatch: bool) -> SurfaceControlMovableInsulationVector:
    return getSurfaceControlMovableInsulationsByName(self, t_name, t_exactMatch)
Model.getSurfaceControlMovableInsulationsByName = _getSurfaceControlMovableInsulationsByName

class SurfacePropertyOtherSideCoefficients(openstudiomodelcore.ResourceObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, model: "Model"):
        _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_swiginit(self, _openstudiomodelgeometry.new_SurfacePropertyOtherSideCoefficients(model))
    __swig_destroy__ = _openstudiomodelgeometry.delete_SurfacePropertyOtherSideCoefficients

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_iddObjectType()

    def combinedConvectiveRadiativeFilmCoefficient(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_combinedConvectiveRadiativeFilmCoefficient(self)

    def constantTemperature(self) -> "double":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_constantTemperature(self)

    def isConstantTemperatureDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_isConstantTemperatureDefaulted(self)

    def constantTemperatureCoefficient(self) -> "double":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_constantTemperatureCoefficient(self)

    def isConstantTemperatureCoefficientDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_isConstantTemperatureCoefficientDefaulted(self)

    def externalDryBulbTemperatureCoefficient(self) -> "double":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_externalDryBulbTemperatureCoefficient(self)

    def isExternalDryBulbTemperatureCoefficientDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_isExternalDryBulbTemperatureCoefficientDefaulted(self)

    def groundTemperatureCoefficient(self) -> "double":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_groundTemperatureCoefficient(self)

    def isGroundTemperatureCoefficientDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_isGroundTemperatureCoefficientDefaulted(self)

    def windSpeedCoefficient(self) -> "double":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_windSpeedCoefficient(self)

    def isWindSpeedCoefficientDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_isWindSpeedCoefficientDefaulted(self)

    def zoneAirTemperatureCoefficient(self) -> "double":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_zoneAirTemperatureCoefficient(self)

    def isZoneAirTemperatureCoefficientDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_isZoneAirTemperatureCoefficientDefaulted(self)

    def constantTemperatureSchedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_constantTemperatureSchedule(self)

    def sinusoidalVariationofConstantTemperatureCoefficient(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_sinusoidalVariationofConstantTemperatureCoefficient(self)

    def isSinusoidalVariationofConstantTemperatureCoefficientDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_isSinusoidalVariationofConstantTemperatureCoefficientDefaulted(self)

    def periodofSinusoidalVariation(self) -> "double":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_periodofSinusoidalVariation(self)

    def isPeriodofSinusoidalVariationDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_isPeriodofSinusoidalVariationDefaulted(self)

    def previousOtherSideTemperatureCoefficient(self) -> "double":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_previousOtherSideTemperatureCoefficient(self)

    def isPreviousOtherSideTemperatureCoefficientDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_isPreviousOtherSideTemperatureCoefficientDefaulted(self)

    def minimumOtherSideTemperatureLimit(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_minimumOtherSideTemperatureLimit(self)

    def maximumOtherSideTemperatureLimit(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_maximumOtherSideTemperatureLimit(self)

    def setCombinedConvectiveRadiativeFilmCoefficient(self, combinedConvectiveRadiativeFilmCoefficient: "double") -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_setCombinedConvectiveRadiativeFilmCoefficient(self, combinedConvectiveRadiativeFilmCoefficient)

    def resetCombinedConvectiveRadiativeFilmCoefficient(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_resetCombinedConvectiveRadiativeFilmCoefficient(self)

    def setConstantTemperature(self, constantTemperature: "double") -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_setConstantTemperature(self, constantTemperature)

    def resetConstantTemperature(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_resetConstantTemperature(self)

    def setConstantTemperatureCoefficient(self, constantTemperatureCoefficient: "double") -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_setConstantTemperatureCoefficient(self, constantTemperatureCoefficient)

    def resetConstantTemperatureCoefficient(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_resetConstantTemperatureCoefficient(self)

    def setExternalDryBulbTemperatureCoefficient(self, externalDryBulbTemperatureCoefficient: "double") -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_setExternalDryBulbTemperatureCoefficient(self, externalDryBulbTemperatureCoefficient)

    def resetExternalDryBulbTemperatureCoefficient(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_resetExternalDryBulbTemperatureCoefficient(self)

    def setGroundTemperatureCoefficient(self, groundTemperatureCoefficient: "double") -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_setGroundTemperatureCoefficient(self, groundTemperatureCoefficient)

    def resetGroundTemperatureCoefficient(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_resetGroundTemperatureCoefficient(self)

    def setWindSpeedCoefficient(self, windSpeedCoefficient: "double") -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_setWindSpeedCoefficient(self, windSpeedCoefficient)

    def resetWindSpeedCoefficient(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_resetWindSpeedCoefficient(self)

    def setZoneAirTemperatureCoefficient(self, zoneAirTemperatureCoefficient: "double") -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_setZoneAirTemperatureCoefficient(self, zoneAirTemperatureCoefficient)

    def resetZoneAirTemperatureCoefficient(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_resetZoneAirTemperatureCoefficient(self)

    def setConstantTemperatureSchedule(self, schedule: "Schedule") -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_setConstantTemperatureSchedule(self, schedule)

    def resetConstantTemperatureSchedule(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_resetConstantTemperatureSchedule(self)

    def setSinusoidalVariationofConstantTemperatureCoefficient(self, sinusoidalVariationofConstantTemperatureCoefficient: "bool") -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_setSinusoidalVariationofConstantTemperatureCoefficient(self, sinusoidalVariationofConstantTemperatureCoefficient)

    def resetSinusoidalVariationofConstantTemperatureCoefficient(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_resetSinusoidalVariationofConstantTemperatureCoefficient(self)

    def setPeriodofSinusoidalVariation(self, periodofSinusoidalVariation: "double") -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_setPeriodofSinusoidalVariation(self, periodofSinusoidalVariation)

    def resetPeriodofSinusoidalVariation(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_resetPeriodofSinusoidalVariation(self)

    def setPreviousOtherSideTemperatureCoefficient(self, previousOtherSideTemperatureCoefficient: "double") -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_setPreviousOtherSideTemperatureCoefficient(self, previousOtherSideTemperatureCoefficient)

    def resetPreviousOtherSideTemperatureCoefficient(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_resetPreviousOtherSideTemperatureCoefficient(self)

    def setMinimumOtherSideTemperatureLimit(self, minimumOtherSideTemperatureLimit: "double") -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_setMinimumOtherSideTemperatureLimit(self, minimumOtherSideTemperatureLimit)

    def resetMinimumOtherSideTemperatureLimit(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_resetMinimumOtherSideTemperatureLimit(self)

    def setMaximumOtherSideTemperatureLimit(self, maximumOtherSideTemperatureLimit: "double") -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_setMaximumOtherSideTemperatureLimit(self, maximumOtherSideTemperatureLimit)

    def resetMaximumOtherSideTemperatureLimit(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_resetMaximumOtherSideTemperatureLimit(self)

# Register SurfacePropertyOtherSideCoefficients in _openstudiomodelgeometry:
_openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_swigregister(SurfacePropertyOtherSideCoefficients)

def SurfacePropertyOtherSideCoefficients_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_iddObjectType()


def toSurfacePropertyOtherSideCoefficients(idfObject: "IdfObject") -> "boost::optional< openstudio::model::SurfacePropertyOtherSideCoefficients >":
    return _openstudiomodelgeometry.toSurfacePropertyOtherSideCoefficients(idfObject)

def getSurfacePropertyOtherSideCoefficients(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::SurfacePropertyOtherSideCoefficients >":
    return _openstudiomodelgeometry.getSurfacePropertyOtherSideCoefficients(t_model, t_handle)

def getSurfacePropertyOtherSideCoefficientss(t_model: "Model") -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients,std::allocator< openstudio::model::SurfacePropertyOtherSideCoefficients > >":
    return _openstudiomodelgeometry.getSurfacePropertyOtherSideCoefficientss(t_model)

def getSurfacePropertyOtherSideCoefficientsByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::SurfacePropertyOtherSideCoefficients >":
    return _openstudiomodelgeometry.getSurfacePropertyOtherSideCoefficientsByName(t_model, t_name)

def getSurfacePropertyOtherSideCoefficientssByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients,std::allocator< openstudio::model::SurfacePropertyOtherSideCoefficients > >":
    return _openstudiomodelgeometry.getSurfacePropertyOtherSideCoefficientssByName(t_model, t_name, t_exactMatch)

def _to_SurfacePropertyOtherSideCoefficients(self) -> OptionalSurfacePropertyOtherSideCoefficients:
    return toSurfacePropertyOtherSideCoefficients(self)
openstudioutilitiesidf.IdfObject.to_SurfacePropertyOtherSideCoefficients = _to_SurfacePropertyOtherSideCoefficients

def _getSurfacePropertyOtherSideCoefficients(self, t_handle: "UUID") -> OptionalSurfacePropertyOtherSideCoefficients:
    return getSurfacePropertyOtherSideCoefficients(self, t_handle)
Model.getSurfacePropertyOtherSideCoefficients = _getSurfacePropertyOtherSideCoefficients

def _getSurfacePropertyOtherSideCoefficients(self, t_handle_str: str) -> OptionalSurfacePropertyOtherSideCoefficients:
    return getSurfacePropertyOtherSideCoefficients(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getSurfacePropertyOtherSideCoefficients = _getSurfacePropertyOtherSideCoefficients

def _getSurfacePropertyOtherSideCoefficientss(self) -> SurfacePropertyOtherSideCoefficientsVector:
    return getSurfacePropertyOtherSideCoefficientss(self)
Model.getSurfacePropertyOtherSideCoefficientss = _getSurfacePropertyOtherSideCoefficientss

def _getSurfacePropertyOtherSideCoefficientsByName(self, t_name: str) -> OptionalSurfacePropertyOtherSideCoefficients:
    return getSurfacePropertyOtherSideCoefficientsByName(self, t_name)
Model.getSurfacePropertyOtherSideCoefficientsByName = _getSurfacePropertyOtherSideCoefficientsByName

def _getSurfacePropertyOtherSideCoefficientssByName(self, t_name: str, t_exactMatch: bool) -> SurfacePropertyOtherSideCoefficientsVector:
    return getSurfacePropertyOtherSideCoefficientssByName(self, t_name, t_exactMatch)
Model.getSurfacePropertyOtherSideCoefficientssByName = _getSurfacePropertyOtherSideCoefficientssByName

class SurfacePropertyOtherSideConditionsModel(openstudiomodelcore.ResourceObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, model: "Model"):
        _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModel_swiginit(self, _openstudiomodelgeometry.new_SurfacePropertyOtherSideConditionsModel(model))
    __swig_destroy__ = _openstudiomodelgeometry.delete_SurfacePropertyOtherSideConditionsModel

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModel_iddObjectType()

    @staticmethod
    def typeOfModelingValues() -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModel_typeOfModelingValues()

    def typeOfModeling(self) -> "std::string":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModel_typeOfModeling(self)

    def isTypeOfModelingDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModel_isTypeOfModelingDefaulted(self)

    def setTypeOfModeling(self, typeOfModeling: "std::string const &") -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModel_setTypeOfModeling(self, typeOfModeling)

    def resetTypeOfModeling(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModel_resetTypeOfModeling(self)

# Register SurfacePropertyOtherSideConditionsModel in _openstudiomodelgeometry:
_openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModel_swigregister(SurfacePropertyOtherSideConditionsModel)

def SurfacePropertyOtherSideConditionsModel_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModel_iddObjectType()

def SurfacePropertyOtherSideConditionsModel_typeOfModelingValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModel_typeOfModelingValues()


def toSurfacePropertyOtherSideConditionsModel(idfObject: "IdfObject") -> "boost::optional< openstudio::model::SurfacePropertyOtherSideConditionsModel >":
    return _openstudiomodelgeometry.toSurfacePropertyOtherSideConditionsModel(idfObject)

def getSurfacePropertyOtherSideConditionsModel(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::SurfacePropertyOtherSideConditionsModel >":
    return _openstudiomodelgeometry.getSurfacePropertyOtherSideConditionsModel(t_model, t_handle)

def getSurfacePropertyOtherSideConditionsModels(t_model: "Model") -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel,std::allocator< openstudio::model::SurfacePropertyOtherSideConditionsModel > >":
    return _openstudiomodelgeometry.getSurfacePropertyOtherSideConditionsModels(t_model)

def getSurfacePropertyOtherSideConditionsModelByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::SurfacePropertyOtherSideConditionsModel >":
    return _openstudiomodelgeometry.getSurfacePropertyOtherSideConditionsModelByName(t_model, t_name)

def getSurfacePropertyOtherSideConditionsModelsByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel,std::allocator< openstudio::model::SurfacePropertyOtherSideConditionsModel > >":
    return _openstudiomodelgeometry.getSurfacePropertyOtherSideConditionsModelsByName(t_model, t_name, t_exactMatch)

def _to_SurfacePropertyOtherSideConditionsModel(self) -> OptionalSurfacePropertyOtherSideConditionsModel:
    return toSurfacePropertyOtherSideConditionsModel(self)
openstudioutilitiesidf.IdfObject.to_SurfacePropertyOtherSideConditionsModel = _to_SurfacePropertyOtherSideConditionsModel

def _getSurfacePropertyOtherSideConditionsModel(self, t_handle: "UUID") -> OptionalSurfacePropertyOtherSideConditionsModel:
    return getSurfacePropertyOtherSideConditionsModel(self, t_handle)
Model.getSurfacePropertyOtherSideConditionsModel = _getSurfacePropertyOtherSideConditionsModel

def _getSurfacePropertyOtherSideConditionsModel(self, t_handle_str: str) -> OptionalSurfacePropertyOtherSideConditionsModel:
    return getSurfacePropertyOtherSideConditionsModel(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getSurfacePropertyOtherSideConditionsModel = _getSurfacePropertyOtherSideConditionsModel

def _getSurfacePropertyOtherSideConditionsModels(self) -> SurfacePropertyOtherSideConditionsModelVector:
    return getSurfacePropertyOtherSideConditionsModels(self)
Model.getSurfacePropertyOtherSideConditionsModels = _getSurfacePropertyOtherSideConditionsModels

def _getSurfacePropertyOtherSideConditionsModelByName(self, t_name: str) -> OptionalSurfacePropertyOtherSideConditionsModel:
    return getSurfacePropertyOtherSideConditionsModelByName(self, t_name)
Model.getSurfacePropertyOtherSideConditionsModelByName = _getSurfacePropertyOtherSideConditionsModelByName

def _getSurfacePropertyOtherSideConditionsModelsByName(self, t_name: str, t_exactMatch: bool) -> SurfacePropertyOtherSideConditionsModelVector:
    return getSurfacePropertyOtherSideConditionsModelsByName(self, t_name, t_exactMatch)
Model.getSurfacePropertyOtherSideConditionsModelsByName = _getSurfacePropertyOtherSideConditionsModelsByName

class SurfacePropertyConvectionCoefficients(openstudiomodelcore.ModelObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_swiginit(self, _openstudiomodelgeometry.new_SurfacePropertyConvectionCoefficients(*args))
    __swig_destroy__ = _openstudiomodelgeometry.delete_SurfacePropertyConvectionCoefficients

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_iddObjectType()

    @staticmethod
    def convectionCoefficient1LocationValues() -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient1LocationValues()

    @staticmethod
    def convectionCoefficient1TypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient1TypeValues()

    @staticmethod
    def convectionCoefficient2LocationValues() -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient2LocationValues()

    @staticmethod
    def convectionCoefficient2TypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient2TypeValues()

    def surfaceAsModelObject(self) -> "openstudio::model::ModelObject":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_surfaceAsModelObject(self)

    def surfaceAsSurface(self) -> "boost::optional< openstudio::model::Surface >":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_surfaceAsSurface(self)

    def surfaceAsSubSurface(self) -> "boost::optional< openstudio::model::SubSurface >":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_surfaceAsSubSurface(self)

    def surfaceAsInternalMass(self) -> "boost::optional< openstudio::model::InternalMass >":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_surfaceAsInternalMass(self)

    def convectionCoefficient1Location(self) -> "boost::optional< std::string >":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient1Location(self)

    def convectionCoefficient1Type(self) -> "boost::optional< std::string >":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient1Type(self)

    def convectionCoefficient1(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient1(self)

    def convectionCoefficient1Schedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient1Schedule(self)

    def convectionCoefficient2Location(self) -> "boost::optional< std::string >":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient2Location(self)

    def convectionCoefficient2Type(self) -> "boost::optional< std::string >":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient2Type(self)

    def convectionCoefficient2(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient2(self)

    def convectionCoefficient2Schedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient2Schedule(self)

    def setSurface(self, surface: "ModelObject") -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_setSurface(self, surface)

    def setConvectionCoefficient1Location(self, convectionCoefficient1Location: "std::string const &") -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_setConvectionCoefficient1Location(self, convectionCoefficient1Location)

    def resetConvectionCoefficient1Location(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_resetConvectionCoefficient1Location(self)

    def setConvectionCoefficient1Type(self, convectionCoefficient1Type: "std::string const &") -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_setConvectionCoefficient1Type(self, convectionCoefficient1Type)

    def resetConvectionCoefficient1Type(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_resetConvectionCoefficient1Type(self)

    def setConvectionCoefficient1(self, convectionCoefficient1: "double") -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_setConvectionCoefficient1(self, convectionCoefficient1)

    def resetConvectionCoefficient1(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_resetConvectionCoefficient1(self)

    def setConvectionCoefficient1Schedule(self, schedule: "Schedule") -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_setConvectionCoefficient1Schedule(self, schedule)

    def resetConvectionCoefficient1Schedule(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_resetConvectionCoefficient1Schedule(self)

    def setConvectionCoefficient2Location(self, convectionCoefficient2Location: "std::string const &") -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_setConvectionCoefficient2Location(self, convectionCoefficient2Location)

    def resetConvectionCoefficient2Location(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_resetConvectionCoefficient2Location(self)

    def setConvectionCoefficient2Type(self, convectionCoefficient2Type: "std::string const &") -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_setConvectionCoefficient2Type(self, convectionCoefficient2Type)

    def resetConvectionCoefficient2Type(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_resetConvectionCoefficient2Type(self)

    def setConvectionCoefficient2(self, convectionCoefficient2: "double") -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_setConvectionCoefficient2(self, convectionCoefficient2)

    def resetConvectionCoefficient2(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_resetConvectionCoefficient2(self)

    def setConvectionCoefficient2Schedule(self, schedule: "Schedule") -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_setConvectionCoefficient2Schedule(self, schedule)

    def resetConvectionCoefficient2Schedule(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_resetConvectionCoefficient2Schedule(self)

# Register SurfacePropertyConvectionCoefficients in _openstudiomodelgeometry:
_openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_swigregister(SurfacePropertyConvectionCoefficients)

def SurfacePropertyConvectionCoefficients_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_iddObjectType()

def SurfacePropertyConvectionCoefficients_convectionCoefficient1LocationValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient1LocationValues()

def SurfacePropertyConvectionCoefficients_convectionCoefficient1TypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient1TypeValues()

def SurfacePropertyConvectionCoefficients_convectionCoefficient2LocationValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient2LocationValues()

def SurfacePropertyConvectionCoefficients_convectionCoefficient2TypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient2TypeValues()


def toSurfacePropertyConvectionCoefficients(idfObject: "IdfObject") -> "boost::optional< openstudio::model::SurfacePropertyConvectionCoefficients >":
    return _openstudiomodelgeometry.toSurfacePropertyConvectionCoefficients(idfObject)

def getSurfacePropertyConvectionCoefficients(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::SurfacePropertyConvectionCoefficients >":
    return _openstudiomodelgeometry.getSurfacePropertyConvectionCoefficients(t_model, t_handle)

def getSurfacePropertyConvectionCoefficientss(t_model: "Model") -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients,std::allocator< openstudio::model::SurfacePropertyConvectionCoefficients > >":
    return _openstudiomodelgeometry.getSurfacePropertyConvectionCoefficientss(t_model)

def getSurfacePropertyConvectionCoefficientsByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::SurfacePropertyConvectionCoefficients >":
    return _openstudiomodelgeometry.getSurfacePropertyConvectionCoefficientsByName(t_model, t_name)

def getSurfacePropertyConvectionCoefficientssByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients,std::allocator< openstudio::model::SurfacePropertyConvectionCoefficients > >":
    return _openstudiomodelgeometry.getSurfacePropertyConvectionCoefficientssByName(t_model, t_name, t_exactMatch)

def _to_SurfacePropertyConvectionCoefficients(self) -> OptionalSurfacePropertyConvectionCoefficients:
    return toSurfacePropertyConvectionCoefficients(self)
openstudioutilitiesidf.IdfObject.to_SurfacePropertyConvectionCoefficients = _to_SurfacePropertyConvectionCoefficients

def _getSurfacePropertyConvectionCoefficients(self, t_handle: "UUID") -> OptionalSurfacePropertyConvectionCoefficients:
    return getSurfacePropertyConvectionCoefficients(self, t_handle)
Model.getSurfacePropertyConvectionCoefficients = _getSurfacePropertyConvectionCoefficients

def _getSurfacePropertyConvectionCoefficients(self, t_handle_str: str) -> OptionalSurfacePropertyConvectionCoefficients:
    return getSurfacePropertyConvectionCoefficients(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getSurfacePropertyConvectionCoefficients = _getSurfacePropertyConvectionCoefficients

def _getSurfacePropertyConvectionCoefficientss(self) -> SurfacePropertyConvectionCoefficientsVector:
    return getSurfacePropertyConvectionCoefficientss(self)
Model.getSurfacePropertyConvectionCoefficientss = _getSurfacePropertyConvectionCoefficientss

def _getSurfacePropertyConvectionCoefficientsByName(self, t_name: str) -> OptionalSurfacePropertyConvectionCoefficients:
    return getSurfacePropertyConvectionCoefficientsByName(self, t_name)
Model.getSurfacePropertyConvectionCoefficientsByName = _getSurfacePropertyConvectionCoefficientsByName

def _getSurfacePropertyConvectionCoefficientssByName(self, t_name: str, t_exactMatch: bool) -> SurfacePropertyConvectionCoefficientsVector:
    return getSurfacePropertyConvectionCoefficientssByName(self, t_name, t_exactMatch)
Model.getSurfacePropertyConvectionCoefficientssByName = _getSurfacePropertyConvectionCoefficientssByName

class People(SpaceLoadInstance):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, peopleDefinition: "PeopleDefinition"):
        _openstudiomodelgeometry.People_swiginit(self, _openstudiomodelgeometry.new_People(peopleDefinition))
    __swig_destroy__ = _openstudiomodelgeometry.delete_People

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.People_iddObjectType()

    def peopleDefinition(self) -> "openstudio::model::PeopleDefinition":
        return _openstudiomodelgeometry.People_peopleDefinition(self)

    def numberofPeopleSchedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.People_numberofPeopleSchedule(self)

    def isNumberofPeopleScheduleDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.People_isNumberofPeopleScheduleDefaulted(self)

    def activityLevelSchedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.People_activityLevelSchedule(self)

    def isActivityLevelScheduleDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.People_isActivityLevelScheduleDefaulted(self)

    def workEfficiencySchedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.People_workEfficiencySchedule(self)

    def clothingInsulationSchedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.People_clothingInsulationSchedule(self)

    def airVelocitySchedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.People_airVelocitySchedule(self)

    def setPeopleDefinition(self, definition: "PeopleDefinition") -> "bool":
        return _openstudiomodelgeometry.People_setPeopleDefinition(self, definition)

    def setNumberofPeopleSchedule(self, schedule: "Schedule") -> "bool":
        return _openstudiomodelgeometry.People_setNumberofPeopleSchedule(self, schedule)

    def resetNumberofPeopleSchedule(self) -> "void":
        return _openstudiomodelgeometry.People_resetNumberofPeopleSchedule(self)

    def setActivityLevelSchedule(self, schedule: "Schedule") -> "bool":
        return _openstudiomodelgeometry.People_setActivityLevelSchedule(self, schedule)

    def resetActivityLevelSchedule(self) -> "void":
        return _openstudiomodelgeometry.People_resetActivityLevelSchedule(self)

    def setWorkEfficiencySchedule(self, schedule: "Schedule") -> "bool":
        return _openstudiomodelgeometry.People_setWorkEfficiencySchedule(self, schedule)

    def resetWorkEfficiencySchedule(self) -> "void":
        return _openstudiomodelgeometry.People_resetWorkEfficiencySchedule(self)

    def setClothingInsulationSchedule(self, schedule: "Schedule") -> "bool":
        return _openstudiomodelgeometry.People_setClothingInsulationSchedule(self, schedule)

    def resetClothingInsulationSchedule(self) -> "void":
        return _openstudiomodelgeometry.People_resetClothingInsulationSchedule(self)

    def setAirVelocitySchedule(self, schedule: "Schedule") -> "bool":
        return _openstudiomodelgeometry.People_setAirVelocitySchedule(self, schedule)

    def resetAirVelocitySchedule(self) -> "void":
        return _openstudiomodelgeometry.People_resetAirVelocitySchedule(self)

    def setMultiplier(self, multiplier: "double") -> "bool":
        return _openstudiomodelgeometry.People_setMultiplier(self, multiplier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.People_resetMultiplier(self)

    def numberOfPeople(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.People_numberOfPeople(self)

    def peoplePerFloorArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.People_peoplePerFloorArea(self)

    def spaceFloorAreaPerPerson(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.People_spaceFloorAreaPerPerson(self)

    def getNumberOfPeople(self, floorArea: "double") -> "double":
        return _openstudiomodelgeometry.People_getNumberOfPeople(self, floorArea)

    def getPeoplePerFloorArea(self, floorArea: "double") -> "double":
        return _openstudiomodelgeometry.People_getPeoplePerFloorArea(self, floorArea)

    def getFloorAreaPerPerson(self, floorArea: "double") -> "double":
        return _openstudiomodelgeometry.People_getFloorAreaPerPerson(self, floorArea)

# Register People in _openstudiomodelgeometry:
_openstudiomodelgeometry.People_swigregister(People)

def People_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.People_iddObjectType()


def toPeople(idfObject: "IdfObject") -> "boost::optional< openstudio::model::People >":
    return _openstudiomodelgeometry.toPeople(idfObject)

def getPeople(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::People >":
    return _openstudiomodelgeometry.getPeople(t_model, t_handle)

def getPeoples(t_model: "Model") -> "std::vector< openstudio::model::People,std::allocator< openstudio::model::People > >":
    return _openstudiomodelgeometry.getPeoples(t_model)

def getPeopleByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::People >":
    return _openstudiomodelgeometry.getPeopleByName(t_model, t_name)

def getPeoplesByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::People,std::allocator< openstudio::model::People > >":
    return _openstudiomodelgeometry.getPeoplesByName(t_model, t_name, t_exactMatch)

def _to_People(self) -> OptionalPeople:
    return toPeople(self)
openstudioutilitiesidf.IdfObject.to_People = _to_People

def _getPeople(self, t_handle: "UUID") -> OptionalPeople:
    return getPeople(self, t_handle)
Model.getPeople = _getPeople

def _getPeople(self, t_handle_str: str) -> OptionalPeople:
    return getPeople(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getPeople = _getPeople

def _getPeoples(self) -> PeopleVector:
    return getPeoples(self)
Model.getPeoples = _getPeoples

def _getPeopleByName(self, t_name: str) -> OptionalPeople:
    return getPeopleByName(self, t_name)
Model.getPeopleByName = _getPeopleByName

def _getPeoplesByName(self, t_name: str, t_exactMatch: bool) -> PeopleVector:
    return getPeoplesByName(self, t_name, t_exactMatch)
Model.getPeoplesByName = _getPeoplesByName

class Luminaire(SpaceLoadInstance):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, luminaireDefinition: "LuminaireDefinition"):
        _openstudiomodelgeometry.Luminaire_swiginit(self, _openstudiomodelgeometry.new_Luminaire(luminaireDefinition))
    __swig_destroy__ = _openstudiomodelgeometry.delete_Luminaire

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.Luminaire_iddObjectType()

    def luminaireDefinition(self) -> "openstudio::model::LuminaireDefinition":
        return _openstudiomodelgeometry.Luminaire_luminaireDefinition(self)

    def schedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.Luminaire_schedule(self)

    def isScheduleDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Luminaire_isScheduleDefaulted(self)

    def positionXcoordinate(self) -> "double":
        return _openstudiomodelgeometry.Luminaire_positionXcoordinate(self)

    def positionYcoordinate(self) -> "double":
        return _openstudiomodelgeometry.Luminaire_positionYcoordinate(self)

    def positionZcoordinate(self) -> "double":
        return _openstudiomodelgeometry.Luminaire_positionZcoordinate(self)

    def psiRotationAroundXaxis(self) -> "double":
        return _openstudiomodelgeometry.Luminaire_psiRotationAroundXaxis(self)

    def isPsiRotationAroundXaxisDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Luminaire_isPsiRotationAroundXaxisDefaulted(self)

    def thetaRotationAroundYaxis(self) -> "double":
        return _openstudiomodelgeometry.Luminaire_thetaRotationAroundYaxis(self)

    def isThetaRotationAroundYaxisDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Luminaire_isThetaRotationAroundYaxisDefaulted(self)

    def phiRotationAroundZaxis(self) -> "double":
        return _openstudiomodelgeometry.Luminaire_phiRotationAroundZaxis(self)

    def isPhiRotationAroundZaxisDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Luminaire_isPhiRotationAroundZaxisDefaulted(self)

    def fractionReplaceable(self) -> "double":
        return _openstudiomodelgeometry.Luminaire_fractionReplaceable(self)

    def isFractionReplaceableDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Luminaire_isFractionReplaceableDefaulted(self)

    def endUseSubcategory(self) -> "std::string":
        return _openstudiomodelgeometry.Luminaire_endUseSubcategory(self)

    def isEndUseSubcategoryDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Luminaire_isEndUseSubcategoryDefaulted(self)

    def setLuminaireDefinition(self, definition: "LuminaireDefinition") -> "bool":
        return _openstudiomodelgeometry.Luminaire_setLuminaireDefinition(self, definition)

    def setSchedule(self, schedule: "Schedule") -> "bool":
        return _openstudiomodelgeometry.Luminaire_setSchedule(self, schedule)

    def resetSchedule(self) -> "void":
        return _openstudiomodelgeometry.Luminaire_resetSchedule(self)

    def setPositionXcoordinate(self, positionXcoordinate: "double") -> "bool":
        return _openstudiomodelgeometry.Luminaire_setPositionXcoordinate(self, positionXcoordinate)

    def setPositionYcoordinate(self, positionYcoordinate: "double") -> "bool":
        return _openstudiomodelgeometry.Luminaire_setPositionYcoordinate(self, positionYcoordinate)

    def setPositionZcoordinate(self, positionZcoordinate: "double") -> "bool":
        return _openstudiomodelgeometry.Luminaire_setPositionZcoordinate(self, positionZcoordinate)

    def setPsiRotationAroundXaxis(self, psiRotationAroundXaxis: "double") -> "bool":
        return _openstudiomodelgeometry.Luminaire_setPsiRotationAroundXaxis(self, psiRotationAroundXaxis)

    def resetPsiRotationAroundXaxis(self) -> "void":
        return _openstudiomodelgeometry.Luminaire_resetPsiRotationAroundXaxis(self)

    def setThetaRotationAroundYaxis(self, thetaRotationAroundYaxis: "double") -> "bool":
        return _openstudiomodelgeometry.Luminaire_setThetaRotationAroundYaxis(self, thetaRotationAroundYaxis)

    def resetThetaRotationAroundYaxis(self) -> "void":
        return _openstudiomodelgeometry.Luminaire_resetThetaRotationAroundYaxis(self)

    def setPhiRotationAroundZaxis(self, phiRotationAroundZaxis: "double") -> "bool":
        return _openstudiomodelgeometry.Luminaire_setPhiRotationAroundZaxis(self, phiRotationAroundZaxis)

    def resetPhiRotationAroundZaxis(self) -> "void":
        return _openstudiomodelgeometry.Luminaire_resetPhiRotationAroundZaxis(self)

    def setFractionReplaceable(self, fractionReplaceable: "double") -> "bool":
        return _openstudiomodelgeometry.Luminaire_setFractionReplaceable(self, fractionReplaceable)

    def resetFractionReplaceable(self) -> "void":
        return _openstudiomodelgeometry.Luminaire_resetFractionReplaceable(self)

    def setMultiplier(self, multiplier: "double") -> "bool":
        return _openstudiomodelgeometry.Luminaire_setMultiplier(self, multiplier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.Luminaire_resetMultiplier(self)

    def setEndUseSubcategory(self, endUseSubcategory: "std::string") -> "bool":
        return _openstudiomodelgeometry.Luminaire_setEndUseSubcategory(self, endUseSubcategory)

    def resetEndUseSubcategory(self) -> "void":
        return _openstudiomodelgeometry.Luminaire_resetEndUseSubcategory(self)

    def position(self) -> "openstudio::Point3d":
        return _openstudiomodelgeometry.Luminaire_position(self)

    def setPosition(self, position: "Point3d") -> "bool":
        return _openstudiomodelgeometry.Luminaire_setPosition(self, position)

    def transformation(self) -> "openstudio::Transformation":
        return _openstudiomodelgeometry.Luminaire_transformation(self)

    def setTransformation(self, transformation: "Transformation") -> "bool":
        return _openstudiomodelgeometry.Luminaire_setTransformation(self, transformation)

    def lightingPower(self) -> "double":
        return _openstudiomodelgeometry.Luminaire_lightingPower(self)

    def getPowerPerFloorArea(self, floorArea: "double") -> "double":
        return _openstudiomodelgeometry.Luminaire_getPowerPerFloorArea(self, floorArea)

    def getPowerPerPerson(self, numPeople: "double") -> "double":
        return _openstudiomodelgeometry.Luminaire_getPowerPerPerson(self, numPeople)

# Register Luminaire in _openstudiomodelgeometry:
_openstudiomodelgeometry.Luminaire_swigregister(Luminaire)

def Luminaire_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.Luminaire_iddObjectType()


def toLuminaire(idfObject: "IdfObject") -> "boost::optional< openstudio::model::Luminaire >":
    return _openstudiomodelgeometry.toLuminaire(idfObject)

def getLuminaire(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::Luminaire >":
    return _openstudiomodelgeometry.getLuminaire(t_model, t_handle)

def getLuminaires(t_model: "Model") -> "std::vector< openstudio::model::Luminaire,std::allocator< openstudio::model::Luminaire > >":
    return _openstudiomodelgeometry.getLuminaires(t_model)

def getLuminaireByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::Luminaire >":
    return _openstudiomodelgeometry.getLuminaireByName(t_model, t_name)

def getLuminairesByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::Luminaire,std::allocator< openstudio::model::Luminaire > >":
    return _openstudiomodelgeometry.getLuminairesByName(t_model, t_name, t_exactMatch)

def _to_Luminaire(self) -> OptionalLuminaire:
    return toLuminaire(self)
openstudioutilitiesidf.IdfObject.to_Luminaire = _to_Luminaire

def _getLuminaire(self, t_handle: "UUID") -> OptionalLuminaire:
    return getLuminaire(self, t_handle)
Model.getLuminaire = _getLuminaire

def _getLuminaire(self, t_handle_str: str) -> OptionalLuminaire:
    return getLuminaire(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getLuminaire = _getLuminaire

def _getLuminaires(self) -> LuminaireVector:
    return getLuminaires(self)
Model.getLuminaires = _getLuminaires

def _getLuminaireByName(self, t_name: str) -> OptionalLuminaire:
    return getLuminaireByName(self, t_name)
Model.getLuminaireByName = _getLuminaireByName

def _getLuminairesByName(self, t_name: str, t_exactMatch: bool) -> LuminaireVector:
    return getLuminairesByName(self, t_name, t_exactMatch)
Model.getLuminairesByName = _getLuminairesByName

class ElectricEquipment(SpaceLoadInstance):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, electricEquipmentDefinition: "ElectricEquipmentDefinition"):
        _openstudiomodelgeometry.ElectricEquipment_swiginit(self, _openstudiomodelgeometry.new_ElectricEquipment(electricEquipmentDefinition))
    __swig_destroy__ = _openstudiomodelgeometry.delete_ElectricEquipment

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.ElectricEquipment_iddObjectType()

    def electricEquipmentDefinition(self) -> "openstudio::model::ElectricEquipmentDefinition":
        return _openstudiomodelgeometry.ElectricEquipment_electricEquipmentDefinition(self)

    def schedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.ElectricEquipment_schedule(self)

    def isScheduleDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.ElectricEquipment_isScheduleDefaulted(self)

    def endUseSubcategory(self) -> "std::string":
        return _openstudiomodelgeometry.ElectricEquipment_endUseSubcategory(self)

    def isEndUseSubcategoryDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.ElectricEquipment_isEndUseSubcategoryDefaulted(self)

    def setElectricEquipmentDefinition(self, definition: "ElectricEquipmentDefinition") -> "bool":
        return _openstudiomodelgeometry.ElectricEquipment_setElectricEquipmentDefinition(self, definition)

    def setSchedule(self, schedule: "Schedule") -> "bool":
        return _openstudiomodelgeometry.ElectricEquipment_setSchedule(self, schedule)

    def resetSchedule(self) -> "void":
        return _openstudiomodelgeometry.ElectricEquipment_resetSchedule(self)

    def setMultiplier(self, multiplier: "double") -> "bool":
        return _openstudiomodelgeometry.ElectricEquipment_setMultiplier(self, multiplier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.ElectricEquipment_resetMultiplier(self)

    def setEndUseSubcategory(self, endUseSubcategory: "std::string") -> "bool":
        return _openstudiomodelgeometry.ElectricEquipment_setEndUseSubcategory(self, endUseSubcategory)

    def resetEndUseSubcategory(self) -> "void":
        return _openstudiomodelgeometry.ElectricEquipment_resetEndUseSubcategory(self)

    def designLevel(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.ElectricEquipment_designLevel(self)

    def powerPerFloorArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.ElectricEquipment_powerPerFloorArea(self)

    def powerPerPerson(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.ElectricEquipment_powerPerPerson(self)

    def getDesignLevel(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.ElectricEquipment_getDesignLevel(self, floorArea, numPeople)

    def getPowerPerFloorArea(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.ElectricEquipment_getPowerPerFloorArea(self, floorArea, numPeople)

    def getPowerPerPerson(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.ElectricEquipment_getPowerPerPerson(self, floorArea, numPeople)

# Register ElectricEquipment in _openstudiomodelgeometry:
_openstudiomodelgeometry.ElectricEquipment_swigregister(ElectricEquipment)

def ElectricEquipment_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.ElectricEquipment_iddObjectType()


def toElectricEquipment(idfObject: "IdfObject") -> "boost::optional< openstudio::model::ElectricEquipment >":
    return _openstudiomodelgeometry.toElectricEquipment(idfObject)

def getElectricEquipment(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::ElectricEquipment >":
    return _openstudiomodelgeometry.getElectricEquipment(t_model, t_handle)

def getElectricEquipments(t_model: "Model") -> "std::vector< openstudio::model::ElectricEquipment,std::allocator< openstudio::model::ElectricEquipment > >":
    return _openstudiomodelgeometry.getElectricEquipments(t_model)

def getElectricEquipmentByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::ElectricEquipment >":
    return _openstudiomodelgeometry.getElectricEquipmentByName(t_model, t_name)

def getElectricEquipmentsByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::ElectricEquipment,std::allocator< openstudio::model::ElectricEquipment > >":
    return _openstudiomodelgeometry.getElectricEquipmentsByName(t_model, t_name, t_exactMatch)

def _to_ElectricEquipment(self) -> OptionalElectricEquipment:
    return toElectricEquipment(self)
openstudioutilitiesidf.IdfObject.to_ElectricEquipment = _to_ElectricEquipment

def _getElectricEquipment(self, t_handle: "UUID") -> OptionalElectricEquipment:
    return getElectricEquipment(self, t_handle)
Model.getElectricEquipment = _getElectricEquipment

def _getElectricEquipment(self, t_handle_str: str) -> OptionalElectricEquipment:
    return getElectricEquipment(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getElectricEquipment = _getElectricEquipment

def _getElectricEquipments(self) -> ElectricEquipmentVector:
    return getElectricEquipments(self)
Model.getElectricEquipments = _getElectricEquipments

def _getElectricEquipmentByName(self, t_name: str) -> OptionalElectricEquipment:
    return getElectricEquipmentByName(self, t_name)
Model.getElectricEquipmentByName = _getElectricEquipmentByName

def _getElectricEquipmentsByName(self, t_name: str, t_exactMatch: bool) -> ElectricEquipmentVector:
    return getElectricEquipmentsByName(self, t_name, t_exactMatch)
Model.getElectricEquipmentsByName = _getElectricEquipmentsByName

class ElectricEquipmentITEAirCooled(SpaceLoadInstance):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, electricEquipmentITEAirCooledDefinition: "ElectricEquipmentITEAirCooledDefinition"):
        _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_swiginit(self, _openstudiomodelgeometry.new_ElectricEquipmentITEAirCooled(electricEquipmentITEAirCooledDefinition))
    __swig_destroy__ = _openstudiomodelgeometry.delete_ElectricEquipmentITEAirCooled

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_iddObjectType()

    def electricEquipmentITEAirCooledDefinition(self) -> "openstudio::model::ElectricEquipmentITEAirCooledDefinition":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_electricEquipmentITEAirCooledDefinition(self)

    def designPowerInputSchedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_designPowerInputSchedule(self)

    def isDesignPowerInputScheduleDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_isDesignPowerInputScheduleDefaulted(self)

    def cPULoadingSchedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_cPULoadingSchedule(self)

    def isCPULoadingScheduleDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_isCPULoadingScheduleDefaulted(self)

    def cPUEndUseSubcategory(self) -> "std::string":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_cPUEndUseSubcategory(self)

    def isCPUEndUseSubcategoryDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_isCPUEndUseSubcategoryDefaulted(self)

    def fanEndUseSubcategory(self) -> "std::string":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_fanEndUseSubcategory(self)

    def isFanEndUseSubcategoryDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_isFanEndUseSubcategoryDefaulted(self)

    def electricPowerSupplyEndUseSubcategory(self) -> "std::string":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_electricPowerSupplyEndUseSubcategory(self)

    def isElectricPowerSupplyEndUseSubcategoryDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_isElectricPowerSupplyEndUseSubcategoryDefaulted(self)

    def setElectricEquipmentITEAirCooledDefinition(self, electricEquipmentITEAirCooledDefinition: "ElectricEquipmentITEAirCooledDefinition") -> "bool":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_setElectricEquipmentITEAirCooledDefinition(self, electricEquipmentITEAirCooledDefinition)

    def setDesignPowerInputSchedule(self, schedule: "Schedule") -> "bool":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_setDesignPowerInputSchedule(self, schedule)

    def resetDesignPowerInputSchedule(self) -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_resetDesignPowerInputSchedule(self)

    def setCPULoadingSchedule(self, schedule: "Schedule") -> "bool":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_setCPULoadingSchedule(self, schedule)

    def resetCPULoadingSchedule(self) -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_resetCPULoadingSchedule(self)

    def setMultiplier(self, multiplier: "double") -> "bool":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_setMultiplier(self, multiplier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_resetMultiplier(self)

    def setCPUEndUseSubcategory(self, cPUEndUseSubcategory: "std::string const &") -> "bool":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_setCPUEndUseSubcategory(self, cPUEndUseSubcategory)

    def resetCPUEndUseSubcategory(self) -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_resetCPUEndUseSubcategory(self)

    def setFanEndUseSubcategory(self, fanEndUseSubcategory: "std::string const &") -> "bool":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_setFanEndUseSubcategory(self, fanEndUseSubcategory)

    def resetFanEndUseSubcategory(self) -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_resetFanEndUseSubcategory(self)

    def setElectricPowerSupplyEndUseSubcategory(self, electricPowerSupplyEndUseSubcategory: "std::string const &") -> "bool":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_setElectricPowerSupplyEndUseSubcategory(self, electricPowerSupplyEndUseSubcategory)

    def resetElectricPowerSupplyEndUseSubcategory(self) -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_resetElectricPowerSupplyEndUseSubcategory(self)

    def wattsperUnit(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_wattsperUnit(self)

    def wattsperZoneFloorArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_wattsperZoneFloorArea(self)

    def getWattsperUnit(self, floorArea: "double") -> "double":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_getWattsperUnit(self, floorArea)

    def getWattsperZoneFloorArea(self, floorArea: "double") -> "double":
        return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_getWattsperZoneFloorArea(self, floorArea)

# Register ElectricEquipmentITEAirCooled in _openstudiomodelgeometry:
_openstudiomodelgeometry.ElectricEquipmentITEAirCooled_swigregister(ElectricEquipmentITEAirCooled)

def ElectricEquipmentITEAirCooled_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.ElectricEquipmentITEAirCooled_iddObjectType()


def toElectricEquipmentITEAirCooled(idfObject: "IdfObject") -> "boost::optional< openstudio::model::ElectricEquipmentITEAirCooled >":
    return _openstudiomodelgeometry.toElectricEquipmentITEAirCooled(idfObject)

def getElectricEquipmentITEAirCooled(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::ElectricEquipmentITEAirCooled >":
    return _openstudiomodelgeometry.getElectricEquipmentITEAirCooled(t_model, t_handle)

def getElectricEquipmentITEAirCooleds(t_model: "Model") -> "std::vector< openstudio::model::ElectricEquipmentITEAirCooled,std::allocator< openstudio::model::ElectricEquipmentITEAirCooled > >":
    return _openstudiomodelgeometry.getElectricEquipmentITEAirCooleds(t_model)

def getElectricEquipmentITEAirCooledByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::ElectricEquipmentITEAirCooled >":
    return _openstudiomodelgeometry.getElectricEquipmentITEAirCooledByName(t_model, t_name)

def getElectricEquipmentITEAirCooledsByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::ElectricEquipmentITEAirCooled,std::allocator< openstudio::model::ElectricEquipmentITEAirCooled > >":
    return _openstudiomodelgeometry.getElectricEquipmentITEAirCooledsByName(t_model, t_name, t_exactMatch)

def _to_ElectricEquipmentITEAirCooled(self) -> OptionalElectricEquipmentITEAirCooled:
    return toElectricEquipmentITEAirCooled(self)
openstudioutilitiesidf.IdfObject.to_ElectricEquipmentITEAirCooled = _to_ElectricEquipmentITEAirCooled

def _getElectricEquipmentITEAirCooled(self, t_handle: "UUID") -> OptionalElectricEquipmentITEAirCooled:
    return getElectricEquipmentITEAirCooled(self, t_handle)
Model.getElectricEquipmentITEAirCooled = _getElectricEquipmentITEAirCooled

def _getElectricEquipmentITEAirCooled(self, t_handle_str: str) -> OptionalElectricEquipmentITEAirCooled:
    return getElectricEquipmentITEAirCooled(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getElectricEquipmentITEAirCooled = _getElectricEquipmentITEAirCooled

def _getElectricEquipmentITEAirCooleds(self) -> ElectricEquipmentITEAirCooledVector:
    return getElectricEquipmentITEAirCooleds(self)
Model.getElectricEquipmentITEAirCooleds = _getElectricEquipmentITEAirCooleds

def _getElectricEquipmentITEAirCooledByName(self, t_name: str) -> OptionalElectricEquipmentITEAirCooled:
    return getElectricEquipmentITEAirCooledByName(self, t_name)
Model.getElectricEquipmentITEAirCooledByName = _getElectricEquipmentITEAirCooledByName

def _getElectricEquipmentITEAirCooledsByName(self, t_name: str, t_exactMatch: bool) -> ElectricEquipmentITEAirCooledVector:
    return getElectricEquipmentITEAirCooledsByName(self, t_name, t_exactMatch)
Model.getElectricEquipmentITEAirCooledsByName = _getElectricEquipmentITEAirCooledsByName

class GasEquipment(SpaceLoadInstance):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, gasEquipmentDefinition: "GasEquipmentDefinition"):
        _openstudiomodelgeometry.GasEquipment_swiginit(self, _openstudiomodelgeometry.new_GasEquipment(gasEquipmentDefinition))
    __swig_destroy__ = _openstudiomodelgeometry.delete_GasEquipment

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.GasEquipment_iddObjectType()

    def gasEquipmentDefinition(self) -> "openstudio::model::GasEquipmentDefinition":
        return _openstudiomodelgeometry.GasEquipment_gasEquipmentDefinition(self)

    def schedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.GasEquipment_schedule(self)

    def isScheduleDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.GasEquipment_isScheduleDefaulted(self)

    def endUseSubcategory(self) -> "std::string":
        return _openstudiomodelgeometry.GasEquipment_endUseSubcategory(self)

    def isEndUseSubcategoryDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.GasEquipment_isEndUseSubcategoryDefaulted(self)

    def setGasEquipmentDefinition(self, definition: "GasEquipmentDefinition") -> "bool":
        return _openstudiomodelgeometry.GasEquipment_setGasEquipmentDefinition(self, definition)

    def setSchedule(self, schedule: "Schedule") -> "bool":
        return _openstudiomodelgeometry.GasEquipment_setSchedule(self, schedule)

    def resetSchedule(self) -> "void":
        return _openstudiomodelgeometry.GasEquipment_resetSchedule(self)

    def setMultiplier(self, multiplier: "double") -> "bool":
        return _openstudiomodelgeometry.GasEquipment_setMultiplier(self, multiplier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.GasEquipment_resetMultiplier(self)

    def setEndUseSubcategory(self, endUseSubcategory: "std::string") -> "bool":
        return _openstudiomodelgeometry.GasEquipment_setEndUseSubcategory(self, endUseSubcategory)

    def resetEndUseSubcategory(self) -> "void":
        return _openstudiomodelgeometry.GasEquipment_resetEndUseSubcategory(self)

    def designLevel(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.GasEquipment_designLevel(self)

    def powerPerFloorArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.GasEquipment_powerPerFloorArea(self)

    def powerPerPerson(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.GasEquipment_powerPerPerson(self)

    def getDesignLevel(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.GasEquipment_getDesignLevel(self, floorArea, numPeople)

    def getPowerPerFloorArea(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.GasEquipment_getPowerPerFloorArea(self, floorArea, numPeople)

    def getPowerPerPerson(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.GasEquipment_getPowerPerPerson(self, floorArea, numPeople)

# Register GasEquipment in _openstudiomodelgeometry:
_openstudiomodelgeometry.GasEquipment_swigregister(GasEquipment)

def GasEquipment_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.GasEquipment_iddObjectType()


def toGasEquipment(idfObject: "IdfObject") -> "boost::optional< openstudio::model::GasEquipment >":
    return _openstudiomodelgeometry.toGasEquipment(idfObject)

def getGasEquipment(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::GasEquipment >":
    return _openstudiomodelgeometry.getGasEquipment(t_model, t_handle)

def getGasEquipments(t_model: "Model") -> "std::vector< openstudio::model::GasEquipment,std::allocator< openstudio::model::GasEquipment > >":
    return _openstudiomodelgeometry.getGasEquipments(t_model)

def getGasEquipmentByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::GasEquipment >":
    return _openstudiomodelgeometry.getGasEquipmentByName(t_model, t_name)

def getGasEquipmentsByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::GasEquipment,std::allocator< openstudio::model::GasEquipment > >":
    return _openstudiomodelgeometry.getGasEquipmentsByName(t_model, t_name, t_exactMatch)

def _to_GasEquipment(self) -> OptionalGasEquipment:
    return toGasEquipment(self)
openstudioutilitiesidf.IdfObject.to_GasEquipment = _to_GasEquipment

def _getGasEquipment(self, t_handle: "UUID") -> OptionalGasEquipment:
    return getGasEquipment(self, t_handle)
Model.getGasEquipment = _getGasEquipment

def _getGasEquipment(self, t_handle_str: str) -> OptionalGasEquipment:
    return getGasEquipment(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getGasEquipment = _getGasEquipment

def _getGasEquipments(self) -> GasEquipmentVector:
    return getGasEquipments(self)
Model.getGasEquipments = _getGasEquipments

def _getGasEquipmentByName(self, t_name: str) -> OptionalGasEquipment:
    return getGasEquipmentByName(self, t_name)
Model.getGasEquipmentByName = _getGasEquipmentByName

def _getGasEquipmentsByName(self, t_name: str, t_exactMatch: bool) -> GasEquipmentVector:
    return getGasEquipmentsByName(self, t_name, t_exactMatch)
Model.getGasEquipmentsByName = _getGasEquipmentsByName

class HotWaterEquipment(SpaceLoadInstance):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, hotWaterEquipmentDefinition: "HotWaterEquipmentDefinition"):
        _openstudiomodelgeometry.HotWaterEquipment_swiginit(self, _openstudiomodelgeometry.new_HotWaterEquipment(hotWaterEquipmentDefinition))
    __swig_destroy__ = _openstudiomodelgeometry.delete_HotWaterEquipment

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.HotWaterEquipment_iddObjectType()

    def hotWaterEquipmentDefinition(self) -> "openstudio::model::HotWaterEquipmentDefinition":
        return _openstudiomodelgeometry.HotWaterEquipment_hotWaterEquipmentDefinition(self)

    def schedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.HotWaterEquipment_schedule(self)

    def isScheduleDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.HotWaterEquipment_isScheduleDefaulted(self)

    def endUseSubcategory(self) -> "std::string":
        return _openstudiomodelgeometry.HotWaterEquipment_endUseSubcategory(self)

    def isEndUseSubcategoryDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.HotWaterEquipment_isEndUseSubcategoryDefaulted(self)

    def setHotWaterEquipmentDefinition(self, definition: "HotWaterEquipmentDefinition") -> "bool":
        return _openstudiomodelgeometry.HotWaterEquipment_setHotWaterEquipmentDefinition(self, definition)

    def setSchedule(self, schedule: "Schedule") -> "bool":
        return _openstudiomodelgeometry.HotWaterEquipment_setSchedule(self, schedule)

    def resetSchedule(self) -> "void":
        return _openstudiomodelgeometry.HotWaterEquipment_resetSchedule(self)

    def setMultiplier(self, multiplier: "double") -> "bool":
        return _openstudiomodelgeometry.HotWaterEquipment_setMultiplier(self, multiplier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.HotWaterEquipment_resetMultiplier(self)

    def setEndUseSubcategory(self, endUseSubcategory: "std::string") -> "bool":
        return _openstudiomodelgeometry.HotWaterEquipment_setEndUseSubcategory(self, endUseSubcategory)

    def resetEndUseSubcategory(self) -> "void":
        return _openstudiomodelgeometry.HotWaterEquipment_resetEndUseSubcategory(self)

    def getDesignLevel(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.HotWaterEquipment_getDesignLevel(self, floorArea, numPeople)

    def getPowerPerFloorArea(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.HotWaterEquipment_getPowerPerFloorArea(self, floorArea, numPeople)

    def getPowerPerPerson(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.HotWaterEquipment_getPowerPerPerson(self, floorArea, numPeople)

# Register HotWaterEquipment in _openstudiomodelgeometry:
_openstudiomodelgeometry.HotWaterEquipment_swigregister(HotWaterEquipment)

def HotWaterEquipment_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.HotWaterEquipment_iddObjectType()


def toHotWaterEquipment(idfObject: "IdfObject") -> "boost::optional< openstudio::model::HotWaterEquipment >":
    return _openstudiomodelgeometry.toHotWaterEquipment(idfObject)

def getHotWaterEquipment(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::HotWaterEquipment >":
    return _openstudiomodelgeometry.getHotWaterEquipment(t_model, t_handle)

def getHotWaterEquipments(t_model: "Model") -> "std::vector< openstudio::model::HotWaterEquipment,std::allocator< openstudio::model::HotWaterEquipment > >":
    return _openstudiomodelgeometry.getHotWaterEquipments(t_model)

def getHotWaterEquipmentByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::HotWaterEquipment >":
    return _openstudiomodelgeometry.getHotWaterEquipmentByName(t_model, t_name)

def getHotWaterEquipmentsByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::HotWaterEquipment,std::allocator< openstudio::model::HotWaterEquipment > >":
    return _openstudiomodelgeometry.getHotWaterEquipmentsByName(t_model, t_name, t_exactMatch)

def _to_HotWaterEquipment(self) -> OptionalHotWaterEquipment:
    return toHotWaterEquipment(self)
openstudioutilitiesidf.IdfObject.to_HotWaterEquipment = _to_HotWaterEquipment

def _getHotWaterEquipment(self, t_handle: "UUID") -> OptionalHotWaterEquipment:
    return getHotWaterEquipment(self, t_handle)
Model.getHotWaterEquipment = _getHotWaterEquipment

def _getHotWaterEquipment(self, t_handle_str: str) -> OptionalHotWaterEquipment:
    return getHotWaterEquipment(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getHotWaterEquipment = _getHotWaterEquipment

def _getHotWaterEquipments(self) -> HotWaterEquipmentVector:
    return getHotWaterEquipments(self)
Model.getHotWaterEquipments = _getHotWaterEquipments

def _getHotWaterEquipmentByName(self, t_name: str) -> OptionalHotWaterEquipment:
    return getHotWaterEquipmentByName(self, t_name)
Model.getHotWaterEquipmentByName = _getHotWaterEquipmentByName

def _getHotWaterEquipmentsByName(self, t_name: str, t_exactMatch: bool) -> HotWaterEquipmentVector:
    return getHotWaterEquipmentsByName(self, t_name, t_exactMatch)
Model.getHotWaterEquipmentsByName = _getHotWaterEquipmentsByName

class SteamEquipment(SpaceLoadInstance):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, definition: "SteamEquipmentDefinition"):
        _openstudiomodelgeometry.SteamEquipment_swiginit(self, _openstudiomodelgeometry.new_SteamEquipment(definition))
    __swig_destroy__ = _openstudiomodelgeometry.delete_SteamEquipment

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.SteamEquipment_iddObjectType()

    def steamEquipmentDefinition(self) -> "openstudio::model::SteamEquipmentDefinition":
        return _openstudiomodelgeometry.SteamEquipment_steamEquipmentDefinition(self)

    def schedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.SteamEquipment_schedule(self)

    def isScheduleDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SteamEquipment_isScheduleDefaulted(self)

    def endUseSubcategory(self) -> "std::string":
        return _openstudiomodelgeometry.SteamEquipment_endUseSubcategory(self)

    def isEndUseSubcategoryDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SteamEquipment_isEndUseSubcategoryDefaulted(self)

    def setSteamEquipmentDefinition(self, definition: "SteamEquipmentDefinition") -> "bool":
        return _openstudiomodelgeometry.SteamEquipment_setSteamEquipmentDefinition(self, definition)

    def setSchedule(self, schedule: "Schedule") -> "bool":
        return _openstudiomodelgeometry.SteamEquipment_setSchedule(self, schedule)

    def resetSchedule(self) -> "void":
        return _openstudiomodelgeometry.SteamEquipment_resetSchedule(self)

    def setMultiplier(self, multiplier: "double") -> "bool":
        return _openstudiomodelgeometry.SteamEquipment_setMultiplier(self, multiplier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.SteamEquipment_resetMultiplier(self)

    def setEndUseSubcategory(self, endUseSubcategory: "std::string") -> "bool":
        return _openstudiomodelgeometry.SteamEquipment_setEndUseSubcategory(self, endUseSubcategory)

    def resetEndUseSubcategory(self) -> "void":
        return _openstudiomodelgeometry.SteamEquipment_resetEndUseSubcategory(self)

    def getDesignLevel(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.SteamEquipment_getDesignLevel(self, floorArea, numPeople)

    def getPowerPerFloorArea(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.SteamEquipment_getPowerPerFloorArea(self, floorArea, numPeople)

    def getPowerPerPerson(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.SteamEquipment_getPowerPerPerson(self, floorArea, numPeople)

# Register SteamEquipment in _openstudiomodelgeometry:
_openstudiomodelgeometry.SteamEquipment_swigregister(SteamEquipment)

def SteamEquipment_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.SteamEquipment_iddObjectType()


def toSteamEquipment(idfObject: "IdfObject") -> "boost::optional< openstudio::model::SteamEquipment >":
    return _openstudiomodelgeometry.toSteamEquipment(idfObject)

def getSteamEquipment(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::SteamEquipment >":
    return _openstudiomodelgeometry.getSteamEquipment(t_model, t_handle)

def getSteamEquipments(t_model: "Model") -> "std::vector< openstudio::model::SteamEquipment,std::allocator< openstudio::model::SteamEquipment > >":
    return _openstudiomodelgeometry.getSteamEquipments(t_model)

def getSteamEquipmentByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::SteamEquipment >":
    return _openstudiomodelgeometry.getSteamEquipmentByName(t_model, t_name)

def getSteamEquipmentsByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::SteamEquipment,std::allocator< openstudio::model::SteamEquipment > >":
    return _openstudiomodelgeometry.getSteamEquipmentsByName(t_model, t_name, t_exactMatch)

def _to_SteamEquipment(self) -> OptionalSteamEquipment:
    return toSteamEquipment(self)
openstudioutilitiesidf.IdfObject.to_SteamEquipment = _to_SteamEquipment

def _getSteamEquipment(self, t_handle: "UUID") -> OptionalSteamEquipment:
    return getSteamEquipment(self, t_handle)
Model.getSteamEquipment = _getSteamEquipment

def _getSteamEquipment(self, t_handle_str: str) -> OptionalSteamEquipment:
    return getSteamEquipment(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getSteamEquipment = _getSteamEquipment

def _getSteamEquipments(self) -> SteamEquipmentVector:
    return getSteamEquipments(self)
Model.getSteamEquipments = _getSteamEquipments

def _getSteamEquipmentByName(self, t_name: str) -> OptionalSteamEquipment:
    return getSteamEquipmentByName(self, t_name)
Model.getSteamEquipmentByName = _getSteamEquipmentByName

def _getSteamEquipmentsByName(self, t_name: str, t_exactMatch: bool) -> SteamEquipmentVector:
    return getSteamEquipmentsByName(self, t_name, t_exactMatch)
Model.getSteamEquipmentsByName = _getSteamEquipmentsByName

class OtherEquipment(SpaceLoadInstance):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, definition: "OtherEquipmentDefinition"):
        _openstudiomodelgeometry.OtherEquipment_swiginit(self, _openstudiomodelgeometry.new_OtherEquipment(definition))
    __swig_destroy__ = _openstudiomodelgeometry.delete_OtherEquipment

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.OtherEquipment_iddObjectType()

    def endUseSubcategory(self) -> "std::string":
        return _openstudiomodelgeometry.OtherEquipment_endUseSubcategory(self)

    def isEndUseSubcategoryDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.OtherEquipment_isEndUseSubcategoryDefaulted(self)

    @staticmethod
    def validFuelTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.OtherEquipment_validFuelTypeValues()

    def fuelType(self) -> "std::string":
        return _openstudiomodelgeometry.OtherEquipment_fuelType(self)

    def isFuelTypeDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.OtherEquipment_isFuelTypeDefaulted(self)

    def otherEquipmentDefinition(self) -> "openstudio::model::OtherEquipmentDefinition":
        return _openstudiomodelgeometry.OtherEquipment_otherEquipmentDefinition(self)

    def schedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.OtherEquipment_schedule(self)

    def isScheduleDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.OtherEquipment_isScheduleDefaulted(self)

    def setEndUseSubcategory(self, endUseSubcategory: "std::string const &") -> "bool":
        return _openstudiomodelgeometry.OtherEquipment_setEndUseSubcategory(self, endUseSubcategory)

    def resetEndUseSubcategory(self) -> "void":
        return _openstudiomodelgeometry.OtherEquipment_resetEndUseSubcategory(self)

    def setFuelType(self, fuelType: "std::string const &") -> "bool":
        return _openstudiomodelgeometry.OtherEquipment_setFuelType(self, fuelType)

    def resetFuelType(self) -> "void":
        return _openstudiomodelgeometry.OtherEquipment_resetFuelType(self)

    def setOtherEquipmentDefinition(self, definition: "OtherEquipmentDefinition") -> "bool":
        return _openstudiomodelgeometry.OtherEquipment_setOtherEquipmentDefinition(self, definition)

    def setSchedule(self, schedule: "Schedule") -> "bool":
        return _openstudiomodelgeometry.OtherEquipment_setSchedule(self, schedule)

    def resetSchedule(self) -> "void":
        return _openstudiomodelgeometry.OtherEquipment_resetSchedule(self)

    def setMultiplier(self, multiplier: "double") -> "bool":
        return _openstudiomodelgeometry.OtherEquipment_setMultiplier(self, multiplier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.OtherEquipment_resetMultiplier(self)

    def getDesignLevel(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.OtherEquipment_getDesignLevel(self, floorArea, numPeople)

    def getPowerPerFloorArea(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.OtherEquipment_getPowerPerFloorArea(self, floorArea, numPeople)

    def getPowerPerPerson(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.OtherEquipment_getPowerPerPerson(self, floorArea, numPeople)

# Register OtherEquipment in _openstudiomodelgeometry:
_openstudiomodelgeometry.OtherEquipment_swigregister(OtherEquipment)

def OtherEquipment_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.OtherEquipment_iddObjectType()

def OtherEquipment_validFuelTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.OtherEquipment_validFuelTypeValues()


def toOtherEquipment(idfObject: "IdfObject") -> "boost::optional< openstudio::model::OtherEquipment >":
    return _openstudiomodelgeometry.toOtherEquipment(idfObject)

def getOtherEquipment(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::OtherEquipment >":
    return _openstudiomodelgeometry.getOtherEquipment(t_model, t_handle)

def getOtherEquipments(t_model: "Model") -> "std::vector< openstudio::model::OtherEquipment,std::allocator< openstudio::model::OtherEquipment > >":
    return _openstudiomodelgeometry.getOtherEquipments(t_model)

def getOtherEquipmentByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::OtherEquipment >":
    return _openstudiomodelgeometry.getOtherEquipmentByName(t_model, t_name)

def getOtherEquipmentsByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::OtherEquipment,std::allocator< openstudio::model::OtherEquipment > >":
    return _openstudiomodelgeometry.getOtherEquipmentsByName(t_model, t_name, t_exactMatch)

def _to_OtherEquipment(self) -> OptionalOtherEquipment:
    return toOtherEquipment(self)
openstudioutilitiesidf.IdfObject.to_OtherEquipment = _to_OtherEquipment

def _getOtherEquipment(self, t_handle: "UUID") -> OptionalOtherEquipment:
    return getOtherEquipment(self, t_handle)
Model.getOtherEquipment = _getOtherEquipment

def _getOtherEquipment(self, t_handle_str: str) -> OptionalOtherEquipment:
    return getOtherEquipment(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getOtherEquipment = _getOtherEquipment

def _getOtherEquipments(self) -> OtherEquipmentVector:
    return getOtherEquipments(self)
Model.getOtherEquipments = _getOtherEquipments

def _getOtherEquipmentByName(self, t_name: str) -> OptionalOtherEquipment:
    return getOtherEquipmentByName(self, t_name)
Model.getOtherEquipmentByName = _getOtherEquipmentByName

def _getOtherEquipmentsByName(self, t_name: str, t_exactMatch: bool) -> OtherEquipmentVector:
    return getOtherEquipmentsByName(self, t_name, t_exactMatch)
Model.getOtherEquipmentsByName = _getOtherEquipmentsByName

class InternalMass(SpaceLoadInstance):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, internalMassDefinition: "InternalMassDefinition"):
        _openstudiomodelgeometry.InternalMass_swiginit(self, _openstudiomodelgeometry.new_InternalMass(internalMassDefinition))
    __swig_destroy__ = _openstudiomodelgeometry.delete_InternalMass

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.InternalMass_iddObjectType()

    def internalMassDefinition(self) -> "openstudio::model::InternalMassDefinition":
        return _openstudiomodelgeometry.InternalMass_internalMassDefinition(self)

    def surfacePropertyConvectionCoefficients(self) -> "boost::optional< openstudio::model::SurfacePropertyConvectionCoefficients >":
        return _openstudiomodelgeometry.InternalMass_surfacePropertyConvectionCoefficients(self)

    def setInternalMassDefinition(self, definition: "InternalMassDefinition") -> "bool":
        return _openstudiomodelgeometry.InternalMass_setInternalMassDefinition(self, definition)

    def setMultiplier(self, multiplier: "double") -> "bool":
        return _openstudiomodelgeometry.InternalMass_setMultiplier(self, multiplier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.InternalMass_resetMultiplier(self)

    def surfaceArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.InternalMass_surfaceArea(self)

    def surfaceAreaPerFloorArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.InternalMass_surfaceAreaPerFloorArea(self)

    def surfaceAreaPerPerson(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.InternalMass_surfaceAreaPerPerson(self)

    def getSurfaceArea(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.InternalMass_getSurfaceArea(self, floorArea, numPeople)

    def getSurfaceAreaPerFloorArea(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.InternalMass_getSurfaceAreaPerFloorArea(self, floorArea, numPeople)

    def getSurfaceAreaPerPerson(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.InternalMass_getSurfaceAreaPerPerson(self, floorArea, numPeople)

# Register InternalMass in _openstudiomodelgeometry:
_openstudiomodelgeometry.InternalMass_swigregister(InternalMass)

def InternalMass_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.InternalMass_iddObjectType()


def toInternalMass(idfObject: "IdfObject") -> "boost::optional< openstudio::model::InternalMass >":
    return _openstudiomodelgeometry.toInternalMass(idfObject)

def getInternalMass(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::InternalMass >":
    return _openstudiomodelgeometry.getInternalMass(t_model, t_handle)

def getInternalMasss(t_model: "Model") -> "std::vector< openstudio::model::InternalMass,std::allocator< openstudio::model::InternalMass > >":
    return _openstudiomodelgeometry.getInternalMasss(t_model)

def getInternalMassByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::InternalMass >":
    return _openstudiomodelgeometry.getInternalMassByName(t_model, t_name)

def getInternalMasssByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::InternalMass,std::allocator< openstudio::model::InternalMass > >":
    return _openstudiomodelgeometry.getInternalMasssByName(t_model, t_name, t_exactMatch)

def _to_InternalMass(self) -> OptionalInternalMass:
    return toInternalMass(self)
openstudioutilitiesidf.IdfObject.to_InternalMass = _to_InternalMass

def _getInternalMass(self, t_handle: "UUID") -> OptionalInternalMass:
    return getInternalMass(self, t_handle)
Model.getInternalMass = _getInternalMass

def _getInternalMass(self, t_handle_str: str) -> OptionalInternalMass:
    return getInternalMass(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getInternalMass = _getInternalMass

def _getInternalMasss(self) -> InternalMassVector:
    return getInternalMasss(self)
Model.getInternalMasss = _getInternalMasss

def _getInternalMassByName(self, t_name: str) -> OptionalInternalMass:
    return getInternalMassByName(self, t_name)
Model.getInternalMassByName = _getInternalMassByName

def _getInternalMasssByName(self, t_name: str, t_exactMatch: bool) -> InternalMassVector:
    return getInternalMasssByName(self, t_name, t_exactMatch)
Model.getInternalMasssByName = _getInternalMasssByName

class SpaceInfiltrationDesignFlowRate(SpaceLoad):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, model: "Model"):
        _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_swiginit(self, _openstudiomodelgeometry.new_SpaceInfiltrationDesignFlowRate(model))
    __swig_destroy__ = _openstudiomodelgeometry.delete_SpaceInfiltrationDesignFlowRate

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_iddObjectType()

    @staticmethod
    def validDesignFlowRateCalculationMethodValues() -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_validDesignFlowRateCalculationMethodValues()

    @staticmethod
    def designFlowRateCalculationMethodValues() -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_designFlowRateCalculationMethodValues()

    def schedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_schedule(self)

    def isScheduleDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_isScheduleDefaulted(self)

    def designFlowRateCalculationMethod(self) -> "std::string":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_designFlowRateCalculationMethod(self)

    def designFlowRate(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_designFlowRate(self)

    def flowperSpaceFloorArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_flowperSpaceFloorArea(self)

    def flowperExteriorSurfaceArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_flowperExteriorSurfaceArea(self)

    def flowperExteriorWallArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_flowperExteriorWallArea(self)

    def airChangesperHour(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_airChangesperHour(self)

    def constantTermCoefficient(self) -> "double":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_constantTermCoefficient(self)

    def isConstantTermCoefficientDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_isConstantTermCoefficientDefaulted(self)

    def temperatureTermCoefficient(self) -> "double":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_temperatureTermCoefficient(self)

    def isTemperatureTermCoefficientDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_isTemperatureTermCoefficientDefaulted(self)

    def velocityTermCoefficient(self) -> "double":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_velocityTermCoefficient(self)

    def isVelocityTermCoefficientDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_isVelocityTermCoefficientDefaulted(self)

    def velocitySquaredTermCoefficient(self) -> "double":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_velocitySquaredTermCoefficient(self)

    def isVelocitySquaredTermCoefficientDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_isVelocitySquaredTermCoefficientDefaulted(self)

    def setSchedule(self, schedule: "Schedule") -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_setSchedule(self, schedule)

    def resetSchedule(self) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_resetSchedule(self)

    def setDesignFlowRate(self, designFlowRate: "double") -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_setDesignFlowRate(self, designFlowRate)

    def setFlowperSpaceFloorArea(self, flowperSpaceFloorArea: "double") -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_setFlowperSpaceFloorArea(self, flowperSpaceFloorArea)

    def setFlowperExteriorSurfaceArea(self, flowperExteriorSurfaceArea: "double") -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_setFlowperExteriorSurfaceArea(self, flowperExteriorSurfaceArea)

    def setFlowperExteriorWallArea(self, flowperExteriorWallArea: "double") -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_setFlowperExteriorWallArea(self, flowperExteriorWallArea)

    def setAirChangesperHour(self, airChangesperHour: "double") -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_setAirChangesperHour(self, airChangesperHour)

    def setConstantTermCoefficient(self, constantTermCoefficient: "double") -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_setConstantTermCoefficient(self, constantTermCoefficient)

    def resetConstantTermCoefficient(self) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_resetConstantTermCoefficient(self)

    def setTemperatureTermCoefficient(self, temperatureTermCoefficient: "double") -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_setTemperatureTermCoefficient(self, temperatureTermCoefficient)

    def resetTemperatureTermCoefficient(self) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_resetTemperatureTermCoefficient(self)

    def setVelocityTermCoefficient(self, velocityTermCoefficient: "double") -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_setVelocityTermCoefficient(self, velocityTermCoefficient)

    def resetVelocityTermCoefficient(self) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_resetVelocityTermCoefficient(self)

    def setVelocitySquaredTermCoefficient(self, velocitySquaredTermCoefficient: "double") -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_setVelocitySquaredTermCoefficient(self, velocitySquaredTermCoefficient)

    def resetVelocitySquaredTermCoefficient(self) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_resetVelocitySquaredTermCoefficient(self)

    def getDesignFlowRate(self, floorArea: "double", exteriorSurfaceArea: "double", exteriorWallArea: "double", airVolume: "double") -> "double":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_getDesignFlowRate(self, floorArea, exteriorSurfaceArea, exteriorWallArea, airVolume)

    def getFlowPerSpaceFloorArea(self, floorArea: "double", exteriorSurfaceArea: "double", exteriorWallArea: "double", airVolume: "double") -> "double":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_getFlowPerSpaceFloorArea(self, floorArea, exteriorSurfaceArea, exteriorWallArea, airVolume)

    def getFlowPerExteriorSurfaceArea(self, floorArea: "double", exteriorSurfaceArea: "double", exteriorWallArea: "double", airVolume: "double") -> "double":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_getFlowPerExteriorSurfaceArea(self, floorArea, exteriorSurfaceArea, exteriorWallArea, airVolume)

    def getFlowPerExteriorWallArea(self, floorArea: "double", exteriorSurfaceArea: "double", exteriorWallArea: "double", airVolume: "double") -> "double":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_getFlowPerExteriorWallArea(self, floorArea, exteriorSurfaceArea, exteriorWallArea, airVolume)

    def getAirChangesPerHour(self, floorArea: "double", exteriorSurfaceArea: "double", exteriorWallArea: "double", airVolume: "double") -> "double":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_getAirChangesPerHour(self, floorArea, exteriorSurfaceArea, exteriorWallArea, airVolume)

# Register SpaceInfiltrationDesignFlowRate in _openstudiomodelgeometry:
_openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_swigregister(SpaceInfiltrationDesignFlowRate)

def SpaceInfiltrationDesignFlowRate_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_iddObjectType()

def SpaceInfiltrationDesignFlowRate_validDesignFlowRateCalculationMethodValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_validDesignFlowRateCalculationMethodValues()

def SpaceInfiltrationDesignFlowRate_designFlowRateCalculationMethodValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_designFlowRateCalculationMethodValues()


def toSpaceInfiltrationDesignFlowRate(idfObject: "IdfObject") -> "boost::optional< openstudio::model::SpaceInfiltrationDesignFlowRate >":
    return _openstudiomodelgeometry.toSpaceInfiltrationDesignFlowRate(idfObject)

def getSpaceInfiltrationDesignFlowRate(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::SpaceInfiltrationDesignFlowRate >":
    return _openstudiomodelgeometry.getSpaceInfiltrationDesignFlowRate(t_model, t_handle)

def getSpaceInfiltrationDesignFlowRates(t_model: "Model") -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate,std::allocator< openstudio::model::SpaceInfiltrationDesignFlowRate > >":
    return _openstudiomodelgeometry.getSpaceInfiltrationDesignFlowRates(t_model)

def getSpaceInfiltrationDesignFlowRateByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::SpaceInfiltrationDesignFlowRate >":
    return _openstudiomodelgeometry.getSpaceInfiltrationDesignFlowRateByName(t_model, t_name)

def getSpaceInfiltrationDesignFlowRatesByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate,std::allocator< openstudio::model::SpaceInfiltrationDesignFlowRate > >":
    return _openstudiomodelgeometry.getSpaceInfiltrationDesignFlowRatesByName(t_model, t_name, t_exactMatch)

def _to_SpaceInfiltrationDesignFlowRate(self) -> OptionalSpaceInfiltrationDesignFlowRate:
    return toSpaceInfiltrationDesignFlowRate(self)
openstudioutilitiesidf.IdfObject.to_SpaceInfiltrationDesignFlowRate = _to_SpaceInfiltrationDesignFlowRate

def _getSpaceInfiltrationDesignFlowRate(self, t_handle: "UUID") -> OptionalSpaceInfiltrationDesignFlowRate:
    return getSpaceInfiltrationDesignFlowRate(self, t_handle)
Model.getSpaceInfiltrationDesignFlowRate = _getSpaceInfiltrationDesignFlowRate

def _getSpaceInfiltrationDesignFlowRate(self, t_handle_str: str) -> OptionalSpaceInfiltrationDesignFlowRate:
    return getSpaceInfiltrationDesignFlowRate(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getSpaceInfiltrationDesignFlowRate = _getSpaceInfiltrationDesignFlowRate

def _getSpaceInfiltrationDesignFlowRates(self) -> SpaceInfiltrationDesignFlowRateVector:
    return getSpaceInfiltrationDesignFlowRates(self)
Model.getSpaceInfiltrationDesignFlowRates = _getSpaceInfiltrationDesignFlowRates

def _getSpaceInfiltrationDesignFlowRateByName(self, t_name: str) -> OptionalSpaceInfiltrationDesignFlowRate:
    return getSpaceInfiltrationDesignFlowRateByName(self, t_name)
Model.getSpaceInfiltrationDesignFlowRateByName = _getSpaceInfiltrationDesignFlowRateByName

def _getSpaceInfiltrationDesignFlowRatesByName(self, t_name: str, t_exactMatch: bool) -> SpaceInfiltrationDesignFlowRateVector:
    return getSpaceInfiltrationDesignFlowRatesByName(self, t_name, t_exactMatch)
Model.getSpaceInfiltrationDesignFlowRatesByName = _getSpaceInfiltrationDesignFlowRatesByName

class SpaceInfiltrationEffectiveLeakageArea(SpaceLoad):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, model: "Model"):
        _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_swiginit(self, _openstudiomodelgeometry.new_SpaceInfiltrationEffectiveLeakageArea(model))
    __swig_destroy__ = _openstudiomodelgeometry.delete_SpaceInfiltrationEffectiveLeakageArea

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_iddObjectType()

    def schedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_schedule(self)

    def isScheduleDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_isScheduleDefaulted(self)

    def effectiveAirLeakageArea(self) -> "double":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_effectiveAirLeakageArea(self)

    def stackCoefficient(self) -> "double":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_stackCoefficient(self)

    def windCoefficient(self) -> "double":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_windCoefficient(self)

    def setSchedule(self, schedule: "Schedule") -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_setSchedule(self, schedule)

    def resetSchedule(self) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_resetSchedule(self)

    def setEffectiveAirLeakageArea(self, effectiveAirLeakageArea: "double") -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_setEffectiveAirLeakageArea(self, effectiveAirLeakageArea)

    def setStackCoefficient(self, stackCoefficient: "double") -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_setStackCoefficient(self, stackCoefficient)

    def setWindCoefficient(self, windCoefficient: "double") -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_setWindCoefficient(self, windCoefficient)

# Register SpaceInfiltrationEffectiveLeakageArea in _openstudiomodelgeometry:
_openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_swigregister(SpaceInfiltrationEffectiveLeakageArea)

def SpaceInfiltrationEffectiveLeakageArea_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_iddObjectType()


def toSpaceInfiltrationEffectiveLeakageArea(idfObject: "IdfObject") -> "boost::optional< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >":
    return _openstudiomodelgeometry.toSpaceInfiltrationEffectiveLeakageArea(idfObject)

def getSpaceInfiltrationEffectiveLeakageArea(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >":
    return _openstudiomodelgeometry.getSpaceInfiltrationEffectiveLeakageArea(t_model, t_handle)

def getSpaceInfiltrationEffectiveLeakageAreas(t_model: "Model") -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea,std::allocator< openstudio::model::SpaceInfiltrationEffectiveLeakageArea > >":
    return _openstudiomodelgeometry.getSpaceInfiltrationEffectiveLeakageAreas(t_model)

def getSpaceInfiltrationEffectiveLeakageAreaByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >":
    return _openstudiomodelgeometry.getSpaceInfiltrationEffectiveLeakageAreaByName(t_model, t_name)

def getSpaceInfiltrationEffectiveLeakageAreasByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea,std::allocator< openstudio::model::SpaceInfiltrationEffectiveLeakageArea > >":
    return _openstudiomodelgeometry.getSpaceInfiltrationEffectiveLeakageAreasByName(t_model, t_name, t_exactMatch)

def _to_SpaceInfiltrationEffectiveLeakageArea(self) -> OptionalSpaceInfiltrationEffectiveLeakageArea:
    return toSpaceInfiltrationEffectiveLeakageArea(self)
openstudioutilitiesidf.IdfObject.to_SpaceInfiltrationEffectiveLeakageArea = _to_SpaceInfiltrationEffectiveLeakageArea

def _getSpaceInfiltrationEffectiveLeakageArea(self, t_handle: "UUID") -> OptionalSpaceInfiltrationEffectiveLeakageArea:
    return getSpaceInfiltrationEffectiveLeakageArea(self, t_handle)
Model.getSpaceInfiltrationEffectiveLeakageArea = _getSpaceInfiltrationEffectiveLeakageArea

def _getSpaceInfiltrationEffectiveLeakageArea(self, t_handle_str: str) -> OptionalSpaceInfiltrationEffectiveLeakageArea:
    return getSpaceInfiltrationEffectiveLeakageArea(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getSpaceInfiltrationEffectiveLeakageArea = _getSpaceInfiltrationEffectiveLeakageArea

def _getSpaceInfiltrationEffectiveLeakageAreas(self) -> SpaceInfiltrationEffectiveLeakageAreaVector:
    return getSpaceInfiltrationEffectiveLeakageAreas(self)
Model.getSpaceInfiltrationEffectiveLeakageAreas = _getSpaceInfiltrationEffectiveLeakageAreas

def _getSpaceInfiltrationEffectiveLeakageAreaByName(self, t_name: str) -> OptionalSpaceInfiltrationEffectiveLeakageArea:
    return getSpaceInfiltrationEffectiveLeakageAreaByName(self, t_name)
Model.getSpaceInfiltrationEffectiveLeakageAreaByName = _getSpaceInfiltrationEffectiveLeakageAreaByName

def _getSpaceInfiltrationEffectiveLeakageAreasByName(self, t_name: str, t_exactMatch: bool) -> SpaceInfiltrationEffectiveLeakageAreaVector:
    return getSpaceInfiltrationEffectiveLeakageAreasByName(self, t_name, t_exactMatch)
Model.getSpaceInfiltrationEffectiveLeakageAreasByName = _getSpaceInfiltrationEffectiveLeakageAreasByName

class DaylightingControl(SpaceItem):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, model: "Model"):
        _openstudiomodelgeometry.DaylightingControl_swiginit(self, _openstudiomodelgeometry.new_DaylightingControl(model))
    __swig_destroy__ = _openstudiomodelgeometry.delete_DaylightingControl

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.DaylightingControl_iddObjectType()

    @staticmethod
    def validLightingControlTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.DaylightingControl_validLightingControlTypeValues()

    def positionXCoordinate(self) -> "double":
        return _openstudiomodelgeometry.DaylightingControl_positionXCoordinate(self)

    def positionYCoordinate(self) -> "double":
        return _openstudiomodelgeometry.DaylightingControl_positionYCoordinate(self)

    def positionZCoordinate(self) -> "double":
        return _openstudiomodelgeometry.DaylightingControl_positionZCoordinate(self)

    def psiRotationAroundXAxis(self) -> "double":
        return _openstudiomodelgeometry.DaylightingControl_psiRotationAroundXAxis(self)

    def isPsiRotationAroundXAxisDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_isPsiRotationAroundXAxisDefaulted(self)

    def thetaRotationAroundYAxis(self) -> "double":
        return _openstudiomodelgeometry.DaylightingControl_thetaRotationAroundYAxis(self)

    def isThetaRotationAroundYAxisDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_isThetaRotationAroundYAxisDefaulted(self)

    def phiRotationAroundZAxis(self) -> "double":
        return _openstudiomodelgeometry.DaylightingControl_phiRotationAroundZAxis(self)

    def isPhiRotationAroundZAxisDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_isPhiRotationAroundZAxisDefaulted(self)

    def illuminanceSetpoint(self) -> "double":
        return _openstudiomodelgeometry.DaylightingControl_illuminanceSetpoint(self)

    def isIlluminanceSetpointDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_isIlluminanceSetpointDefaulted(self)

    def lightingControlType(self) -> "std::string":
        return _openstudiomodelgeometry.DaylightingControl_lightingControlType(self)

    def isLightingControlTypeDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_isLightingControlTypeDefaulted(self)

    def minimumInputPowerFractionforContinuousDimmingControl(self) -> "double":
        return _openstudiomodelgeometry.DaylightingControl_minimumInputPowerFractionforContinuousDimmingControl(self)

    def isMinimumInputPowerFractionforContinuousDimmingControlDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_isMinimumInputPowerFractionforContinuousDimmingControlDefaulted(self)

    def minimumLightOutputFractionforContinuousDimmingControl(self) -> "double":
        return _openstudiomodelgeometry.DaylightingControl_minimumLightOutputFractionforContinuousDimmingControl(self)

    def isMinimumLightOutputFractionforContinuousDimmingControlDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_isMinimumLightOutputFractionforContinuousDimmingControlDefaulted(self)

    def numberofSteppedControlSteps(self) -> "int":
        return _openstudiomodelgeometry.DaylightingControl_numberofSteppedControlSteps(self)

    def isNumberofSteppedControlStepsDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_isNumberofSteppedControlStepsDefaulted(self)

    def probabilityLightingwillbeResetWhenNeededinManualSteppedControl(self) -> "double":
        return _openstudiomodelgeometry.DaylightingControl_probabilityLightingwillbeResetWhenNeededinManualSteppedControl(self)

    def isProbabilityLightingwillbeResetWhenNeededinManualSteppedControlDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_isProbabilityLightingwillbeResetWhenNeededinManualSteppedControlDefaulted(self)

    def numberofDaylightingViews(self) -> "int":
        return _openstudiomodelgeometry.DaylightingControl_numberofDaylightingViews(self)

    def isNumberofDaylightingViewsDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_isNumberofDaylightingViewsDefaulted(self)

    def maximumAllowableDiscomfortGlareIndex(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.DaylightingControl_maximumAllowableDiscomfortGlareIndex(self)

    def setPositionXCoordinate(self, positionXCoordinate: "double") -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setPositionXCoordinate(self, positionXCoordinate)

    def setPositionYCoordinate(self, positionYCoordinate: "double") -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setPositionYCoordinate(self, positionYCoordinate)

    def setPositionZCoordinate(self, positionZCoordinate: "double") -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setPositionZCoordinate(self, positionZCoordinate)

    def setPsiRotationAroundXAxis(self, psiRotationAroundXAxis: "double") -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setPsiRotationAroundXAxis(self, psiRotationAroundXAxis)

    def resetPsiRotationAroundXAxis(self) -> "void":
        return _openstudiomodelgeometry.DaylightingControl_resetPsiRotationAroundXAxis(self)

    def setThetaRotationAroundYAxis(self, thetaRotationAroundYAxis: "double") -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setThetaRotationAroundYAxis(self, thetaRotationAroundYAxis)

    def resetThetaRotationAroundYAxis(self) -> "void":
        return _openstudiomodelgeometry.DaylightingControl_resetThetaRotationAroundYAxis(self)

    def setPhiRotationAroundZAxis(self, phiRotationAroundZAxis: "double") -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setPhiRotationAroundZAxis(self, phiRotationAroundZAxis)

    def resetPhiRotationAroundZAxis(self) -> "void":
        return _openstudiomodelgeometry.DaylightingControl_resetPhiRotationAroundZAxis(self)

    def setIlluminanceSetpoint(self, illuminanceSetpoint: "double") -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setIlluminanceSetpoint(self, illuminanceSetpoint)

    def resetIlluminanceSetpoint(self) -> "void":
        return _openstudiomodelgeometry.DaylightingControl_resetIlluminanceSetpoint(self)

    def setLightingControlType(self, lightingControlType: "std::string") -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setLightingControlType(self, lightingControlType)

    def resetLightingControlType(self) -> "void":
        return _openstudiomodelgeometry.DaylightingControl_resetLightingControlType(self)

    def setMinimumInputPowerFractionforContinuousDimmingControl(self, minimumInputPowerFractionforContinuousDimmingControl: "double") -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setMinimumInputPowerFractionforContinuousDimmingControl(self, minimumInputPowerFractionforContinuousDimmingControl)

    def resetMinimumInputPowerFractionforContinuousDimmingControl(self) -> "void":
        return _openstudiomodelgeometry.DaylightingControl_resetMinimumInputPowerFractionforContinuousDimmingControl(self)

    def setMinimumLightOutputFractionforContinuousDimmingControl(self, minimumLightOutputFractionforContinuousDimmingControl: "double") -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setMinimumLightOutputFractionforContinuousDimmingControl(self, minimumLightOutputFractionforContinuousDimmingControl)

    def resetMinimumLightOutputFractionforContinuousDimmingControl(self) -> "void":
        return _openstudiomodelgeometry.DaylightingControl_resetMinimumLightOutputFractionforContinuousDimmingControl(self)

    def setNumberofSteppedControlSteps(self, numberofSteppedControlSteps: "int") -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setNumberofSteppedControlSteps(self, numberofSteppedControlSteps)

    def resetNumberofSteppedControlSteps(self) -> "void":
        return _openstudiomodelgeometry.DaylightingControl_resetNumberofSteppedControlSteps(self)

    def setProbabilityLightingwillbeResetWhenNeededinManualSteppedControl(self, probabilityLightingwillbeResetWhenNeededinManualSteppedControl: "double") -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setProbabilityLightingwillbeResetWhenNeededinManualSteppedControl(self, probabilityLightingwillbeResetWhenNeededinManualSteppedControl)

    def resetProbabilityLightingwillbeResetWhenNeededinManualSteppedControl(self) -> "void":
        return _openstudiomodelgeometry.DaylightingControl_resetProbabilityLightingwillbeResetWhenNeededinManualSteppedControl(self)

    def setNumberofDaylightingViews(self, numberofDaylightingViews: "int") -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setNumberofDaylightingViews(self, numberofDaylightingViews)

    def resetNumberofDaylightingViews(self) -> "void":
        return _openstudiomodelgeometry.DaylightingControl_resetNumberofDaylightingViews(self)

    def setMaximumAllowableDiscomfortGlareIndex(self, maximumAllowableDiscomfortGlareIndex: "double") -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setMaximumAllowableDiscomfortGlareIndex(self, maximumAllowableDiscomfortGlareIndex)

    def resetMaximumAllowableDiscomfortGlareIndex(self) -> "void":
        return _openstudiomodelgeometry.DaylightingControl_resetMaximumAllowableDiscomfortGlareIndex(self)

    def position(self) -> "openstudio::Point3d":
        return _openstudiomodelgeometry.DaylightingControl_position(self)

    def setPosition(self, position: "Point3d") -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setPosition(self, position)

    def transformation(self) -> "openstudio::Transformation":
        return _openstudiomodelgeometry.DaylightingControl_transformation(self)

    def setTransformation(self, transformation: "Transformation") -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setTransformation(self, transformation)

    def isPrimaryDaylightingControl(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_isPrimaryDaylightingControl(self)

    def isSecondaryDaylightingControl(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_isSecondaryDaylightingControl(self)

    def aimAt(self, target: "Point3d") -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_aimAt(self, target)

# Register DaylightingControl in _openstudiomodelgeometry:
_openstudiomodelgeometry.DaylightingControl_swigregister(DaylightingControl)

def DaylightingControl_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.DaylightingControl_iddObjectType()

def DaylightingControl_validLightingControlTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.DaylightingControl_validLightingControlTypeValues()


def toDaylightingControl(idfObject: "IdfObject") -> "boost::optional< openstudio::model::DaylightingControl >":
    return _openstudiomodelgeometry.toDaylightingControl(idfObject)

def getDaylightingControl(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::DaylightingControl >":
    return _openstudiomodelgeometry.getDaylightingControl(t_model, t_handle)

def getDaylightingControls(t_model: "Model") -> "std::vector< openstudio::model::DaylightingControl,std::allocator< openstudio::model::DaylightingControl > >":
    return _openstudiomodelgeometry.getDaylightingControls(t_model)

def getDaylightingControlByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::DaylightingControl >":
    return _openstudiomodelgeometry.getDaylightingControlByName(t_model, t_name)

def getDaylightingControlsByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::DaylightingControl,std::allocator< openstudio::model::DaylightingControl > >":
    return _openstudiomodelgeometry.getDaylightingControlsByName(t_model, t_name, t_exactMatch)

def _to_DaylightingControl(self) -> OptionalDaylightingControl:
    return toDaylightingControl(self)
openstudioutilitiesidf.IdfObject.to_DaylightingControl = _to_DaylightingControl

def _getDaylightingControl(self, t_handle: "UUID") -> OptionalDaylightingControl:
    return getDaylightingControl(self, t_handle)
Model.getDaylightingControl = _getDaylightingControl

def _getDaylightingControl(self, t_handle_str: str) -> OptionalDaylightingControl:
    return getDaylightingControl(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getDaylightingControl = _getDaylightingControl

def _getDaylightingControls(self) -> DaylightingControlVector:
    return getDaylightingControls(self)
Model.getDaylightingControls = _getDaylightingControls

def _getDaylightingControlByName(self, t_name: str) -> OptionalDaylightingControl:
    return getDaylightingControlByName(self, t_name)
Model.getDaylightingControlByName = _getDaylightingControlByName

def _getDaylightingControlsByName(self, t_name: str, t_exactMatch: bool) -> DaylightingControlVector:
    return getDaylightingControlsByName(self, t_name, t_exactMatch)
Model.getDaylightingControlsByName = _getDaylightingControlsByName

class GlareSensor(SpaceItem):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, model: "Model"):
        _openstudiomodelgeometry.GlareSensor_swiginit(self, _openstudiomodelgeometry.new_GlareSensor(model))
    __swig_destroy__ = _openstudiomodelgeometry.delete_GlareSensor

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.GlareSensor_iddObjectType()

    def positionXCoordinate(self) -> "double":
        return _openstudiomodelgeometry.GlareSensor_positionXCoordinate(self)

    def positionYCoordinate(self) -> "double":
        return _openstudiomodelgeometry.GlareSensor_positionYCoordinate(self)

    def positionZCoordinate(self) -> "double":
        return _openstudiomodelgeometry.GlareSensor_positionZCoordinate(self)

    def psiRotationAroundXAxis(self) -> "double":
        return _openstudiomodelgeometry.GlareSensor_psiRotationAroundXAxis(self)

    def isPsiRotationAroundXAxisDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.GlareSensor_isPsiRotationAroundXAxisDefaulted(self)

    def thetaRotationAroundYAxis(self) -> "double":
        return _openstudiomodelgeometry.GlareSensor_thetaRotationAroundYAxis(self)

    def isThetaRotationAroundYAxisDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.GlareSensor_isThetaRotationAroundYAxisDefaulted(self)

    def phiRotationAroundZAxis(self) -> "double":
        return _openstudiomodelgeometry.GlareSensor_phiRotationAroundZAxis(self)

    def isPhiRotationAroundZAxisDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.GlareSensor_isPhiRotationAroundZAxisDefaulted(self)

    def numberofGlareViewVectors(self) -> "int":
        return _openstudiomodelgeometry.GlareSensor_numberofGlareViewVectors(self)

    def maximumAllowableDaylightGlareProbability(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.GlareSensor_maximumAllowableDaylightGlareProbability(self)

    def setPositionXCoordinate(self, positionXCoordinate: "double") -> "bool":
        return _openstudiomodelgeometry.GlareSensor_setPositionXCoordinate(self, positionXCoordinate)

    def setPositionYCoordinate(self, positionYCoordinate: "double") -> "bool":
        return _openstudiomodelgeometry.GlareSensor_setPositionYCoordinate(self, positionYCoordinate)

    def setPositionZCoordinate(self, positionZCoordinate: "double") -> "bool":
        return _openstudiomodelgeometry.GlareSensor_setPositionZCoordinate(self, positionZCoordinate)

    def setPsiRotationAroundXAxis(self, psiRotationAroundXAxis: "double") -> "bool":
        return _openstudiomodelgeometry.GlareSensor_setPsiRotationAroundXAxis(self, psiRotationAroundXAxis)

    def resetPsiRotationAroundXAxis(self) -> "void":
        return _openstudiomodelgeometry.GlareSensor_resetPsiRotationAroundXAxis(self)

    def setThetaRotationAroundYAxis(self, thetaRotationAroundYAxis: "double") -> "bool":
        return _openstudiomodelgeometry.GlareSensor_setThetaRotationAroundYAxis(self, thetaRotationAroundYAxis)

    def resetThetaRotationAroundYAxis(self) -> "void":
        return _openstudiomodelgeometry.GlareSensor_resetThetaRotationAroundYAxis(self)

    def setPhiRotationAroundZAxis(self, phiRotationAroundZAxis: "double") -> "bool":
        return _openstudiomodelgeometry.GlareSensor_setPhiRotationAroundZAxis(self, phiRotationAroundZAxis)

    def resetPhiRotationAroundZAxis(self) -> "void":
        return _openstudiomodelgeometry.GlareSensor_resetPhiRotationAroundZAxis(self)

    def setNumberofGlareViewVectors(self, numberofGlareViewVectors: "int") -> "bool":
        return _openstudiomodelgeometry.GlareSensor_setNumberofGlareViewVectors(self, numberofGlareViewVectors)

    def resetNumberofGlareViewVectors(self) -> "void":
        return _openstudiomodelgeometry.GlareSensor_resetNumberofGlareViewVectors(self)

    def setMaximumAllowableDaylightGlareProbability(self, maximumAllowableDaylightGlareProbability: "double") -> "bool":
        return _openstudiomodelgeometry.GlareSensor_setMaximumAllowableDaylightGlareProbability(self, maximumAllowableDaylightGlareProbability)

    def resetMaximumAllowableDaylightGlareProbability(self) -> "void":
        return _openstudiomodelgeometry.GlareSensor_resetMaximumAllowableDaylightGlareProbability(self)

    def position(self) -> "openstudio::Point3d":
        return _openstudiomodelgeometry.GlareSensor_position(self)

    def setPosition(self, position: "Point3d") -> "bool":
        return _openstudiomodelgeometry.GlareSensor_setPosition(self, position)

    def transformation(self) -> "openstudio::Transformation":
        return _openstudiomodelgeometry.GlareSensor_transformation(self)

    def setTransformation(self, transformation: "Transformation") -> "bool":
        return _openstudiomodelgeometry.GlareSensor_setTransformation(self, transformation)

    def aimAt(self, target: "Point3d") -> "bool":
        return _openstudiomodelgeometry.GlareSensor_aimAt(self, target)

# Register GlareSensor in _openstudiomodelgeometry:
_openstudiomodelgeometry.GlareSensor_swigregister(GlareSensor)

def GlareSensor_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.GlareSensor_iddObjectType()


def toGlareSensor(idfObject: "IdfObject") -> "boost::optional< openstudio::model::GlareSensor >":
    return _openstudiomodelgeometry.toGlareSensor(idfObject)

def getGlareSensor(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::GlareSensor >":
    return _openstudiomodelgeometry.getGlareSensor(t_model, t_handle)

def getGlareSensors(t_model: "Model") -> "std::vector< openstudio::model::GlareSensor,std::allocator< openstudio::model::GlareSensor > >":
    return _openstudiomodelgeometry.getGlareSensors(t_model)

def getGlareSensorByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::GlareSensor >":
    return _openstudiomodelgeometry.getGlareSensorByName(t_model, t_name)

def getGlareSensorsByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::GlareSensor,std::allocator< openstudio::model::GlareSensor > >":
    return _openstudiomodelgeometry.getGlareSensorsByName(t_model, t_name, t_exactMatch)

def _to_GlareSensor(self) -> OptionalGlareSensor:
    return toGlareSensor(self)
openstudioutilitiesidf.IdfObject.to_GlareSensor = _to_GlareSensor

def _getGlareSensor(self, t_handle: "UUID") -> OptionalGlareSensor:
    return getGlareSensor(self, t_handle)
Model.getGlareSensor = _getGlareSensor

def _getGlareSensor(self, t_handle_str: str) -> OptionalGlareSensor:
    return getGlareSensor(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getGlareSensor = _getGlareSensor

def _getGlareSensors(self) -> GlareSensorVector:
    return getGlareSensors(self)
Model.getGlareSensors = _getGlareSensors

def _getGlareSensorByName(self, t_name: str) -> OptionalGlareSensor:
    return getGlareSensorByName(self, t_name)
Model.getGlareSensorByName = _getGlareSensorByName

def _getGlareSensorsByName(self, t_name: str, t_exactMatch: bool) -> GlareSensorVector:
    return getGlareSensorsByName(self, t_name, t_exactMatch)
Model.getGlareSensorsByName = _getGlareSensorsByName

class IlluminanceMap(SpaceItem):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, model: "Model"):
        _openstudiomodelgeometry.IlluminanceMap_swiginit(self, _openstudiomodelgeometry.new_IlluminanceMap(model))
    __swig_destroy__ = _openstudiomodelgeometry.delete_IlluminanceMap

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.IlluminanceMap_iddObjectType()

    def originXCoordinate(self) -> "double":
        return _openstudiomodelgeometry.IlluminanceMap_originXCoordinate(self)

    def originYCoordinate(self) -> "double":
        return _openstudiomodelgeometry.IlluminanceMap_originYCoordinate(self)

    def originZCoordinate(self) -> "double":
        return _openstudiomodelgeometry.IlluminanceMap_originZCoordinate(self)

    def psiRotationAroundXAxis(self) -> "double":
        return _openstudiomodelgeometry.IlluminanceMap_psiRotationAroundXAxis(self)

    def isPsiRotationAroundXAxisDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_isPsiRotationAroundXAxisDefaulted(self)

    def thetaRotationAroundYAxis(self) -> "double":
        return _openstudiomodelgeometry.IlluminanceMap_thetaRotationAroundYAxis(self)

    def isThetaRotationAroundYAxisDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_isThetaRotationAroundYAxisDefaulted(self)

    def phiRotationAroundZAxis(self) -> "double":
        return _openstudiomodelgeometry.IlluminanceMap_phiRotationAroundZAxis(self)

    def isPhiRotationAroundZAxisDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_isPhiRotationAroundZAxisDefaulted(self)

    def xLength(self) -> "double":
        return _openstudiomodelgeometry.IlluminanceMap_xLength(self)

    def isXLengthDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_isXLengthDefaulted(self)

    def numberofXGridPoints(self) -> "int":
        return _openstudiomodelgeometry.IlluminanceMap_numberofXGridPoints(self)

    def isNumberofXGridPointsDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_isNumberofXGridPointsDefaulted(self)

    def yLength(self) -> "double":
        return _openstudiomodelgeometry.IlluminanceMap_yLength(self)

    def isYLengthDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_isYLengthDefaulted(self)

    def numberofYGridPoints(self) -> "int":
        return _openstudiomodelgeometry.IlluminanceMap_numberofYGridPoints(self)

    def isNumberofYGridPointsDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_isNumberofYGridPointsDefaulted(self)

    def setOriginXCoordinate(self, originXCoordinate: "double") -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_setOriginXCoordinate(self, originXCoordinate)

    def setOriginYCoordinate(self, originYCoordinate: "double") -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_setOriginYCoordinate(self, originYCoordinate)

    def setOriginZCoordinate(self, originZCoordinate: "double") -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_setOriginZCoordinate(self, originZCoordinate)

    def setPsiRotationAroundXAxis(self, psiRotationAroundXAxis: "double") -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_setPsiRotationAroundXAxis(self, psiRotationAroundXAxis)

    def resetPsiRotationAroundXAxis(self) -> "void":
        return _openstudiomodelgeometry.IlluminanceMap_resetPsiRotationAroundXAxis(self)

    def setThetaRotationAroundYAxis(self, thetaRotationAroundYAxis: "double") -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_setThetaRotationAroundYAxis(self, thetaRotationAroundYAxis)

    def resetThetaRotationAroundYAxis(self) -> "void":
        return _openstudiomodelgeometry.IlluminanceMap_resetThetaRotationAroundYAxis(self)

    def setPhiRotationAroundZAxis(self, phiRotationAroundZAxis: "double") -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_setPhiRotationAroundZAxis(self, phiRotationAroundZAxis)

    def resetPhiRotationAroundZAxis(self) -> "void":
        return _openstudiomodelgeometry.IlluminanceMap_resetPhiRotationAroundZAxis(self)

    def setXLength(self, xLength: "double") -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_setXLength(self, xLength)

    def resetXLength(self) -> "void":
        return _openstudiomodelgeometry.IlluminanceMap_resetXLength(self)

    def setNumberofXGridPoints(self, numberofXGridPoints: "int") -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_setNumberofXGridPoints(self, numberofXGridPoints)

    def resetNumberofXGridPoints(self) -> "void":
        return _openstudiomodelgeometry.IlluminanceMap_resetNumberofXGridPoints(self)

    def setYLength(self, yLength: "double") -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_setYLength(self, yLength)

    def resetYLength(self) -> "void":
        return _openstudiomodelgeometry.IlluminanceMap_resetYLength(self)

    def setNumberofYGridPoints(self, numberofYGridPoints: "int") -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_setNumberofYGridPoints(self, numberofYGridPoints)

    def resetNumberofYGridPoints(self) -> "void":
        return _openstudiomodelgeometry.IlluminanceMap_resetNumberofYGridPoints(self)

    def transformation(self) -> "openstudio::Transformation":
        return _openstudiomodelgeometry.IlluminanceMap_transformation(self)

    def setTransformation(self, transformation: "Transformation") -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_setTransformation(self, transformation)

    def referencePoints(self) -> "std::vector< openstudio::Point3d,std::allocator< openstudio::Point3d > >":
        return _openstudiomodelgeometry.IlluminanceMap_referencePoints(self)

    def corners(self) -> "std::vector< openstudio::Point3d,std::allocator< openstudio::Point3d > >":
        return _openstudiomodelgeometry.IlluminanceMap_corners(self)

# Register IlluminanceMap in _openstudiomodelgeometry:
_openstudiomodelgeometry.IlluminanceMap_swigregister(IlluminanceMap)

def IlluminanceMap_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.IlluminanceMap_iddObjectType()


def toIlluminanceMap(idfObject: "IdfObject") -> "boost::optional< openstudio::model::IlluminanceMap >":
    return _openstudiomodelgeometry.toIlluminanceMap(idfObject)

def getIlluminanceMap(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::IlluminanceMap >":
    return _openstudiomodelgeometry.getIlluminanceMap(t_model, t_handle)

def getIlluminanceMaps(t_model: "Model") -> "std::vector< openstudio::model::IlluminanceMap,std::allocator< openstudio::model::IlluminanceMap > >":
    return _openstudiomodelgeometry.getIlluminanceMaps(t_model)

def getIlluminanceMapByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::IlluminanceMap >":
    return _openstudiomodelgeometry.getIlluminanceMapByName(t_model, t_name)

def getIlluminanceMapsByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::IlluminanceMap,std::allocator< openstudio::model::IlluminanceMap > >":
    return _openstudiomodelgeometry.getIlluminanceMapsByName(t_model, t_name, t_exactMatch)

def _to_IlluminanceMap(self) -> OptionalIlluminanceMap:
    return toIlluminanceMap(self)
openstudioutilitiesidf.IdfObject.to_IlluminanceMap = _to_IlluminanceMap

def _getIlluminanceMap(self, t_handle: "UUID") -> OptionalIlluminanceMap:
    return getIlluminanceMap(self, t_handle)
Model.getIlluminanceMap = _getIlluminanceMap

def _getIlluminanceMap(self, t_handle_str: str) -> OptionalIlluminanceMap:
    return getIlluminanceMap(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getIlluminanceMap = _getIlluminanceMap

def _getIlluminanceMaps(self) -> IlluminanceMapVector:
    return getIlluminanceMaps(self)
Model.getIlluminanceMaps = _getIlluminanceMaps

def _getIlluminanceMapByName(self, t_name: str) -> OptionalIlluminanceMap:
    return getIlluminanceMapByName(self, t_name)
Model.getIlluminanceMapByName = _getIlluminanceMapByName

def _getIlluminanceMapsByName(self, t_name: str, t_exactMatch: bool) -> IlluminanceMapVector:
    return getIlluminanceMapsByName(self, t_name, t_exactMatch)
Model.getIlluminanceMapsByName = _getIlluminanceMapsByName

class DaylightingDeviceShelf(openstudiomodelcore.ModelObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, subSurface: "SubSurface"):
        _openstudiomodelgeometry.DaylightingDeviceShelf_swiginit(self, _openstudiomodelgeometry.new_DaylightingDeviceShelf(subSurface))
    __swig_destroy__ = _openstudiomodelgeometry.delete_DaylightingDeviceShelf

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.DaylightingDeviceShelf_iddObjectType()

    def insideShelf(self) -> "boost::optional< openstudio::model::InteriorPartitionSurface >":
        return _openstudiomodelgeometry.DaylightingDeviceShelf_insideShelf(self)

    def outsideShelf(self) -> "boost::optional< openstudio::model::ShadingSurface >":
        return _openstudiomodelgeometry.DaylightingDeviceShelf_outsideShelf(self)

    def viewFactortoOutsideShelf(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.DaylightingDeviceShelf_viewFactortoOutsideShelf(self)

    def setInsideShelf(self, insideShelf: "InteriorPartitionSurface") -> "bool":
        return _openstudiomodelgeometry.DaylightingDeviceShelf_setInsideShelf(self, insideShelf)

    def setOutsideShelf(self, outsideShelf: "ShadingSurface") -> "bool":
        return _openstudiomodelgeometry.DaylightingDeviceShelf_setOutsideShelf(self, outsideShelf)

    def setViewFactortoOutsideShelf(self, viewFactortoOutsideShelf: "double") -> "bool":
        return _openstudiomodelgeometry.DaylightingDeviceShelf_setViewFactortoOutsideShelf(self, viewFactortoOutsideShelf)

    def resetViewFactortoOutsideShelf(self) -> "void":
        return _openstudiomodelgeometry.DaylightingDeviceShelf_resetViewFactortoOutsideShelf(self)

    def subSurface(self) -> "openstudio::model::SubSurface":
        return _openstudiomodelgeometry.DaylightingDeviceShelf_subSurface(self)

# Register DaylightingDeviceShelf in _openstudiomodelgeometry:
_openstudiomodelgeometry.DaylightingDeviceShelf_swigregister(DaylightingDeviceShelf)

def DaylightingDeviceShelf_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.DaylightingDeviceShelf_iddObjectType()


def toDaylightingDeviceShelf(idfObject: "IdfObject") -> "boost::optional< openstudio::model::DaylightingDeviceShelf >":
    return _openstudiomodelgeometry.toDaylightingDeviceShelf(idfObject)

def getDaylightingDeviceShelf(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::DaylightingDeviceShelf >":
    return _openstudiomodelgeometry.getDaylightingDeviceShelf(t_model, t_handle)

def getDaylightingDeviceShelfs(t_model: "Model") -> "std::vector< openstudio::model::DaylightingDeviceShelf,std::allocator< openstudio::model::DaylightingDeviceShelf > >":
    return _openstudiomodelgeometry.getDaylightingDeviceShelfs(t_model)

def getDaylightingDeviceShelfByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::DaylightingDeviceShelf >":
    return _openstudiomodelgeometry.getDaylightingDeviceShelfByName(t_model, t_name)

def getDaylightingDeviceShelfsByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::DaylightingDeviceShelf,std::allocator< openstudio::model::DaylightingDeviceShelf > >":
    return _openstudiomodelgeometry.getDaylightingDeviceShelfsByName(t_model, t_name, t_exactMatch)

def _to_DaylightingDeviceShelf(self) -> OptionalDaylightingDeviceShelf:
    return toDaylightingDeviceShelf(self)
openstudioutilitiesidf.IdfObject.to_DaylightingDeviceShelf = _to_DaylightingDeviceShelf

def _getDaylightingDeviceShelf(self, t_handle: "UUID") -> OptionalDaylightingDeviceShelf:
    return getDaylightingDeviceShelf(self, t_handle)
Model.getDaylightingDeviceShelf = _getDaylightingDeviceShelf

def _getDaylightingDeviceShelf(self, t_handle_str: str) -> OptionalDaylightingDeviceShelf:
    return getDaylightingDeviceShelf(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getDaylightingDeviceShelf = _getDaylightingDeviceShelf

def _getDaylightingDeviceShelfs(self) -> DaylightingDeviceShelfVector:
    return getDaylightingDeviceShelfs(self)
Model.getDaylightingDeviceShelfs = _getDaylightingDeviceShelfs

def _getDaylightingDeviceShelfByName(self, t_name: str) -> OptionalDaylightingDeviceShelf:
    return getDaylightingDeviceShelfByName(self, t_name)
Model.getDaylightingDeviceShelfByName = _getDaylightingDeviceShelfByName

def _getDaylightingDeviceShelfsByName(self, t_name: str, t_exactMatch: bool) -> DaylightingDeviceShelfVector:
    return getDaylightingDeviceShelfsByName(self, t_name, t_exactMatch)
Model.getDaylightingDeviceShelfsByName = _getDaylightingDeviceShelfsByName

class SpaceType(openstudiomodelcore.ResourceObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, model: "Model"):
        _openstudiomodelgeometry.SpaceType_swiginit(self, _openstudiomodelgeometry.new_SpaceType(model))
    __swig_destroy__ = _openstudiomodelgeometry.delete_SpaceType

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.SpaceType_iddObjectType()

    def defaultConstructionSet(self) -> "boost::optional< openstudio::model::DefaultConstructionSet >":
        return _openstudiomodelgeometry.SpaceType_defaultConstructionSet(self)

    def defaultScheduleSet(self) -> "boost::optional< openstudio::model::DefaultScheduleSet >":
        return _openstudiomodelgeometry.SpaceType_defaultScheduleSet(self)

    def renderingColor(self) -> "boost::optional< openstudio::model::RenderingColor >":
        return _openstudiomodelgeometry.SpaceType_renderingColor(self)

    def standardsTemplate(self) -> "boost::optional< std::string >":
        return _openstudiomodelgeometry.SpaceType_standardsTemplate(self)

    def suggestedStandardsTemplates(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.SpaceType_suggestedStandardsTemplates(self)

    def standardsBuildingType(self) -> "boost::optional< std::string >":
        return _openstudiomodelgeometry.SpaceType_standardsBuildingType(self)

    def suggestedStandardsBuildingTypes(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.SpaceType_suggestedStandardsBuildingTypes(self)

    def standardsSpaceType(self) -> "boost::optional< std::string >":
        return _openstudiomodelgeometry.SpaceType_standardsSpaceType(self)

    def suggestedStandardsSpaceTypes(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.SpaceType_suggestedStandardsSpaceTypes(self)

    def setDefaultConstructionSet(self, defaultConstructionSet: "DefaultConstructionSet") -> "bool":
        return _openstudiomodelgeometry.SpaceType_setDefaultConstructionSet(self, defaultConstructionSet)

    def resetDefaultConstructionSet(self) -> "void":
        return _openstudiomodelgeometry.SpaceType_resetDefaultConstructionSet(self)

    def setDefaultScheduleSet(self, defaultScheduleSet: "DefaultScheduleSet") -> "bool":
        return _openstudiomodelgeometry.SpaceType_setDefaultScheduleSet(self, defaultScheduleSet)

    def resetDefaultScheduleSet(self) -> "void":
        return _openstudiomodelgeometry.SpaceType_resetDefaultScheduleSet(self)

    def setRenderingColor(self, renderingColor: "RenderingColor") -> "bool":
        return _openstudiomodelgeometry.SpaceType_setRenderingColor(self, renderingColor)

    def resetRenderingColor(self) -> "void":
        return _openstudiomodelgeometry.SpaceType_resetRenderingColor(self)

    def setStandardsTemplate(self, standardsTemplate: "std::string const &") -> "bool":
        return _openstudiomodelgeometry.SpaceType_setStandardsTemplate(self, standardsTemplate)

    def resetStandardsTemplate(self) -> "void":
        return _openstudiomodelgeometry.SpaceType_resetStandardsTemplate(self)

    def setStandardsBuildingType(self, standardsBuildingType: "std::string const &") -> "bool":
        return _openstudiomodelgeometry.SpaceType_setStandardsBuildingType(self, standardsBuildingType)

    def resetStandardsBuildingType(self) -> "void":
        return _openstudiomodelgeometry.SpaceType_resetStandardsBuildingType(self)

    def setStandardsSpaceType(self, standardsSpaceType: "std::string const &") -> "bool":
        return _openstudiomodelgeometry.SpaceType_setStandardsSpaceType(self, standardsSpaceType)

    def resetStandardsSpaceType(self) -> "void":
        return _openstudiomodelgeometry.SpaceType_resetStandardsSpaceType(self)

    def spaces(self) -> "std::vector< openstudio::model::Space,std::allocator< openstudio::model::Space > >":
        return _openstudiomodelgeometry.SpaceType_spaces(self)

    def getDefaultSchedule(self, defaultScheduleType: "DefaultScheduleType") -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.SpaceType_getDefaultSchedule(self, defaultScheduleType)

    def internalMass(self) -> "std::vector< openstudio::model::InternalMass,std::allocator< openstudio::model::InternalMass > >":
        return _openstudiomodelgeometry.SpaceType_internalMass(self)

    def people(self) -> "std::vector< openstudio::model::People,std::allocator< openstudio::model::People > >":
        return _openstudiomodelgeometry.SpaceType_people(self)

    def lights(self) -> "std::vector< openstudio::model::Lights,std::allocator< openstudio::model::Lights > >":
        return _openstudiomodelgeometry.SpaceType_lights(self)

    def luminaires(self) -> "std::vector< openstudio::model::Luminaire,std::allocator< openstudio::model::Luminaire > >":
        return _openstudiomodelgeometry.SpaceType_luminaires(self)

    def electricEquipment(self) -> "std::vector< openstudio::model::ElectricEquipment,std::allocator< openstudio::model::ElectricEquipment > >":
        return _openstudiomodelgeometry.SpaceType_electricEquipment(self)

    def electricEquipmentITEAirCooled(self) -> "std::vector< openstudio::model::ElectricEquipmentITEAirCooled,std::allocator< openstudio::model::ElectricEquipmentITEAirCooled > >":
        return _openstudiomodelgeometry.SpaceType_electricEquipmentITEAirCooled(self)

    def gasEquipment(self) -> "std::vector< openstudio::model::GasEquipment,std::allocator< openstudio::model::GasEquipment > >":
        return _openstudiomodelgeometry.SpaceType_gasEquipment(self)

    def hotWaterEquipment(self) -> "std::vector< openstudio::model::HotWaterEquipment,std::allocator< openstudio::model::HotWaterEquipment > >":
        return _openstudiomodelgeometry.SpaceType_hotWaterEquipment(self)

    def steamEquipment(self) -> "std::vector< openstudio::model::SteamEquipment,std::allocator< openstudio::model::SteamEquipment > >":
        return _openstudiomodelgeometry.SpaceType_steamEquipment(self)

    def otherEquipment(self) -> "std::vector< openstudio::model::OtherEquipment,std::allocator< openstudio::model::OtherEquipment > >":
        return _openstudiomodelgeometry.SpaceType_otherEquipment(self)

    def spaceInfiltrationDesignFlowRates(self) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate,std::allocator< openstudio::model::SpaceInfiltrationDesignFlowRate > >":
        return _openstudiomodelgeometry.SpaceType_spaceInfiltrationDesignFlowRates(self)

    def spaceInfiltrationEffectiveLeakageAreas(self) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea,std::allocator< openstudio::model::SpaceInfiltrationEffectiveLeakageArea > >":
        return _openstudiomodelgeometry.SpaceType_spaceInfiltrationEffectiveLeakageAreas(self)

    def designSpecificationOutdoorAir(self) -> "boost::optional< openstudio::model::DesignSpecificationOutdoorAir >":
        return _openstudiomodelgeometry.SpaceType_designSpecificationOutdoorAir(self)

    def isDesignSpecificationOutdoorAirDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SpaceType_isDesignSpecificationOutdoorAirDefaulted(self)

    def setDesignSpecificationOutdoorAir(self, designSpecificationOutdoorAir: "DesignSpecificationOutdoorAir") -> "bool":
        return _openstudiomodelgeometry.SpaceType_setDesignSpecificationOutdoorAir(self, designSpecificationOutdoorAir)

    def resetDesignSpecificationOutdoorAir(self) -> "void":
        return _openstudiomodelgeometry.SpaceType_resetDesignSpecificationOutdoorAir(self)

    def hardApplySpaceLoadSchedules(self) -> "void":
        return _openstudiomodelgeometry.SpaceType_hardApplySpaceLoadSchedules(self)

    def peoplePerFloorArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SpaceType_peoplePerFloorArea(self)

    def setPeoplePerFloorArea(self, *args) -> "bool":
        return _openstudiomodelgeometry.SpaceType_setPeoplePerFloorArea(self, *args)

    def spaceFloorAreaPerPerson(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SpaceType_spaceFloorAreaPerPerson(self)

    def setSpaceFloorAreaPerPerson(self, *args) -> "bool":
        return _openstudiomodelgeometry.SpaceType_setSpaceFloorAreaPerPerson(self, *args)

    def getNumberOfPeople(self, floorArea: "double") -> "double":
        return _openstudiomodelgeometry.SpaceType_getNumberOfPeople(self, floorArea)

    def getPeoplePerFloorArea(self, floorArea: "double") -> "double":
        return _openstudiomodelgeometry.SpaceType_getPeoplePerFloorArea(self, floorArea)

    def getFloorAreaPerPerson(self, floorArea: "double") -> "double":
        return _openstudiomodelgeometry.SpaceType_getFloorAreaPerPerson(self, floorArea)

    def lightingPowerPerFloorArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SpaceType_lightingPowerPerFloorArea(self)

    def setLightingPowerPerFloorArea(self, *args) -> "bool":
        return _openstudiomodelgeometry.SpaceType_setLightingPowerPerFloorArea(self, *args)

    def lightingPowerPerPerson(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SpaceType_lightingPowerPerPerson(self)

    def setLightingPowerPerPerson(self, *args) -> "bool":
        return _openstudiomodelgeometry.SpaceType_setLightingPowerPerPerson(self, *args)

    def getLightingPower(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.SpaceType_getLightingPower(self, floorArea, numPeople)

    def getLightingPowerPerFloorArea(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.SpaceType_getLightingPowerPerFloorArea(self, floorArea, numPeople)

    def getLightingPowerPerPerson(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.SpaceType_getLightingPowerPerPerson(self, floorArea, numPeople)

    def electricEquipmentPowerPerFloorArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SpaceType_electricEquipmentPowerPerFloorArea(self)

    def setElectricEquipmentPowerPerFloorArea(self, *args) -> "bool":
        return _openstudiomodelgeometry.SpaceType_setElectricEquipmentPowerPerFloorArea(self, *args)

    def electricEquipmentPowerPerPerson(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SpaceType_electricEquipmentPowerPerPerson(self)

    def setElectricEquipmentPowerPerPerson(self, *args) -> "bool":
        return _openstudiomodelgeometry.SpaceType_setElectricEquipmentPowerPerPerson(self, *args)

    def getElectricEquipmentDesignLevel(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.SpaceType_getElectricEquipmentDesignLevel(self, floorArea, numPeople)

    def getElectricEquipmentPowerPerFloorArea(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.SpaceType_getElectricEquipmentPowerPerFloorArea(self, floorArea, numPeople)

    def getElectricEquipmentPowerPerPerson(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.SpaceType_getElectricEquipmentPowerPerPerson(self, floorArea, numPeople)

    def electricEquipmentITEAirCooledPowerPerFloorArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SpaceType_electricEquipmentITEAirCooledPowerPerFloorArea(self)

    def gasEquipmentPowerPerFloorArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SpaceType_gasEquipmentPowerPerFloorArea(self)

    def setGasEquipmentPowerPerFloorArea(self, *args) -> "bool":
        return _openstudiomodelgeometry.SpaceType_setGasEquipmentPowerPerFloorArea(self, *args)

    def gasEquipmentPowerPerPerson(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SpaceType_gasEquipmentPowerPerPerson(self)

    def setGasEquipmentPowerPerPerson(self, *args) -> "bool":
        return _openstudiomodelgeometry.SpaceType_setGasEquipmentPowerPerPerson(self, *args)

    def getGasEquipmentDesignLevel(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.SpaceType_getGasEquipmentDesignLevel(self, floorArea, numPeople)

    def getGasEquipmentPowerPerFloorArea(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.SpaceType_getGasEquipmentPowerPerFloorArea(self, floorArea, numPeople)

    def getGasEquipmentPowerPerPerson(self, floorArea: "double", numPeople: "double") -> "double":
        return _openstudiomodelgeometry.SpaceType_getGasEquipmentPowerPerPerson(self, floorArea, numPeople)

    def floorArea(self) -> "double":
        return _openstudiomodelgeometry.SpaceType_floorArea(self)

    def setNameProtected(self, newName: "std::string const &") -> "boost::optional< std::string >":
        return _openstudiomodelgeometry.SpaceType_setNameProtected(self, newName)

# Register SpaceType in _openstudiomodelgeometry:
_openstudiomodelgeometry.SpaceType_swigregister(SpaceType)

def SpaceType_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.SpaceType_iddObjectType()


def toSpaceType(idfObject: "IdfObject") -> "boost::optional< openstudio::model::SpaceType >":
    return _openstudiomodelgeometry.toSpaceType(idfObject)

def getSpaceType(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::SpaceType >":
    return _openstudiomodelgeometry.getSpaceType(t_model, t_handle)

def getSpaceTypes(t_model: "Model") -> "std::vector< openstudio::model::SpaceType,std::allocator< openstudio::model::SpaceType > >":
    return _openstudiomodelgeometry.getSpaceTypes(t_model)

def getSpaceTypeByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::SpaceType >":
    return _openstudiomodelgeometry.getSpaceTypeByName(t_model, t_name)

def getSpaceTypesByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::SpaceType,std::allocator< openstudio::model::SpaceType > >":
    return _openstudiomodelgeometry.getSpaceTypesByName(t_model, t_name, t_exactMatch)

def _to_SpaceType(self) -> OptionalSpaceType:
    return toSpaceType(self)
openstudioutilitiesidf.IdfObject.to_SpaceType = _to_SpaceType

def _getSpaceType(self, t_handle: "UUID") -> OptionalSpaceType:
    return getSpaceType(self, t_handle)
Model.getSpaceType = _getSpaceType

def _getSpaceType(self, t_handle_str: str) -> OptionalSpaceType:
    return getSpaceType(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getSpaceType = _getSpaceType

def _getSpaceTypes(self) -> SpaceTypeVector:
    return getSpaceTypes(self)
Model.getSpaceTypes = _getSpaceTypes

def _getSpaceTypeByName(self, t_name: str) -> OptionalSpaceType:
    return getSpaceTypeByName(self, t_name)
Model.getSpaceTypeByName = _getSpaceTypeByName

def _getSpaceTypesByName(self, t_name: str, t_exactMatch: bool) -> SpaceTypeVector:
    return getSpaceTypesByName(self, t_name, t_exactMatch)
Model.getSpaceTypesByName = _getSpaceTypesByName

class LightingSimulationZone(openstudiomodelcore.ModelObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, model: "Model"):
        _openstudiomodelgeometry.LightingSimulationZone_swiginit(self, _openstudiomodelgeometry.new_LightingSimulationZone(model))
    __swig_destroy__ = _openstudiomodelgeometry.delete_LightingSimulationZone

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.LightingSimulationZone_iddObjectType()

    def renderingColor(self) -> "boost::optional< openstudio::model::RenderingColor >":
        return _openstudiomodelgeometry.LightingSimulationZone_renderingColor(self)

    def setRenderingColor(self, renderingColor: "RenderingColor") -> "bool":
        return _openstudiomodelgeometry.LightingSimulationZone_setRenderingColor(self, renderingColor)

    def resetRenderingColor(self) -> "void":
        return _openstudiomodelgeometry.LightingSimulationZone_resetRenderingColor(self)

    def spaces(self) -> "std::vector< openstudio::model::Space,std::allocator< openstudio::model::Space > >":
        return _openstudiomodelgeometry.LightingSimulationZone_spaces(self)

    def addSpace(self, space: "Space") -> "bool":
        return _openstudiomodelgeometry.LightingSimulationZone_addSpace(self, space)

    def resetSpaces(self) -> "void":
        return _openstudiomodelgeometry.LightingSimulationZone_resetSpaces(self)

# Register LightingSimulationZone in _openstudiomodelgeometry:
_openstudiomodelgeometry.LightingSimulationZone_swigregister(LightingSimulationZone)

def LightingSimulationZone_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.LightingSimulationZone_iddObjectType()


def toLightingSimulationZone(idfObject: "IdfObject") -> "boost::optional< openstudio::model::LightingSimulationZone >":
    return _openstudiomodelgeometry.toLightingSimulationZone(idfObject)

def getLightingSimulationZone(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::LightingSimulationZone >":
    return _openstudiomodelgeometry.getLightingSimulationZone(t_model, t_handle)

def getLightingSimulationZones(t_model: "Model") -> "std::vector< openstudio::model::LightingSimulationZone,std::allocator< openstudio::model::LightingSimulationZone > >":
    return _openstudiomodelgeometry.getLightingSimulationZones(t_model)

def getLightingSimulationZoneByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::LightingSimulationZone >":
    return _openstudiomodelgeometry.getLightingSimulationZoneByName(t_model, t_name)

def getLightingSimulationZonesByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::LightingSimulationZone,std::allocator< openstudio::model::LightingSimulationZone > >":
    return _openstudiomodelgeometry.getLightingSimulationZonesByName(t_model, t_name, t_exactMatch)

def _to_LightingSimulationZone(self) -> OptionalLightingSimulationZone:
    return toLightingSimulationZone(self)
openstudioutilitiesidf.IdfObject.to_LightingSimulationZone = _to_LightingSimulationZone

def _getLightingSimulationZone(self, t_handle: "UUID") -> OptionalLightingSimulationZone:
    return getLightingSimulationZone(self, t_handle)
Model.getLightingSimulationZone = _getLightingSimulationZone

def _getLightingSimulationZone(self, t_handle_str: str) -> OptionalLightingSimulationZone:
    return getLightingSimulationZone(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getLightingSimulationZone = _getLightingSimulationZone

def _getLightingSimulationZones(self) -> LightingSimulationZoneVector:
    return getLightingSimulationZones(self)
Model.getLightingSimulationZones = _getLightingSimulationZones

def _getLightingSimulationZoneByName(self, t_name: str) -> OptionalLightingSimulationZone:
    return getLightingSimulationZoneByName(self, t_name)
Model.getLightingSimulationZoneByName = _getLightingSimulationZoneByName

def _getLightingSimulationZonesByName(self, t_name: str, t_exactMatch: bool) -> LightingSimulationZoneVector:
    return getLightingSimulationZonesByName(self, t_name, t_exactMatch)
Model.getLightingSimulationZonesByName = _getLightingSimulationZonesByName

class CustomBlock(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, material: "Material", depth: "double", xPosition: "double", zPosition: "double"):
        _openstudiomodelgeometry.CustomBlock_swiginit(self, _openstudiomodelgeometry.new_CustomBlock(material, depth, xPosition, zPosition))

    def material(self) -> "openstudio::model::Material":
        return _openstudiomodelgeometry.CustomBlock_material(self)

    def depth(self) -> "double":
        return _openstudiomodelgeometry.CustomBlock_depth(self)

    def xPosition(self) -> "double":
        return _openstudiomodelgeometry.CustomBlock_xPosition(self)

    def zPosition(self) -> "double":
        return _openstudiomodelgeometry.CustomBlock_zPosition(self)

    def __str__(self) -> "std::string":
        return _openstudiomodelgeometry.CustomBlock___str__(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_CustomBlock

# Register CustomBlock in _openstudiomodelgeometry:
_openstudiomodelgeometry.CustomBlock_swigregister(CustomBlock)

class FoundationKiva(openstudiomodelcore.ModelObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, model: "Model"):
        _openstudiomodelgeometry.FoundationKiva_swiginit(self, _openstudiomodelgeometry.new_FoundationKiva(model))
    __swig_destroy__ = _openstudiomodelgeometry.delete_FoundationKiva

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.FoundationKiva_iddObjectType()

    def addCustomBlock(self, *args) -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_addCustomBlock(self, *args)

    def removeCustomBlock(self, groupIndex: "int") -> "void":
        return _openstudiomodelgeometry.FoundationKiva_removeCustomBlock(self, groupIndex)

    def removeAllCustomBlocks(self) -> "void":
        return _openstudiomodelgeometry.FoundationKiva_removeAllCustomBlocks(self)

    def customBlocks(self) -> "std::vector< openstudio::model::CustomBlock,std::allocator< openstudio::model::CustomBlock > >":
        return _openstudiomodelgeometry.FoundationKiva_customBlocks(self)

    def addCustomBlocks(self, customBlocks: "CustomBlockVector") -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_addCustomBlocks(self, customBlocks)

    def initialIndoorAirTemperature(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.FoundationKiva_initialIndoorAirTemperature(self)

    def interiorHorizontalInsulationMaterial(self) -> "boost::optional< openstudio::model::Material >":
        return _openstudiomodelgeometry.FoundationKiva_interiorHorizontalInsulationMaterial(self)

    def interiorHorizontalInsulationDepth(self) -> "double":
        return _openstudiomodelgeometry.FoundationKiva_interiorHorizontalInsulationDepth(self)

    def isInteriorHorizontalInsulationDepthDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_isInteriorHorizontalInsulationDepthDefaulted(self)

    def interiorHorizontalInsulationWidth(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.FoundationKiva_interiorHorizontalInsulationWidth(self)

    def interiorVerticalInsulationMaterial(self) -> "boost::optional< openstudio::model::Material >":
        return _openstudiomodelgeometry.FoundationKiva_interiorVerticalInsulationMaterial(self)

    def interiorVerticalInsulationDepth(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.FoundationKiva_interiorVerticalInsulationDepth(self)

    def exteriorHorizontalInsulationMaterial(self) -> "boost::optional< openstudio::model::Material >":
        return _openstudiomodelgeometry.FoundationKiva_exteriorHorizontalInsulationMaterial(self)

    def exteriorHorizontalInsulationDepth(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.FoundationKiva_exteriorHorizontalInsulationDepth(self)

    def exteriorHorizontalInsulationWidth(self) -> "double":
        return _openstudiomodelgeometry.FoundationKiva_exteriorHorizontalInsulationWidth(self)

    def isExteriorHorizontalInsulationWidthDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_isExteriorHorizontalInsulationWidthDefaulted(self)

    def exteriorVerticalInsulationMaterial(self) -> "boost::optional< openstudio::model::Material >":
        return _openstudiomodelgeometry.FoundationKiva_exteriorVerticalInsulationMaterial(self)

    def exteriorVerticalInsulationDepth(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.FoundationKiva_exteriorVerticalInsulationDepth(self)

    def wallHeightAboveGrade(self) -> "double":
        return _openstudiomodelgeometry.FoundationKiva_wallHeightAboveGrade(self)

    def isWallHeightAboveGradeDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_isWallHeightAboveGradeDefaulted(self)

    def wallDepthBelowSlab(self) -> "double":
        return _openstudiomodelgeometry.FoundationKiva_wallDepthBelowSlab(self)

    def isWallDepthBelowSlabDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_isWallDepthBelowSlabDefaulted(self)

    def footingWallConstruction(self) -> "boost::optional< openstudio::model::ConstructionBase >":
        return _openstudiomodelgeometry.FoundationKiva_footingWallConstruction(self)

    def footingMaterial(self) -> "boost::optional< openstudio::model::Material >":
        return _openstudiomodelgeometry.FoundationKiva_footingMaterial(self)

    def footingDepth(self) -> "double":
        return _openstudiomodelgeometry.FoundationKiva_footingDepth(self)

    def isFootingDepthDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_isFootingDepthDefaulted(self)

    def surfaces(self) -> "std::vector< openstudio::model::Surface,std::allocator< openstudio::model::Surface > >":
        return _openstudiomodelgeometry.FoundationKiva_surfaces(self)

    def numberofCustomBlocks(self) -> "unsigned int":
        return _openstudiomodelgeometry.FoundationKiva_numberofCustomBlocks(self)

    def setInitialIndoorAirTemperature(self, initialIndoorAirTemperature: "double") -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setInitialIndoorAirTemperature(self, initialIndoorAirTemperature)

    def setInteriorHorizontalInsulationMaterial(self, material: "Material") -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setInteriorHorizontalInsulationMaterial(self, material)

    def resetInteriorHorizontalInsulationMaterial(self) -> "void":
        return _openstudiomodelgeometry.FoundationKiva_resetInteriorHorizontalInsulationMaterial(self)

    def setInteriorHorizontalInsulationDepth(self, interiorHorizontalInsulationDepth: "double") -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setInteriorHorizontalInsulationDepth(self, interiorHorizontalInsulationDepth)

    def resetInteriorHorizontalInsulationDepth(self) -> "void":
        return _openstudiomodelgeometry.FoundationKiva_resetInteriorHorizontalInsulationDepth(self)

    def setInteriorHorizontalInsulationWidth(self, interiorHorizontalInsulationWidth: "double") -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setInteriorHorizontalInsulationWidth(self, interiorHorizontalInsulationWidth)

    def setInteriorVerticalInsulationMaterial(self, material: "Material") -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setInteriorVerticalInsulationMaterial(self, material)

    def resetInteriorVerticalInsulationMaterial(self) -> "void":
        return _openstudiomodelgeometry.FoundationKiva_resetInteriorVerticalInsulationMaterial(self)

    def setInteriorVerticalInsulationDepth(self, interiorVerticalInsulationDepth: "double") -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setInteriorVerticalInsulationDepth(self, interiorVerticalInsulationDepth)

    def setExteriorHorizontalInsulationMaterial(self, material: "Material") -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setExteriorHorizontalInsulationMaterial(self, material)

    def resetExteriorHorizontalInsulationMaterial(self) -> "void":
        return _openstudiomodelgeometry.FoundationKiva_resetExteriorHorizontalInsulationMaterial(self)

    def setExteriorHorizontalInsulationDepth(self, exteriorHorizontalInsulationDepth: "double") -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setExteriorHorizontalInsulationDepth(self, exteriorHorizontalInsulationDepth)

    def setExteriorHorizontalInsulationWidth(self, exteriorHorizontalInsulationWidth: "double") -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setExteriorHorizontalInsulationWidth(self, exteriorHorizontalInsulationWidth)

    def resetExteriorHorizontalInsulationWidth(self) -> "void":
        return _openstudiomodelgeometry.FoundationKiva_resetExteriorHorizontalInsulationWidth(self)

    def setExteriorVerticalInsulationMaterial(self, material: "Material") -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setExteriorVerticalInsulationMaterial(self, material)

    def resetExteriorVerticalInsulationMaterial(self) -> "void":
        return _openstudiomodelgeometry.FoundationKiva_resetExteriorVerticalInsulationMaterial(self)

    def setExteriorVerticalInsulationDepth(self, exteriorVerticalInsulationDepth: "double") -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setExteriorVerticalInsulationDepth(self, exteriorVerticalInsulationDepth)

    def setWallHeightAboveGrade(self, wallHeightAboveGrade: "double") -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setWallHeightAboveGrade(self, wallHeightAboveGrade)

    def resetWallHeightAboveGrade(self) -> "void":
        return _openstudiomodelgeometry.FoundationKiva_resetWallHeightAboveGrade(self)

    def setWallDepthBelowSlab(self, wallDepthBelowSlab: "double") -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setWallDepthBelowSlab(self, wallDepthBelowSlab)

    def resetWallDepthBelowSlab(self) -> "void":
        return _openstudiomodelgeometry.FoundationKiva_resetWallDepthBelowSlab(self)

    def setFootingWallConstruction(self, construction: "ConstructionBase") -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setFootingWallConstruction(self, construction)

    def resetFootingWallConstruction(self) -> "void":
        return _openstudiomodelgeometry.FoundationKiva_resetFootingWallConstruction(self)

    def setFootingMaterial(self, material: "Material") -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setFootingMaterial(self, material)

    def resetFootingMaterial(self) -> "void":
        return _openstudiomodelgeometry.FoundationKiva_resetFootingMaterial(self)

    def setFootingDepth(self, footingDepth: "double") -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setFootingDepth(self, footingDepth)

    def resetFootingDepth(self) -> "void":
        return _openstudiomodelgeometry.FoundationKiva_resetFootingDepth(self)

# Register FoundationKiva in _openstudiomodelgeometry:
_openstudiomodelgeometry.FoundationKiva_swigregister(FoundationKiva)

def FoundationKiva_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.FoundationKiva_iddObjectType()


def toFoundationKiva(idfObject: "IdfObject") -> "boost::optional< openstudio::model::FoundationKiva >":
    return _openstudiomodelgeometry.toFoundationKiva(idfObject)

def getFoundationKiva(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::FoundationKiva >":
    return _openstudiomodelgeometry.getFoundationKiva(t_model, t_handle)

def getFoundationKivas(t_model: "Model") -> "std::vector< openstudio::model::FoundationKiva,std::allocator< openstudio::model::FoundationKiva > >":
    return _openstudiomodelgeometry.getFoundationKivas(t_model)

def getFoundationKivaByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::FoundationKiva >":
    return _openstudiomodelgeometry.getFoundationKivaByName(t_model, t_name)

def getFoundationKivasByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::FoundationKiva,std::allocator< openstudio::model::FoundationKiva > >":
    return _openstudiomodelgeometry.getFoundationKivasByName(t_model, t_name, t_exactMatch)

def _to_FoundationKiva(self) -> OptionalFoundationKiva:
    return toFoundationKiva(self)
openstudioutilitiesidf.IdfObject.to_FoundationKiva = _to_FoundationKiva

def _getFoundationKiva(self, t_handle: "UUID") -> OptionalFoundationKiva:
    return getFoundationKiva(self, t_handle)
Model.getFoundationKiva = _getFoundationKiva

def _getFoundationKiva(self, t_handle_str: str) -> OptionalFoundationKiva:
    return getFoundationKiva(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getFoundationKiva = _getFoundationKiva

def _getFoundationKivas(self) -> FoundationKivaVector:
    return getFoundationKivas(self)
Model.getFoundationKivas = _getFoundationKivas

def _getFoundationKivaByName(self, t_name: str) -> OptionalFoundationKiva:
    return getFoundationKivaByName(self, t_name)
Model.getFoundationKivaByName = _getFoundationKivaByName

def _getFoundationKivasByName(self, t_name: str, t_exactMatch: bool) -> FoundationKivaVector:
    return getFoundationKivasByName(self, t_name, t_exactMatch)
Model.getFoundationKivasByName = _getFoundationKivasByName

class SurfacePropertyExposedFoundationPerimeter(openstudiomodelcore.ModelObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, surface: "Surface", exposedPerimeterCalculationMethod: "std::string", exposedPerimeter: "double"):
        _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeter_swiginit(self, _openstudiomodelgeometry.new_SurfacePropertyExposedFoundationPerimeter(surface, exposedPerimeterCalculationMethod, exposedPerimeter))
    __swig_destroy__ = _openstudiomodelgeometry.delete_SurfacePropertyExposedFoundationPerimeter

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeter_iddObjectType()

    def surfaceName(self) -> "std::string":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeter_surfaceName(self)

    def exposedPerimeterCalculationMethod(self) -> "std::string":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeter_exposedPerimeterCalculationMethod(self)

    def totalExposedPerimeter(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeter_totalExposedPerimeter(self)

    def exposedPerimeterFraction(self) -> "double":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeter_exposedPerimeterFraction(self)

    def isExposedPerimeterFractionDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeter_isExposedPerimeterFractionDefaulted(self)

    def setExposedPerimeterCalculationMethod(self, exposedPerimeterCalculationMethod: "std::string") -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeter_setExposedPerimeterCalculationMethod(self, exposedPerimeterCalculationMethod)

    def setTotalExposedPerimeter(self, totalExposedPerimeter: "double") -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeter_setTotalExposedPerimeter(self, totalExposedPerimeter)

    def setExposedPerimeterFraction(self, exposedPerimeterFraction: "double") -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeter_setExposedPerimeterFraction(self, exposedPerimeterFraction)

    def resetExposedPerimeterFraction(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeter_resetExposedPerimeterFraction(self)

# Register SurfacePropertyExposedFoundationPerimeter in _openstudiomodelgeometry:
_openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeter_swigregister(SurfacePropertyExposedFoundationPerimeter)

def SurfacePropertyExposedFoundationPerimeter_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeter_iddObjectType()


def toSurfacePropertyExposedFoundationPerimeter(idfObject: "IdfObject") -> "boost::optional< openstudio::model::SurfacePropertyExposedFoundationPerimeter >":
    return _openstudiomodelgeometry.toSurfacePropertyExposedFoundationPerimeter(idfObject)

def getSurfacePropertyExposedFoundationPerimeter(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::SurfacePropertyExposedFoundationPerimeter >":
    return _openstudiomodelgeometry.getSurfacePropertyExposedFoundationPerimeter(t_model, t_handle)

def getSurfacePropertyExposedFoundationPerimeters(t_model: "Model") -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter,std::allocator< openstudio::model::SurfacePropertyExposedFoundationPerimeter > >":
    return _openstudiomodelgeometry.getSurfacePropertyExposedFoundationPerimeters(t_model)

def getSurfacePropertyExposedFoundationPerimeterByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::SurfacePropertyExposedFoundationPerimeter >":
    return _openstudiomodelgeometry.getSurfacePropertyExposedFoundationPerimeterByName(t_model, t_name)

def getSurfacePropertyExposedFoundationPerimetersByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter,std::allocator< openstudio::model::SurfacePropertyExposedFoundationPerimeter > >":
    return _openstudiomodelgeometry.getSurfacePropertyExposedFoundationPerimetersByName(t_model, t_name, t_exactMatch)

def _to_SurfacePropertyExposedFoundationPerimeter(self) -> OptionalSurfacePropertyExposedFoundationPerimeter:
    return toSurfacePropertyExposedFoundationPerimeter(self)
openstudioutilitiesidf.IdfObject.to_SurfacePropertyExposedFoundationPerimeter = _to_SurfacePropertyExposedFoundationPerimeter

def _getSurfacePropertyExposedFoundationPerimeter(self, t_handle: "UUID") -> OptionalSurfacePropertyExposedFoundationPerimeter:
    return getSurfacePropertyExposedFoundationPerimeter(self, t_handle)
Model.getSurfacePropertyExposedFoundationPerimeter = _getSurfacePropertyExposedFoundationPerimeter

def _getSurfacePropertyExposedFoundationPerimeter(self, t_handle_str: str) -> OptionalSurfacePropertyExposedFoundationPerimeter:
    return getSurfacePropertyExposedFoundationPerimeter(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getSurfacePropertyExposedFoundationPerimeter = _getSurfacePropertyExposedFoundationPerimeter

def _getSurfacePropertyExposedFoundationPerimeters(self) -> SurfacePropertyExposedFoundationPerimeterVector:
    return getSurfacePropertyExposedFoundationPerimeters(self)
Model.getSurfacePropertyExposedFoundationPerimeters = _getSurfacePropertyExposedFoundationPerimeters

def _getSurfacePropertyExposedFoundationPerimeterByName(self, t_name: str) -> OptionalSurfacePropertyExposedFoundationPerimeter:
    return getSurfacePropertyExposedFoundationPerimeterByName(self, t_name)
Model.getSurfacePropertyExposedFoundationPerimeterByName = _getSurfacePropertyExposedFoundationPerimeterByName

def _getSurfacePropertyExposedFoundationPerimetersByName(self, t_name: str, t_exactMatch: bool) -> SurfacePropertyExposedFoundationPerimeterVector:
    return getSurfacePropertyExposedFoundationPerimetersByName(self, t_name, t_exactMatch)
Model.getSurfacePropertyExposedFoundationPerimetersByName = _getSurfacePropertyExposedFoundationPerimetersByName

class ViewFactor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fromSurface: "ModelObject", toSurface: "ModelObject", viewFactor: "double"):
        _openstudiomodelgeometry.ViewFactor_swiginit(self, _openstudiomodelgeometry.new_ViewFactor(fromSurface, toSurface, viewFactor))

    def fromSurface(self) -> "openstudio::model::ModelObject":
        return _openstudiomodelgeometry.ViewFactor_fromSurface(self)

    def toSurface(self) -> "openstudio::model::ModelObject":
        return _openstudiomodelgeometry.ViewFactor_toSurface(self)

    def viewFactor(self) -> "double":
        return _openstudiomodelgeometry.ViewFactor_viewFactor(self)

    def __str__(self) -> "std::string":
        return _openstudiomodelgeometry.ViewFactor___str__(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_ViewFactor

# Register ViewFactor in _openstudiomodelgeometry:
_openstudiomodelgeometry.ViewFactor_swigregister(ViewFactor)


def __lshift__(*args) -> "std::ostream &":
    return _openstudiomodelgeometry.__lshift__(*args)
class ZonePropertyUserViewFactorsBySurfaceName(openstudiomodelcore.ModelObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, thermalZone: "openstudio::model::ThermalZone const &"):
        _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceName_swiginit(self, _openstudiomodelgeometry.new_ZonePropertyUserViewFactorsBySurfaceName(thermalZone))
    __swig_destroy__ = _openstudiomodelgeometry.delete_ZonePropertyUserViewFactorsBySurfaceName

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceName_iddObjectType()

    def thermalZone(self) -> "openstudio::model::ThermalZone":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceName_thermalZone(self)

    def viewFactors(self) -> "std::vector< openstudio::model::ViewFactor,std::allocator< openstudio::model::ViewFactor > >":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceName_viewFactors(self)

    def numberofViewFactors(self) -> "unsigned int":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceName_numberofViewFactors(self)

    def viewFactorIndex(self, viewFactor: "ViewFactor") -> "boost::optional< unsigned int >":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceName_viewFactorIndex(self, viewFactor)

    def getViewFactor(self, groupIndex: "unsigned int") -> "boost::optional< openstudio::model::ViewFactor >":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceName_getViewFactor(self, groupIndex)

    def addViewFactor(self, *args) -> "bool":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceName_addViewFactor(self, *args)

    def addViewFactors(self, viewFactors: "ViewFactorVector") -> "bool":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceName_addViewFactors(self, viewFactors)

    def removeViewFactor(self, groupIndex: "int") -> "void":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceName_removeViewFactor(self, groupIndex)

    def removeAllViewFactors(self) -> "void":
        return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceName_removeAllViewFactors(self)

# Register ZonePropertyUserViewFactorsBySurfaceName in _openstudiomodelgeometry:
_openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceName_swigregister(ZonePropertyUserViewFactorsBySurfaceName)

def ZonePropertyUserViewFactorsBySurfaceName_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.ZonePropertyUserViewFactorsBySurfaceName_iddObjectType()


def toZonePropertyUserViewFactorsBySurfaceName(idfObject: "IdfObject") -> "boost::optional< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName >":
    return _openstudiomodelgeometry.toZonePropertyUserViewFactorsBySurfaceName(idfObject)

def getZonePropertyUserViewFactorsBySurfaceName(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName >":
    return _openstudiomodelgeometry.getZonePropertyUserViewFactorsBySurfaceName(t_model, t_handle)

def getZonePropertyUserViewFactorsBySurfaceNames(t_model: "Model") -> "std::vector< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName,std::allocator< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName > >":
    return _openstudiomodelgeometry.getZonePropertyUserViewFactorsBySurfaceNames(t_model)

def getZonePropertyUserViewFactorsBySurfaceNameByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName >":
    return _openstudiomodelgeometry.getZonePropertyUserViewFactorsBySurfaceNameByName(t_model, t_name)

def getZonePropertyUserViewFactorsBySurfaceNamesByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName,std::allocator< openstudio::model::ZonePropertyUserViewFactorsBySurfaceName > >":
    return _openstudiomodelgeometry.getZonePropertyUserViewFactorsBySurfaceNamesByName(t_model, t_name, t_exactMatch)

def _to_ZonePropertyUserViewFactorsBySurfaceName(self) -> OptionalZonePropertyUserViewFactorsBySurfaceName:
    return toZonePropertyUserViewFactorsBySurfaceName(self)
openstudioutilitiesidf.IdfObject.to_ZonePropertyUserViewFactorsBySurfaceName = _to_ZonePropertyUserViewFactorsBySurfaceName

def _getZonePropertyUserViewFactorsBySurfaceName(self, t_handle: "UUID") -> OptionalZonePropertyUserViewFactorsBySurfaceName:
    return getZonePropertyUserViewFactorsBySurfaceName(self, t_handle)
Model.getZonePropertyUserViewFactorsBySurfaceName = _getZonePropertyUserViewFactorsBySurfaceName

def _getZonePropertyUserViewFactorsBySurfaceName(self, t_handle_str: str) -> OptionalZonePropertyUserViewFactorsBySurfaceName:
    return getZonePropertyUserViewFactorsBySurfaceName(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getZonePropertyUserViewFactorsBySurfaceName = _getZonePropertyUserViewFactorsBySurfaceName

def _getZonePropertyUserViewFactorsBySurfaceNames(self) -> ZonePropertyUserViewFactorsBySurfaceNameVector:
    return getZonePropertyUserViewFactorsBySurfaceNames(self)
Model.getZonePropertyUserViewFactorsBySurfaceNames = _getZonePropertyUserViewFactorsBySurfaceNames

def _getZonePropertyUserViewFactorsBySurfaceNameByName(self, t_name: str) -> OptionalZonePropertyUserViewFactorsBySurfaceName:
    return getZonePropertyUserViewFactorsBySurfaceNameByName(self, t_name)
Model.getZonePropertyUserViewFactorsBySurfaceNameByName = _getZonePropertyUserViewFactorsBySurfaceNameByName

def _getZonePropertyUserViewFactorsBySurfaceNamesByName(self, t_name: str, t_exactMatch: bool) -> ZonePropertyUserViewFactorsBySurfaceNameVector:
    return getZonePropertyUserViewFactorsBySurfaceNamesByName(self, t_name, t_exactMatch)
Model.getZonePropertyUserViewFactorsBySurfaceNamesByName = _getZonePropertyUserViewFactorsBySurfaceNamesByName

class ExteriorLoadInstance(openstudiomodelcore.ModelObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomodelgeometry.delete_ExteriorLoadInstance

    def definition(self) -> "openstudio::model::ExteriorLoadDefinition":
        return _openstudiomodelgeometry.ExteriorLoadInstance_definition(self)

    def setDefinition(self, definition: "ExteriorLoadDefinition") -> "bool":
        return _openstudiomodelgeometry.ExteriorLoadInstance_setDefinition(self, definition)

    def makeUnique(self) -> "void":
        return _openstudiomodelgeometry.ExteriorLoadInstance_makeUnique(self)

    def multiplier(self) -> "double":
        return _openstudiomodelgeometry.ExteriorLoadInstance_multiplier(self)

    def isMultiplierDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorLoadInstance_isMultiplierDefaulted(self)

    def quantity(self) -> "int":
        return _openstudiomodelgeometry.ExteriorLoadInstance_quantity(self)

# Register ExteriorLoadInstance in _openstudiomodelgeometry:
_openstudiomodelgeometry.ExteriorLoadInstance_swigregister(ExteriorLoadInstance)


def toExteriorLoadInstance(idfObject: "IdfObject") -> "boost::optional< openstudio::model::ExteriorLoadInstance >":
    return _openstudiomodelgeometry.toExteriorLoadInstance(idfObject)

def getExteriorLoadInstance(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::ExteriorLoadInstance >":
    return _openstudiomodelgeometry.getExteriorLoadInstance(t_model, t_handle)

def getExteriorLoadInstances(t_model: "Model") -> "std::vector< openstudio::model::ExteriorLoadInstance,std::allocator< openstudio::model::ExteriorLoadInstance > >":
    return _openstudiomodelgeometry.getExteriorLoadInstances(t_model)

def getExteriorLoadInstanceByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::ExteriorLoadInstance >":
    return _openstudiomodelgeometry.getExteriorLoadInstanceByName(t_model, t_name)

def getExteriorLoadInstancesByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::ExteriorLoadInstance,std::allocator< openstudio::model::ExteriorLoadInstance > >":
    return _openstudiomodelgeometry.getExteriorLoadInstancesByName(t_model, t_name, t_exactMatch)

def _to_ExteriorLoadInstance(self) -> OptionalExteriorLoadInstance:
    return toExteriorLoadInstance(self)
openstudioutilitiesidf.IdfObject.to_ExteriorLoadInstance = _to_ExteriorLoadInstance

def _getExteriorLoadInstance(self, t_handle: "UUID") -> OptionalExteriorLoadInstance:
    return getExteriorLoadInstance(self, t_handle)
Model.getExteriorLoadInstance = _getExteriorLoadInstance

def _getExteriorLoadInstance(self, t_handle_str: str) -> OptionalExteriorLoadInstance:
    return getExteriorLoadInstance(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getExteriorLoadInstance = _getExteriorLoadInstance

def _getExteriorLoadInstances(self) -> ExteriorLoadInstanceVector:
    return getExteriorLoadInstances(self)
Model.getExteriorLoadInstances = _getExteriorLoadInstances

def _getExteriorLoadInstanceByName(self, t_name: str) -> OptionalExteriorLoadInstance:
    return getExteriorLoadInstanceByName(self, t_name)
Model.getExteriorLoadInstanceByName = _getExteriorLoadInstanceByName

def _getExteriorLoadInstancesByName(self, t_name: str, t_exactMatch: bool) -> ExteriorLoadInstanceVector:
    return getExteriorLoadInstancesByName(self, t_name, t_exactMatch)
Model.getExteriorLoadInstancesByName = _getExteriorLoadInstancesByName

class ExteriorLights(ExteriorLoadInstance):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.ExteriorLights_swiginit(self, _openstudiomodelgeometry.new_ExteriorLights(*args))
    __swig_destroy__ = _openstudiomodelgeometry.delete_ExteriorLights

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.ExteriorLights_iddObjectType()

    @staticmethod
    def controlOptionValues() -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.ExteriorLights_controlOptionValues()

    @staticmethod
    def validControlOptionValues() -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.ExteriorLights_validControlOptionValues()

    def exteriorLightsDefinition(self) -> "openstudio::model::ExteriorLightsDefinition":
        return _openstudiomodelgeometry.ExteriorLights_exteriorLightsDefinition(self)

    def schedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.ExteriorLights_schedule(self)

    def controlOption(self) -> "std::string":
        return _openstudiomodelgeometry.ExteriorLights_controlOption(self)

    def isControlOptionDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorLights_isControlOptionDefaulted(self)

    def multiplier(self) -> "double":
        return _openstudiomodelgeometry.ExteriorLights_multiplier(self)

    def isMultiplierDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorLights_isMultiplierDefaulted(self)

    def endUseSubcategory(self) -> "std::string":
        return _openstudiomodelgeometry.ExteriorLights_endUseSubcategory(self)

    def isEndUseSubcategoryDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorLights_isEndUseSubcategoryDefaulted(self)

    def setExteriorLightsDefinition(self, exteriorLightsDefinition: "ExteriorLightsDefinition") -> "bool":
        return _openstudiomodelgeometry.ExteriorLights_setExteriorLightsDefinition(self, exteriorLightsDefinition)

    def setSchedule(self, schedule: "Schedule") -> "bool":
        return _openstudiomodelgeometry.ExteriorLights_setSchedule(self, schedule)

    def resetSchedule(self) -> "void":
        return _openstudiomodelgeometry.ExteriorLights_resetSchedule(self)

    def setControlOption(self, controlOption: "std::string") -> "bool":
        return _openstudiomodelgeometry.ExteriorLights_setControlOption(self, controlOption)

    def resetControlOption(self) -> "void":
        return _openstudiomodelgeometry.ExteriorLights_resetControlOption(self)

    def setMultiplier(self, multiplier: "double") -> "bool":
        return _openstudiomodelgeometry.ExteriorLights_setMultiplier(self, multiplier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.ExteriorLights_resetMultiplier(self)

    def setEndUseSubcategory(self, endUseSubcategory: "std::string") -> "bool":
        return _openstudiomodelgeometry.ExteriorLights_setEndUseSubcategory(self, endUseSubcategory)

    def resetEndUseSubcategory(self) -> "void":
        return _openstudiomodelgeometry.ExteriorLights_resetEndUseSubcategory(self)

    def facility(self) -> "openstudio::model::Facility":
        return _openstudiomodelgeometry.ExteriorLights_facility(self)

# Register ExteriorLights in _openstudiomodelgeometry:
_openstudiomodelgeometry.ExteriorLights_swigregister(ExteriorLights)

def ExteriorLights_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.ExteriorLights_iddObjectType()

def ExteriorLights_controlOptionValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.ExteriorLights_controlOptionValues()

def ExteriorLights_validControlOptionValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.ExteriorLights_validControlOptionValues()


def toExteriorLights(idfObject: "IdfObject") -> "boost::optional< openstudio::model::ExteriorLights >":
    return _openstudiomodelgeometry.toExteriorLights(idfObject)

def getExteriorLights(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::ExteriorLights >":
    return _openstudiomodelgeometry.getExteriorLights(t_model, t_handle)

def getExteriorLightss(t_model: "Model") -> "std::vector< openstudio::model::ExteriorLights,std::allocator< openstudio::model::ExteriorLights > >":
    return _openstudiomodelgeometry.getExteriorLightss(t_model)

def getExteriorLightsByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::ExteriorLights >":
    return _openstudiomodelgeometry.getExteriorLightsByName(t_model, t_name)

def getExteriorLightssByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::ExteriorLights,std::allocator< openstudio::model::ExteriorLights > >":
    return _openstudiomodelgeometry.getExteriorLightssByName(t_model, t_name, t_exactMatch)

def _to_ExteriorLights(self) -> OptionalExteriorLights:
    return toExteriorLights(self)
openstudioutilitiesidf.IdfObject.to_ExteriorLights = _to_ExteriorLights

def _getExteriorLights(self, t_handle: "UUID") -> OptionalExteriorLights:
    return getExteriorLights(self, t_handle)
Model.getExteriorLights = _getExteriorLights

def _getExteriorLights(self, t_handle_str: str) -> OptionalExteriorLights:
    return getExteriorLights(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getExteriorLights = _getExteriorLights

def _getExteriorLightss(self) -> ExteriorLightsVector:
    return getExteriorLightss(self)
Model.getExteriorLightss = _getExteriorLightss

def _getExteriorLightsByName(self, t_name: str) -> OptionalExteriorLights:
    return getExteriorLightsByName(self, t_name)
Model.getExteriorLightsByName = _getExteriorLightsByName

def _getExteriorLightssByName(self, t_name: str, t_exactMatch: bool) -> ExteriorLightsVector:
    return getExteriorLightssByName(self, t_name, t_exactMatch)
Model.getExteriorLightssByName = _getExteriorLightssByName

class ExteriorFuelEquipment(ExteriorLoadInstance):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.ExteriorFuelEquipment_swiginit(self, _openstudiomodelgeometry.new_ExteriorFuelEquipment(*args))
    __swig_destroy__ = _openstudiomodelgeometry.delete_ExteriorFuelEquipment

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_iddObjectType()

    @staticmethod
    def fuelTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_fuelTypeValues()

    @staticmethod
    def validFuelTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_validFuelTypeValues()

    def exteriorFuelEquipmentDefinition(self) -> "openstudio::model::ExteriorFuelEquipmentDefinition":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_exteriorFuelEquipmentDefinition(self)

    def schedule(self) -> "openstudio::model::Schedule":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_schedule(self)

    def fuelType(self) -> "std::string":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_fuelType(self)

    def multiplier(self) -> "double":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_multiplier(self)

    def isMultiplierDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_isMultiplierDefaulted(self)

    def endUseSubcategory(self) -> "std::string":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_endUseSubcategory(self)

    def isEndUseSubcategoryDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_isEndUseSubcategoryDefaulted(self)

    def setExteriorFuelEquipmentDefinition(self, exteriorFuelEquipmentDefinition: "ExteriorFuelEquipmentDefinition") -> "bool":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_setExteriorFuelEquipmentDefinition(self, exteriorFuelEquipmentDefinition)

    def setSchedule(self, schedule: "Schedule") -> "bool":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_setSchedule(self, schedule)

    def resetSchedule(self) -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_resetSchedule(self)

    def setFuelType(self, fuelType: "std::string") -> "bool":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_setFuelType(self, fuelType)

    def setMultiplier(self, multiplier: "double") -> "bool":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_setMultiplier(self, multiplier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_resetMultiplier(self)

    def setEndUseSubcategory(self, endUseSubcategory: "std::string") -> "bool":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_setEndUseSubcategory(self, endUseSubcategory)

    def resetEndUseSubcategory(self) -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_resetEndUseSubcategory(self)

    def facility(self) -> "openstudio::model::Facility":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_facility(self)

# Register ExteriorFuelEquipment in _openstudiomodelgeometry:
_openstudiomodelgeometry.ExteriorFuelEquipment_swigregister(ExteriorFuelEquipment)

def ExteriorFuelEquipment_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.ExteriorFuelEquipment_iddObjectType()

def ExteriorFuelEquipment_fuelTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.ExteriorFuelEquipment_fuelTypeValues()

def ExteriorFuelEquipment_validFuelTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.ExteriorFuelEquipment_validFuelTypeValues()


def toExteriorFuelEquipment(idfObject: "IdfObject") -> "boost::optional< openstudio::model::ExteriorFuelEquipment >":
    return _openstudiomodelgeometry.toExteriorFuelEquipment(idfObject)

def getExteriorFuelEquipment(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::ExteriorFuelEquipment >":
    return _openstudiomodelgeometry.getExteriorFuelEquipment(t_model, t_handle)

def getExteriorFuelEquipments(t_model: "Model") -> "std::vector< openstudio::model::ExteriorFuelEquipment,std::allocator< openstudio::model::ExteriorFuelEquipment > >":
    return _openstudiomodelgeometry.getExteriorFuelEquipments(t_model)

def getExteriorFuelEquipmentByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::ExteriorFuelEquipment >":
    return _openstudiomodelgeometry.getExteriorFuelEquipmentByName(t_model, t_name)

def getExteriorFuelEquipmentsByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::ExteriorFuelEquipment,std::allocator< openstudio::model::ExteriorFuelEquipment > >":
    return _openstudiomodelgeometry.getExteriorFuelEquipmentsByName(t_model, t_name, t_exactMatch)

def _to_ExteriorFuelEquipment(self) -> OptionalExteriorFuelEquipment:
    return toExteriorFuelEquipment(self)
openstudioutilitiesidf.IdfObject.to_ExteriorFuelEquipment = _to_ExteriorFuelEquipment

def _getExteriorFuelEquipment(self, t_handle: "UUID") -> OptionalExteriorFuelEquipment:
    return getExteriorFuelEquipment(self, t_handle)
Model.getExteriorFuelEquipment = _getExteriorFuelEquipment

def _getExteriorFuelEquipment(self, t_handle_str: str) -> OptionalExteriorFuelEquipment:
    return getExteriorFuelEquipment(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getExteriorFuelEquipment = _getExteriorFuelEquipment

def _getExteriorFuelEquipments(self) -> ExteriorFuelEquipmentVector:
    return getExteriorFuelEquipments(self)
Model.getExteriorFuelEquipments = _getExteriorFuelEquipments

def _getExteriorFuelEquipmentByName(self, t_name: str) -> OptionalExteriorFuelEquipment:
    return getExteriorFuelEquipmentByName(self, t_name)
Model.getExteriorFuelEquipmentByName = _getExteriorFuelEquipmentByName

def _getExteriorFuelEquipmentsByName(self, t_name: str, t_exactMatch: bool) -> ExteriorFuelEquipmentVector:
    return getExteriorFuelEquipmentsByName(self, t_name, t_exactMatch)
Model.getExteriorFuelEquipmentsByName = _getExteriorFuelEquipmentsByName

class ExteriorWaterEquipment(ExteriorLoadInstance):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _openstudiomodelgeometry.ExteriorWaterEquipment_swiginit(self, _openstudiomodelgeometry.new_ExteriorWaterEquipment(*args))
    __swig_destroy__ = _openstudiomodelgeometry.delete_ExteriorWaterEquipment

    @staticmethod
    def iddObjectType() -> "openstudio::IddObjectType":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_iddObjectType()

    def exteriorWaterEquipmentDefinition(self) -> "openstudio::model::ExteriorWaterEquipmentDefinition":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_exteriorWaterEquipmentDefinition(self)

    def schedule(self) -> "openstudio::model::Schedule":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_schedule(self)

    def multiplier(self) -> "double":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_multiplier(self)

    def isMultiplierDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_isMultiplierDefaulted(self)

    def endUseSubcategory(self) -> "std::string":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_endUseSubcategory(self)

    def isEndUseSubcategoryDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_isEndUseSubcategoryDefaulted(self)

    def setExteriorWaterEquipmentDefinition(self, exteriorWaterEquipmentDefinition: "ExteriorWaterEquipmentDefinition") -> "bool":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_setExteriorWaterEquipmentDefinition(self, exteriorWaterEquipmentDefinition)

    def setSchedule(self, schedule: "Schedule") -> "bool":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_setSchedule(self, schedule)

    def resetSchedule(self) -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_resetSchedule(self)

    def setMultiplier(self, multiplier: "double") -> "bool":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_setMultiplier(self, multiplier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_resetMultiplier(self)

    def setEndUseSubcategory(self, endUseSubcategory: "std::string") -> "bool":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_setEndUseSubcategory(self, endUseSubcategory)

    def resetEndUseSubcategory(self) -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_resetEndUseSubcategory(self)

    def facility(self) -> "openstudio::model::Facility":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_facility(self)

# Register ExteriorWaterEquipment in _openstudiomodelgeometry:
_openstudiomodelgeometry.ExteriorWaterEquipment_swigregister(ExteriorWaterEquipment)

def ExteriorWaterEquipment_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.ExteriorWaterEquipment_iddObjectType()


def toExteriorWaterEquipment(idfObject: "IdfObject") -> "boost::optional< openstudio::model::ExteriorWaterEquipment >":
    return _openstudiomodelgeometry.toExteriorWaterEquipment(idfObject)

def getExteriorWaterEquipment(t_model: "Model", t_handle: "UUID") -> "boost::optional< openstudio::model::ExteriorWaterEquipment >":
    return _openstudiomodelgeometry.getExteriorWaterEquipment(t_model, t_handle)

def getExteriorWaterEquipments(t_model: "Model") -> "std::vector< openstudio::model::ExteriorWaterEquipment,std::allocator< openstudio::model::ExteriorWaterEquipment > >":
    return _openstudiomodelgeometry.getExteriorWaterEquipments(t_model)

def getExteriorWaterEquipmentByName(t_model: "Model", t_name: "std::string const &") -> "boost::optional< openstudio::model::ExteriorWaterEquipment >":
    return _openstudiomodelgeometry.getExteriorWaterEquipmentByName(t_model, t_name)

def getExteriorWaterEquipmentsByName(t_model: "Model", t_name: "std::string const &", t_exactMatch: "bool") -> "std::vector< openstudio::model::ExteriorWaterEquipment,std::allocator< openstudio::model::ExteriorWaterEquipment > >":
    return _openstudiomodelgeometry.getExteriorWaterEquipmentsByName(t_model, t_name, t_exactMatch)

def _to_ExteriorWaterEquipment(self) -> OptionalExteriorWaterEquipment:
    return toExteriorWaterEquipment(self)
openstudioutilitiesidf.IdfObject.to_ExteriorWaterEquipment = _to_ExteriorWaterEquipment

def _getExteriorWaterEquipment(self, t_handle: "UUID") -> OptionalExteriorWaterEquipment:
    return getExteriorWaterEquipment(self, t_handle)
Model.getExteriorWaterEquipment = _getExteriorWaterEquipment

def _getExteriorWaterEquipment(self, t_handle_str: str) -> OptionalExteriorWaterEquipment:
    return getExteriorWaterEquipment(self, openstudioutilitiescore.toUUID(t_handle_str))
Model.getExteriorWaterEquipment = _getExteriorWaterEquipment

def _getExteriorWaterEquipments(self) -> ExteriorWaterEquipmentVector:
    return getExteriorWaterEquipments(self)
Model.getExteriorWaterEquipments = _getExteriorWaterEquipments

def _getExteriorWaterEquipmentByName(self, t_name: str) -> OptionalExteriorWaterEquipment:
    return getExteriorWaterEquipmentByName(self, t_name)
Model.getExteriorWaterEquipmentByName = _getExteriorWaterEquipmentByName

def _getExteriorWaterEquipmentsByName(self, t_name: str, t_exactMatch: bool) -> ExteriorWaterEquipmentVector:
    return getExteriorWaterEquipmentsByName(self, t_name, t_exactMatch)
Model.getExteriorWaterEquipmentsByName = _getExteriorWaterEquipmentsByName



